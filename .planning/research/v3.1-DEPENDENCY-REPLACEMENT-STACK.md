# Technology Stack: Dependency Replacement

**Project:** gaz dependency internalization (v3.1)
**Researched:** 2026-02-01
**Mode:** Stack dimension for subsequent milestone

## Executive Summary

This research addresses replacing 4 external dependencies with internal implementations:
- `jpillora/backoff` -> internal backoff in `worker/` 
- `robfig/cron/v3` -> internal cron engine in `cron/internal/`
- `lmittmann/tint` -> internal colored handler in `logger/`
- `alexliesenfeld/health` -> internal health checker in `health/`

**Key decision:** Place internal implementations within existing packages, NOT as new top-level `internal/` packages. This maintains API compatibility and follows gaz's established pattern where each feature package owns its internals.

---

## Package Structure Recommendations

### Decision: Internal Subpackages, Not Top-Level Internal

**Recommendation:** Use `{package}/internal/` subpackages within existing packages.

**Rationale:**
1. **API stability:** Current APIs (`worker.BackoffConfig`, `cron.Scheduler`, etc.) remain unchanged
2. **gaz convention:** Existing packages (`config/viper/`, `di/`) use nested structure
3. **Encapsulation:** `internal/` visibility rules prevent external import of implementation details
4. **Minimal diff:** Only internal imports change; user-facing code untouched

**Structure:**
```
cron/
  internal/
    engine/         # Cron engine (from cron/internal)
      cron.go       # Main scheduler
      parser.go     # Cron expression parser  
      spec.go       # Schedule specification
      chain.go      # Job wrappers
    schedule/       # Schedule interfaces and types
      schedule.go
  scheduler.go      # Public Scheduler wraps internal/engine
  ...

worker/
  internal/
    backoff/        # Backoff implementation
      backoff.go    # Core interface + simple types
      exponential.go # ExponentialBackOff
  backoff.go        # Public BackoffConfig unchanged
  ...

logger/
  internal/
    tint/           # Colored slog handler
      handler.go    # tint.Handler port
      options.go
  provider.go       # Uses internal/tint when Format=="text"
  ...

health/
  internal/
    checker/        # Health check engine
      checker.go    # Main Checker type
      check.go      # Check type and options
      result.go     # CheckerResult, AvailabilityStatus
      handler.go    # HTTP handler
  manager.go        # Manager wraps internal/checker
  ...
```

### Why NOT `internal/backoffx/`, `internal/cron/internal/`, etc.

Placing packages at `gaz/internal/` would:
1. Break the "package owns its internals" pattern
2. Create cross-package dependencies that complicate testing
3. Scatter related code across the codebase
4. Make future refactoring harder

---

## Per-Dependency Analysis

### 1. jpillora/backoff Replacement

**Current usage:** `worker/backoff.go` and `worker/supervisor.go`

**API surface used:**
```go
// In BackoffConfig.NewBackoff()
&backoff.Backoff{
    Min:    c.Min,
    Max:    c.Max,
    Factor: c.Factor,
    Jitter: c.Jitter,
}

// In supervisor.go
s.backoff.Duration()  // Get next delay
s.backoff.Reset()     // Reset after stable run
```

**Internal implementation needed:**
```go
// worker/internal/backoff/backoff.go
type Backoff struct {
    Min, Max  time.Duration
    Factor    float64
    Jitter    bool
    attempt   int64
}

func (b *Backoff) Duration() time.Duration { ... }
func (b *Backoff) Reset() { ... }
```

**Reference code to adapt:** `_tmp_trust/srex/backoff/`
- Use exponential.go algorithm, but simplify
- Skip retry utilities (Retry, RetryWithData) - not needed
- Skip context-aware backoff - not needed
- Skip Ticker - not needed

**What NOT to copy:**
- `PermanentError` type and retry semantics - gaz uses simpler model
- `Timer` interface abstraction - unnecessary for worker use case
- `OperationWithData` generics - not needed
- `github.com/pkg/errors` dependency - use standard errors

**Changes to `worker/` package:**
1. Create `worker/internal/backoff/backoff.go`
2. Update `worker/backoff.go`: `NewBackoff()` returns `*internal/backoff.Backoff`
3. Update `worker/supervisor.go`: import path changes only
4. Remove jpillora/backoff from go.mod

**Confidence:** HIGH - Simple port, clear API boundary

---

### 2. robfig/cron/v3 Replacement

**Current usage:** `cron/scheduler.go`, `cron/logger.go`, `cron/wrapper.go`

**API surface used:**
```go
// cron.New() with options
c := cron.New(
    cron.WithLogger(adapter),
    cron.WithChain(cron.SkipIfStillRunning(adapter)),
)

// AddJob for registration
_, err := s.cron.AddJob(schedule, wrapper)

// Start/Stop lifecycle
s.cron.Start()
cronCtx := s.cron.Stop()
<-cronCtx.Done()
```

**Internal implementation needed:**
```go
// cron/internal/engine/cron.go
type Cron struct { ... }
func New(opts ...Option) *Cron
func (c *Cron) AddJob(spec string, cmd Job) (EntryID, error)
func (c *Cron) Start()
func (c *Cron) Stop() context.Context

// cron/internal/engine/option.go
type Option func(*Cron)
func WithLogger(logger Logger) Option
func WithChain(wrappers ...JobWrapper) Option

// cron/internal/engine/chain.go
type JobWrapper func(Job) Job
func SkipIfStillRunning(logger Logger) JobWrapper
```

**Reference code to adapt:** `_tmp_trust/cron/internal/`
- Port cron.go, parser.go, spec.go, chain.go, option.go, constantdelay.go
- Replace `logx.Logger` with `*slog.Logger` (gaz standard)
- Keep the Job interface simple: `Run()` only

**What NOT to copy:**
- `dev.azure.com/SovosGvatLatam/Trust-Services/_git/xgo-lib.git/logx` - use slog directly
- Complex logger abstraction - use slog.Logger

**Logger interface adaptation:**
```go
// cron/internal/engine/logger.go
// Use slog.Logger directly, not an interface
type Logger interface {
    Info(msg string, args ...any)
    Error(msg string, args ...any)
}

// Adapter wraps slog.Logger
type slogLogger struct{ *slog.Logger }
```

**Changes to `cron/` package:**
1. Create `cron/internal/engine/` with full cron engine
2. Update `cron/scheduler.go`: wrap internal engine, keep public API identical
3. Remove `cron/logger.go` adapter (internalize into engine)
4. Remove robfig/cron/v3 from go.mod

**Confidence:** HIGH - Complete reference implementation exists

---

### 3. lmittmann/tint Replacement

**Current usage:** `logger/provider.go`

**API surface used:**
```go
handler = tint.NewHandler(os.Stdout, &tint.Options{
    Level:      lvl,
    AddSource:  cfg.AddSource,
    TimeFormat: "15:04:05.000",
})
```

**Internal implementation needed:**
```go
// logger/internal/tint/handler.go
type Handler struct { ... }
type Options struct {
    Level      slog.Leveler
    AddSource  bool
    TimeFormat string
    NoColor    bool  // For CI/testing
}
func NewHandler(w io.Writer, opts *Options) *Handler
```

**Implementation approach:**
This is the ONLY dependency without reference implementation in `_tmp_trust/`. Two options:

**Option A: Minimal colored handler (RECOMMENDED)**
- Implement basic ANSI coloring for level and message
- ~150-200 lines of code
- Support: Level colors, time formatting, source info
- Skip: Theme customization, ReplaceAttr, custom colors

**Option B: Port lmittmann/tint**
- Full feature parity
- More complex (~400 lines)
- MIT licensed, can fork

**Recommend Option A because:**
1. gaz only uses basic features (level, source, time format)
2. Simpler code = easier maintenance
3. Can always enhance later

**Minimal handler spec:**
```go
// Level colors (ANSI)
const (
    colorReset  = "\033[0m"
    colorRed    = "\033[31m"    // ERROR
    colorYellow = "\033[33m"    // WARN
    colorGreen  = "\033[32m"    // INFO
    colorBlue   = "\033[34m"    // DEBUG
)

// Handler implements slog.Handler
type Handler struct {
    w          io.Writer
    level      slog.Leveler
    addSource  bool
    timeFormat string
    noColor    bool
    
    // Pre-built group/attr context
    preformatted []byte
    groups       []string
}
```

**Changes to `logger/` package:**
1. Create `logger/internal/tint/handler.go`
2. Update `logger/provider.go`: use internal handler
3. Remove lmittmann/tint from go.mod

**Confidence:** MEDIUM - No reference, but API is simple

---

### 4. alexliesenfeld/health Replacement

**Current usage:** `health/manager.go`, `health/handlers.go`, `health/writer.go`

**API surface used:**
```go
// In manager.go
m.livenessChecks = append(m.livenessChecks, health.Check{
    Name:  name,
    Check: check,
})

checker := health.NewChecker(finalOpts...)

// In handlers.go
return health.NewHandler(checker,
    health.WithResultWriter(NewIETFResultWriter()),
    health.WithStatusCodeUp(http.StatusOK),
    health.WithStatusCodeDown(http.StatusServiceUnavailable),
)

// Types used
health.Check
health.Checker
health.CheckerOption
health.CheckerResult
health.AvailabilityStatus
```

**Internal implementation needed:**
```go
// health/internal/checker/types.go
type AvailabilityStatus int
const (
    StatusUnknown AvailabilityStatus = iota
    StatusUp
    StatusDown
)

type Check struct {
    Name    string
    Timeout time.Duration
    Check   func(context.Context) error
}

type CheckResult struct {
    Status    AvailabilityStatus
    Timestamp time.Time
    Error     error
}

type CheckerResult struct {
    Status  AvailabilityStatus
    Details map[string]CheckResult
}

// health/internal/checker/checker.go
type Checker interface {
    Check(ctx context.Context) CheckerResult
}

type checker struct {
    checks  []Check
    timeout time.Duration
    cache   *cachedResult  // Optional caching
}

func NewChecker(opts ...Option) Checker
func WithCheck(check Check) Option
func WithTimeout(timeout time.Duration) Option
func WithCacheDuration(duration time.Duration) Option

// health/internal/checker/handler.go
type HandlerOption func(*handlerConfig)
func NewHandler(checker Checker, opts ...HandlerOption) http.Handler
func WithResultWriter(w ResultWriter) HandlerOption
func WithStatusCodeUp(code int) HandlerOption
func WithStatusCodeDown(code int) HandlerOption

type ResultWriter interface {
    Write(result *CheckerResult, statusCode int, w http.ResponseWriter, r *http.Request) error
}
```

**No reference code available.** Implementation from scratch based on alexliesenfeld/health API.

**Implementation considerations:**
1. **Synchronous checks by default** - gaz doesn't use periodic checks
2. **Result caching** - optional, can skip for v1
3. **IETF writer stays** - `health/writer.go` already implements custom ResultWriter

**Changes to `health/` package:**
1. Create `health/internal/checker/` with full implementation
2. Update `health/manager.go`: use internal checker types
3. Update `health/handlers.go`: use internal handler
4. Keep `health/writer.go` mostly unchanged (just type imports)
5. Remove alexliesenfeld/health from go.mod

**Confidence:** MEDIUM - No reference, but alexliesenfeld/health is well-documented

---

## API Compatibility Matrix

| Package | Public API | Change Required | Reason |
|---------|-----------|-----------------|--------|
| `worker.BackoffConfig` | `NewBackoff() *backoff.Backoff` | Return type change | Now returns internal type |
| `worker.BackoffOption` | `With*()` functions | None | Unchanged |
| `cron.Scheduler` | `NewScheduler()`, `RegisterJob()` | None | Wraps internal |
| `cron.CronJob` | Interface | None | Unchanged |
| `logger.NewLogger()` | Returns `*slog.Logger` | None | Unchanged |
| `logger.Config` | Struct | None | Unchanged |
| `health.Manager` | `Add*Check()` methods | None | Unchanged |
| `health.Registrar` | Interface | None | Unchanged |
| `health.CheckFunc` | Type alias | None | Unchanged |
| `health.*Handler()` | Methods | None | Unchanged |

**Breaking change note:** `worker.BackoffConfig.NewBackoff()` currently returns `*backoff.Backoff` (jpillora's type). After change, returns internal type. However, the interface is identical:
- `Duration() time.Duration`
- `Reset()`

Users calling these methods won't see a difference. Users storing the return value with explicit type annotation will need update. This is acceptable for an internal framework.

---

## Implementation Order

**Recommended sequence:**

1. **worker/internal/backoff/** (1-2 hours)
   - Simplest dependency
   - Smallest API surface
   - Good warmup for pattern

2. **logger/internal/tint/** (2-3 hours)
   - No reference code, needs implementation
   - But slog.Handler interface is well-defined
   - Isolated, no cross-package deps

3. **health/internal/checker/** (3-4 hours)
   - More complex API
   - Existing writer.go provides template
   - Manager already abstracts most complexity

4. **cron/internal/engine/** (4-6 hours)
   - Most complex, largest codebase
   - Complete reference in `_tmp_trust/cron/internal/`
   - Do last when pattern is established

**Total estimate:** 10-15 hours

---

## Testing Strategy

### Unit Tests

Each internal package needs comprehensive tests:

```
worker/internal/backoff/
  backoff_test.go       # Duration(), Reset(), jitter behavior

logger/internal/tint/
  handler_test.go       # Output format, colors, levels

health/internal/checker/
  checker_test.go       # Check execution, aggregation
  handler_test.go       # HTTP response codes, body format

cron/internal/engine/
  cron_test.go          # Start, Stop, AddJob
  parser_test.go        # Expression parsing (extensive)
  spec_test.go          # Next() time calculation
  chain_test.go         # Job wrappers
```

### Integration Tests

Existing integration tests in `tests/` should continue passing:
- `tests/health_test.go` - validates health endpoints work
- Top-level `*_test.go` files exercise full lifecycle

### Testing Helpers

Reference implementations include tests - adapt them:
- `_tmp_trust/cron/internal/*_test.go` -> `cron/internal/engine/*_test.go`
- `_tmp_trust/srex/backoff/*_test.go` -> `worker/internal/backoff/*_test.go`

---

## Dependencies After Removal

**Before:**
```go
require (
    github.com/alexliesenfeld/health v0.8.1
    github.com/jpillora/backoff v1.0.0
    github.com/lmittmann/tint v1.1.2
    github.com/robfig/cron/v3 v3.0.1
    // ... other deps
)
```

**After:**
```go
require (
    // These four removed
    // ... other deps remain
)
```

**Impact:**
- 4 fewer direct dependencies
- Smaller go.sum
- No transitive dependencies from these libraries
- Full control over implementations

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Parser bugs in cron expressions | Medium | High | Port extensive test suite from cron/internal |
| Color output issues in different terminals | Low | Low | Add `NoColor` option, test in CI |
| Health check timing edge cases | Low | Medium | Comprehensive timeout tests |
| Backoff randomness not truly random | Low | Low | Use crypto/rand for jitter if needed |

---

## What NOT to Build

1. **Retry utilities** - gaz workers use supervision, not retry-with-backoff pattern
2. **Periodic health checks** - gaz uses on-demand checks only
3. **Theme customization for logger** - Only basic colors needed
4. **Cron seconds field** - gaz uses standard 5-field format only
5. **Complex caching for health** - Keep it simple, no periodic refresh

---

## Summary

| Dependency | Replacement Location | Reference Available | Complexity |
|------------|---------------------|---------------------|------------|
| jpillora/backoff | `worker/internal/backoff/` | Yes (_tmp_trust/srex/backoff/) | Low |
| robfig/cron/v3 | `cron/internal/engine/` | Yes (_tmp_trust/cron/internal/) | High |
| lmittmann/tint | `logger/internal/tint/` | No | Medium |
| alexliesenfeld/health | `health/internal/checker/` | No | Medium |

**Overall confidence:** HIGH

The approach is straightforward:
1. Create internal subpackages in existing feature packages
2. Port or implement the minimal API surface actually used
3. Update wrapper code to use internal implementations
4. Remove external dependencies

This preserves API compatibility while eliminating external dependencies.
