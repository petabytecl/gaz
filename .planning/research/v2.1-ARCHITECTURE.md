# Architecture Patterns: GAZ v2.1 Integration

**Domain:** Go DI Framework Enhancement
**Researched:** 2026-01-29
**Confidence:** HIGH (based on direct codebase analysis + Context7 Fx documentation)

## Executive Summary

This document analyzes how the v2.1 features integrate with GAZ's existing architecture. Each proposed feature has clear integration points based on current patterns. The key architectural insight: **GAZ already implements interface-based lifecycle** in `di/service.go` via `Starter`/`Stopper` interfaces - the v2.1 work extends this, not creates it.

## Current Architecture Overview

```
gaz/                          # Core App builder (depends on all subpackages)
  app.go                      # App struct, lifecycle orchestration
  lifecycle.go                # Starter/Stopper interfaces (re-export)
  lifecycle_engine.go         # Startup/Shutdown ordering
  cobra.go                    # Cobra integration, WithCobra()
  config_manager.go           # Deprecated wrapper for config.Manager

gaz/di/                       # Standalone DI container
  container.go                # Container struct, resolution
  registration.go             # For[T]() builder, scope/lifecycle
  service.go                  # ServiceWrapper implementations
  lifecycle.go                # Starter/Stopper interfaces (canonical)
  resolution.go               # Resolve[T](), MustResolve[T]()
  inject.go                   # Struct tag injection (gaz:"inject")
  testing.go                  # NewTestContainer()
  types.go                    # TypeName[T]() reflection helpers

gaz/config/                   # Standalone configuration
  manager.go                  # Config loading orchestration
  backend.go                  # Backend interface
  types.go                    # Defaulter, Validator interfaces

gaz/worker/                   # Background workers
  worker.go                   # Worker interface
  manager.go                  # Lifecycle coordination
  supervisor.go               # Panic recovery, circuit breaker

gaz/cron/                     # Scheduled tasks
  job.go                      # CronJob interface
  scheduler.go                # Job registration and execution

gaz/eventbus/                 # Pub/sub
  eventbus.go                 # Publish[T](), Subscribe[T]()

gaz/health/                   # Health checks
  module.go                   # Module registration pattern
  manager.go                  # Check aggregation
```

## Feature Integration Analysis

### 1. Interface Auto-Detection for Starter/Stopper

**Current State:**
- `di.Starter` and `di.Stopper` interfaces already defined in `di/lifecycle.go`
- `baseService.runStartLifecycle()` in `di/service.go` already calls `starter.OnStart()` if instance implements `Starter`
- `baseService.runStopLifecycle()` already calls `stopper.OnStop()` if instance implements `Stopper`

**Discovery:** The interface auto-detection is ALREADY IMPLEMENTED in `di/service.go`:

```go
// di/service.go lines 77-98
func (s *baseService) runStartLifecycle(ctx context.Context, instance any) error {
    if err := s.runStartHooks(ctx, instance); err != nil {
        return err
    }
    if starter, ok := instance.(Starter); ok {  // <-- AUTO-DETECTION EXISTS
        if err := starter.OnStart(ctx); err != nil {
            return fmt.Errorf("service %s: start failed: %w", s.serviceName, err)
        }
    }
    return nil
}
```

**Gap:** The issue is that `HasLifecycle()` currently only returns true if explicit hooks exist:

```go
// di/service.go line 55-57
func (s *baseService) HasLifecycle() bool {
    return len(s.startHooks) > 0 || len(s.stopHooks) > 0  // <-- Misses interface check
}
```

**Integration Point:** Modify `di/service.go`

**Changes Required:**
1. Update `HasLifecycle()` to also check if the instance implements `Starter` or `Stopper`
2. Problem: At `HasLifecycle()` call time, instance may not be built yet (lazy singletons)
3. Solution: Store a flag during registration if the type implements lifecycle interfaces

**Suggested Approach:**
```go
// In RegistrationBuilder, check type at registration time
type RegistrationBuilder[T any] struct {
    // ... existing fields
    implementsLifecycle bool  // Set via reflection on T
}

// In For[T]():
func For[T any](c *Container) *RegistrationBuilder[T] {
    // Check if T implements Starter or Stopper using reflection
    var zero T
    _, isStarter := any(zero).(Starter)
    _, isStopper := any(zero).(Stopper)
    return &RegistrationBuilder[T]{
        // ...
        implementsLifecycle: isStarter || isStopper,
    }
}
```

**Build Order:** Early (Phase 1) - foundational for subsequent features

---

### 2. Build Info Package

**Current State:**
- No build info functionality exists
- Cobra integration in `gaz/cobra.go` handles command lifecycle

**Integration Point:** New `gaz/buildinfo/` package

**Cobra Pattern Reference:** (from Context7 Cobra docs)
```go
// Cobra's native version support
type Command struct {
    Version string  // If non-empty, adds --version flag
}
cmd.SetVersionTemplate(s string)
```

**Suggested Architecture:**
```
gaz/buildinfo/
  buildinfo.go      # Info struct, Set() for ldflags
  provider.go       # DI integration helpers
```

**Design:**
```go
package buildinfo

// Info holds build metadata set via ldflags
type Info struct {
    Version   string
    Commit    string
    Branch    string
    BuildDate string
    GoVersion string
}

// Default instance for ldflags injection
var (
    version   = "dev"
    commit    = "unknown"
    branch    = "unknown"
    buildDate = "unknown"
)

// Get returns the current build info
func Get() Info {
    return Info{
        Version:   version,
        Commit:    commit,
        Branch:    branch,
        BuildDate: buildDate,
        GoVersion: runtime.Version(),
    }
}

// Module registers build info for DI
func Module(c *gaz.Container) error {
    return gaz.For[Info](c).Instance(Get())
}
```

**Cobra Integration:**
- App.WithCobra() can auto-set `cmd.Version` from buildinfo.Get()
- Or: User manually sets `rootCmd.Version = buildinfo.Get().Version`

**Build Order:** Middle (Phase 2) - standalone, no dependencies on other new features

---

### 3. Args Injection (CLI Arguments as DI Dependency)

**Current State:**
- Cobra passes `args []string` to Run functions
- No DI mechanism for accessing args outside Run context

**Integration Point:** `gaz/cobra.go` + new type in core `gaz` package

**Suggested Architecture:**
```go
// In gaz/types.go or gaz/args.go
package gaz

// Args wraps CLI arguments for DI injection
type Args []string

// In cobra.go bootstrap():
func (a *App) bootstrap(ctx context.Context, cmd *cobra.Command, args []string) error {
    // Register args for DI access
    if err := For[Args](a.container).Replace().Instance(Args(args)); err != nil {
        return err
    }
    // ... rest of bootstrap
}
```

**Usage:**
```go
func NewMyService(args gaz.Args) *MyService {
    // Access CLI args via DI
}
```

**Build Order:** Early (Phase 1) - simple, useful immediately

---

### 4. Pre/Post Run Hooks for App

**Current State:**
- `App.Run()` manages lifecycle (signal handling, shutdown)
- `App.Start()` starts services
- No hooks between Build() and Start(), or after Stop()

**Cobra Reference:** (from Context7)
```go
// Cobra's hook execution order:
// PersistentPreRun -> PreRun -> Run -> PostRun -> PersistentPostRun
```

**Integration Point:** `gaz/app.go`

**Suggested Architecture:**
```go
type App struct {
    // ... existing fields
    preRunHooks  []func(context.Context) error
    postRunHooks []func(context.Context) error
}

func (a *App) OnPreRun(fn func(context.Context) error) *App {
    a.preRunHooks = append(a.preRunHooks, fn)
    return a
}

func (a *App) OnPostRun(fn func(context.Context) error) *App {
    a.postRunHooks = append(a.postRunHooks, fn)
    return a
}

// In Run(), execute hooks at appropriate points:
// Build() -> preRunHooks -> Start services -> waitForShutdown -> Stop -> postRunHooks
```

**Build Order:** Middle (Phase 2) - extends existing App API

---

### 5. Frame Introspection Utilities (Debug Package)

**Current State:**
- No debug utilities exist
- Error wrapping uses standard library

**Integration Point:** New `gaz/debug/` package (or `gaz/internal/debug/`)

**Suggested Architecture:**
```
gaz/debug/
  frame.go     # CallerInfo, stack frame utilities
  trace.go     # Registration tracing helpers
```

**Design:**
```go
package debug

import "runtime"

// CallerInfo returns caller information at a specific depth
func CallerInfo(skip int) (file string, line int, fn string) {
    pc, file, line, ok := runtime.Caller(skip + 1)
    if !ok {
        return "unknown", 0, "unknown"
    }
    fn = runtime.FuncForPC(pc).Name()
    return file, line, fn
}

// Trace captures registration location for error messages
type Trace struct {
    File string
    Line int
    Func string
}

func Capture() Trace {
    file, line, fn := CallerInfo(1)
    return Trace{File: file, Line: line, Func: fn}
}
```

**Build Order:** Late (Phase 3) - nice-to-have, not blocking other features

---

### 6. Service Builder Pattern (Pre-configured Providers)

**Current State:**
- Health module uses `Module(c *gaz.Container) error` pattern
- Manual provider chaining with For[T]()

**Fx Reference:** (from Context7)
```go
// Fx uses fx.Module for grouping:
fx.Module("server",
    fx.Provide(NewHTTPServer),
    fx.Provide(NewRouter),
)
```

**Integration Point:** New `gaz/service/` package or pattern in `gaz/`

**Suggested Architecture:**
Option A: **Function-based (current pattern)**
```go
package service

func HTTPServer(c *gaz.Container, opts ...ServerOption) error {
    cfg := defaultServerConfig()
    for _, opt := range opts {
        opt(cfg)
    }
    return gaz.For[*http.Server](c).
        OnStart(func(ctx context.Context, s *http.Server) error { ... }).
        OnStop(func(ctx context.Context, s *http.Server) error { ... }).
        Provider(func(c *gaz.Container) (*http.Server, error) { ... })
}
```

Option B: **Struct-based builder**
```go
package service

type Builder struct {
    container *gaz.Container
    providers []func(*gaz.Container) error
}

func New(c *gaz.Container) *Builder {
    return &Builder{container: c}
}

func (b *Builder) WithHTTPServer(opts ...ServerOption) *Builder {
    b.providers = append(b.providers, func(c *gaz.Container) error {
        return httpServer(c, opts...)
    })
    return b
}

func (b *Builder) Register() error {
    for _, p := range b.providers {
        if err := p(b.container); err != nil {
            return err
        }
    }
    return nil
}
```

**Recommendation:** Option A (function-based) matches existing health.Module() pattern

**Build Order:** Late (Phase 3) - convenience layer, not core

---

### 7. Unified Provider Type

**Current State:**
- ConfigProvider interface for flag-based config
- For[T]() builder for registration
- Separate hook registration

**Fx Reference:**
```go
fx.Provide(
    fx.Annotate(
        NewHTTPServer,
        fx.OnStart(startServer),
        fx.OnStop(stopServer),
    ),
)
```

**Integration Point:** Extend `di/registration.go`

**Suggested Architecture:**
```go
// Provider encapsulates constructor + config + lifecycle
type Provider[T any] struct {
    Constructor func(*Container) (T, error)
    Namespace   string          // Config namespace
    Flags       []ConfigFlag    // Config flags
    OnStart     func(context.Context, T) error
    OnStop      func(context.Context, T) error
}

// RegisterProvider registers a fully-configured provider
func RegisterProvider[T any](c *Container, p Provider[T]) error {
    builder := For[T](c)
    if p.OnStart != nil {
        builder = builder.OnStart(p.OnStart)
    }
    if p.OnStop != nil {
        builder = builder.OnStop(p.OnStop)
    }
    // ConfigProvider integration would need App-level handling
    return builder.Provider(p.Constructor)
}
```

**Challenge:** ConfigProvider handling is at App level, not DI level
**Solution:** Provider[T] registers in DI, and if instance implements ConfigProvider, App collects it during Build()

**Build Order:** Late (Phase 3) - API convenience, requires careful design

---

### 8. Test Builder (fxtest-like)

**Current State:**
- `di.NewTestContainer()` exists but is trivial (just calls New())
- No lifecycle testing helpers

**Fx fxtest Reference:** (from pkg.go.dev)
```go
// fxtest.App wraps fx.App with testing helpers
type App struct {
    *fx.App
}
func New(tb TB, opts ...fx.Option) *App
func (app *App) RequireStart() *App
func (app *App) RequireStop()

// fxtest.Lifecycle for unit testing hooks
type Lifecycle struct {}
func NewLifecycle(t TB, opts ...LifecycleOption) *Lifecycle
func (l *Lifecycle) RequireStart() *Lifecycle
func (l *Lifecycle) RequireStop()
```

**Integration Point:** New `gaz/testing/` or `gaz/gaztest/` package

**Suggested Architecture:**
```go
package gaztest

import "testing"

// TB is the testing interface subset
type TB interface {
    Helper()
    Fatalf(format string, args ...any)
    Logf(format string, args ...any)
    Cleanup(func())
}

// App wraps gaz.App with testing helpers
type App struct {
    *gaz.App
    tb TB
}

func New(tb TB, opts ...gaz.Option) *App {
    tb.Helper()
    app := gaz.New(opts...)
    tb.Cleanup(func() {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        _ = app.Stop(ctx)
    })
    return &App{App: app, tb: tb}
}

func (a *App) RequireStart() *App {
    a.tb.Helper()
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := a.Build(); err != nil {
        a.tb.Fatalf("Build failed: %v", err)
    }
    if err := a.Start(ctx); err != nil {
        a.tb.Fatalf("Start failed: %v", err)
    }
    return a
}

func (a *App) RequireStop() {
    a.tb.Helper()
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := a.Stop(ctx); err != nil {
        a.tb.Fatalf("Stop failed: %v", err)
    }
}

// Container wraps di.Container with testing helpers
type Container struct {
    *di.Container
    tb TB
}

func NewContainer(tb TB) *Container {
    tb.Helper()
    return &Container{Container: di.New(), tb: tb}
}

func (c *Container) MustBuild() *Container {
    c.tb.Helper()
    if err := c.Build(); err != nil {
        c.tb.Fatalf("Build failed: %v", err)
    }
    return c
}
```

**Build Order:** Late (Phase 4) - convenience layer for testing

---

## Component Dependency Map

```
                    +------------------+
                    |   gaz/buildinfo  |  (standalone)
                    +------------------+
                            |
                            v
+------------------+  +------------------+  +------------------+
|     gaz/debug    |  |     gaz/di       |  |   gaz/config     |
+------------------+  +------------------+  +------------------+
        |                     |                      |
        |   +------------------+----------------------+
        |   |
        v   v
+--------------------------------------------------+
|                     gaz (core)                    |
| - App, Container (wrapper), lifecycle            |
| - Args injection                                  |
| - Pre/Post run hooks                              |
+--------------------------------------------------+
        |
        v
+------------------+
|   gaz/gaztest    |  (testing layer)
+------------------+
```

## Suggested Build Order

Based on dependencies and value delivery:

| Phase | Feature | Package | Complexity | Value |
|-------|---------|---------|------------|-------|
| 1 | Interface auto-detection fix | di/ | Low | High |
| 1 | Args injection | gaz/ | Low | Medium |
| 2 | Build Info | buildinfo/ | Low | Medium |
| 2 | Pre/Post run hooks | gaz/ | Low | Medium |
| 3 | Frame introspection | debug/ | Low | Low |
| 3 | Service Builder | service/ | Medium | Medium |
| 3 | Unified Provider | di/ | Medium | Medium |
| 4 | Test Builder | gaztest/ | Medium | High |

**Rationale:**
1. **Phase 1 (Foundation):** Interface auto-detection is a bug fix that enables cleaner service definitions. Args injection is simple and immediately useful.
2. **Phase 2 (Core Enhancement):** Build info and hooks are standalone additions that improve developer experience.
3. **Phase 3 (Convenience APIs):** Builder patterns and unified providers are API sugar that can wait.
4. **Phase 4 (Testing):** Test utilities benefit from having the other features in place first.

## New vs Modified Components

| Component | Status | Changes |
|-----------|--------|---------|
| `gaz/di/service.go` | **Modify** | Fix `HasLifecycle()` to check interface implementation |
| `gaz/di/registration.go` | **Modify** | Track interface implementation at registration |
| `gaz/app.go` | **Modify** | Add pre/post hooks, Args injection |
| `gaz/cobra.go` | **Modify** | Register Args in bootstrap() |
| `gaz/buildinfo/` | **New** | Build metadata package |
| `gaz/debug/` | **New** | Frame introspection utilities |
| `gaz/gaztest/` | **New** | Testing helpers (fxtest-like) |
| `gaz/service/` | **New** (optional) | Pre-configured service builders |

## Key Architectural Principles

1. **Extend, don't replace:** All changes build on existing patterns (For[T](), Module())
2. **Subpackage autonomy:** New packages (buildinfo, debug, gaztest) are standalone-capable
3. **Core stays thin:** Complex logic goes in subpackages, core orchestrates
4. **Backward compatible:** Existing code continues to work unchanged

## Anti-Patterns to Avoid

1. **Don't modify di.Container interface** - Keep it stable for existing users
2. **Don't add global state** - All state in App or Container instances
3. **Don't couple testing package to App internals** - Use public API only
4. **Don't break lazy instantiation** - Interface detection at registration, not resolution

## Sources

| Source | Confidence | Used For |
|--------|------------|----------|
| GAZ codebase analysis | HIGH | Current architecture understanding |
| Context7 /uber-go/fx | HIGH | Lifecycle patterns, fxtest reference |
| Context7 /spf13/cobra | HIGH | Version flag, hook execution order |
| pkg.go.dev/fxtest | HIGH | Test helper API design |

---
*Research completed: 2026-01-29*
