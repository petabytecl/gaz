# Domain Pitfalls: v2.1 API Enhancement Features

**Project:** GAZ v2.1 - Interface Auto-detection and RuntimeX-inspired Features
**Researched:** 2026-01-29
**Confidence:** HIGH (verified against GAZ codebase + authoritative sources)

This document catalogs specific pitfalls when adding interface auto-detection, build info, args injection, hooks, frame utils, service builder, unified provider, and test builder features to GAZ's existing DI framework.

---

## Critical Pitfalls

Mistakes that cause rewrites or breaking API changes.

---

### Pitfall 1: Pointer vs Value Receiver Interface Detection

**What goes wrong:** Interface auto-detection incorrectly determines whether a type implements an interface due to Go's method set rules.

**Why it happens:** In Go:
- Value types (`T`) only have methods with value receivers
- Pointer types (`*T`) have methods with both value AND pointer receivers

If you check `reflect.TypeOf(myStruct{}).Implements(StarterInterface)` when `OnStart` has a pointer receiver, it returns `false` even though `*myStruct` implements `Starter`.

**Current GAZ code at risk:**
```go
// di/service.go:82 - correct but easy to break
if starter, ok := instance.(Starter); ok {
    if err := starter.OnStart(ctx); err != nil {
```
This works because `instance` is already the concrete value. The pitfall occurs when doing reflection-based type checks during registration.

**Consequences:**
- Services silently don't get lifecycle hooks invoked
- Users file bugs: "my OnStart never runs"
- Edge cases: works with pointer registration, fails with value registration

**Prevention:**
```go
// Check BOTH value and pointer type for interface implementation
func implementsInterface(t reflect.Type, iface reflect.Type) bool {
    if t.Implements(iface) {
        return true
    }
    // Also check pointer-to-type
    if t.Kind() != reflect.Ptr {
        return reflect.PtrTo(t).Implements(iface)
    }
    return false
}
```

**Detection (warning signs):**
- Tests pass with `*MyService` but fail with `MyService`
- Lifecycle hooks work for some services but not others
- Interface detection returns different results than type assertion

**Phase to address:** Phase 1 - Interface Auto-detection foundation must get this right.

---

### Pitfall 2: Named Dependency Collision with Args Injection

**What goes wrong:** The new `Args("name", value)` injection pattern collides with existing `di.Named("name")` registrations.

**Why it happens:** GAZ already uses string names for service lookup:
```go
// Existing: di/options.go:19
func Named(name string) ResolveOption {
    return func(o *resolveOptions) {
        o.name = name
    }
}
```

If Args injection uses the same namespace, a user could do:
```go
di.For[*sql.DB](c).Named("primary").Provider(NewPrimaryDB)
// ...later...
app.Args("primary", someValue)  // COLLISION!
```

**Consequences:**
- Silent override of named service with arg value
- Type mismatch errors at resolution time
- Confusing error: "expected *sql.DB, got string"

**Prevention:**
1. **Separate namespace:** Prefix args with `arg:` or use separate registry:
   ```go
   // Args stored separately
   type Container struct {
       services map[string]any      // existing
       args     map[string]any      // NEW - separate namespace
   }
   ```

2. **Conflict detection at registration time:**
   ```go
   func (b *ArgsBuilder) Set(name string, value any) error {
       if c.HasService(name) {
           return fmt.Errorf("arg name %q conflicts with registered service", name)
       }
       // ...
   }
   ```

**Detection (warning signs):**
- Existing services mysteriously replaced after adding Args
- Tests using `Named()` start failing after Args feature added
- Resolution errors with unexpected types

**Phase to address:** Phase 3 - Args Injection must define namespace separation early.

---

### Pitfall 3: Pre/Post Hook Ordering with Existing Lifecycle Interfaces

**What goes wrong:** New Pre/Post hooks execute in wrong order relative to existing `Starter`/`Stopper` interface methods.

**Why it happens:** GAZ already has a defined order in `di/service.go`:
```go
// di/service.go:77-88 - Start lifecycle
func (s *baseService) runStartLifecycle(ctx context.Context, instance any) error {
    if err := s.runStartHooks(ctx, instance); err != nil {  // Hooks FIRST
        return err
    }
    if starter, ok := instance.(Starter); ok {
        if err := starter.OnStart(ctx); err != nil {        // Interface SECOND
            ...
        }
    }
    return nil
}

// di/service.go:90-98 - Stop lifecycle
func (s *baseService) runStopLifecycle(ctx context.Context, instance any) error {
    if stopper, ok := instance.(Stopper); ok {
        if err := stopper.OnStop(ctx); err != nil {         // Interface FIRST
            ...
        }
    }
    return s.runStopHooks(ctx, instance)                    // Hooks SECOND
}
```

Adding "Pre" and "Post" hooks must respect this existing order. If PreStart runs AFTER OnStart, it's not "pre" anymore.

**Consequences:**
- PreStart/PostStart semantics violated
- Existing OnStart hooks see different state than expected
- Breaking behavior for services already using Starter interface

**Prevention:**
Define explicit ordering contract in v2.1:
```
Startup Order:
1. PreStart hooks (NEW)
2. OnStart hooks (existing registration hooks)
3. Starter.OnStart() (existing interface)
4. PostStart hooks (NEW)

Shutdown Order (reverse):
1. PreStop hooks (NEW)
2. Stopper.OnStop() (existing interface)
3. OnStop hooks (existing registration hooks)
4. PostStop hooks (NEW)
```

**Detection (warning signs):**
- Existing tests using OnStart + registration hooks change behavior
- PreStart hook sees instance in different state than expected
- Service start timing issues after adding new hooks

**Phase to address:** Phase 4 - Pre/Post Hooks must document ordering contract explicitly.

---

### Pitfall 4: Unified Provider API Confusion with Existing For[T]()

**What goes wrong:** Adding new provider variants (like `Provide[T]()`, `Register[T]()`) creates API confusion with existing `For[T]()`.

**Why it happens:** GAZ has an established pattern:
```go
// Current API
di.For[*MyService](c).Provider(NewMyService)
di.For[*Config](c).Instance(cfg)
di.For[*sql.DB](c).Named("primary").Provider(NewPrimaryDB)
```

Adding alternatives like:
```go
// Potential NEW APIs that cause confusion
di.Provide[*MyService](c, NewMyService)      // Different signature!
di.Register[*MyService](c).Provider(...)     // Why not For?
di.Service[*MyService](c).Build(...)         // Yet another name
```

**Consequences:**
- Users don't know which API to use
- Inconsistent patterns across codebase
- Documentation sprawl explaining "For vs Provide vs Register"
- IDE autocomplete shows too many options

**Prevention:**
1. **Extend, don't duplicate:** Add functionality to existing `For[T]()` builder
   ```go
   // GOOD: Extend existing pattern
   di.For[*MyService](c).
       As[ServiceInterface]().        // NEW capability
       Provider(NewMyService)
   ```

2. **If adding new entry points, make purpose distinct:**
   ```go
   // ACCEPTABLE: Different purpose
   di.For[*MyService](c)           // Registration
   di.MustResolve[*MyService](c)   // Resolution (already exists)
   di.Test[*MyService](c)          // NEW: Test-specific builder
   ```

3. **Never add synonyms:**
   - `Register` = `Provide` = `For` is cognitive overhead for zero benefit

**Detection (warning signs):**
- API review shows multiple ways to do same thing
- Examples in docs use different registration patterns
- Users ask "what's the difference between X and Y?"

**Phase to address:** Phase 7 - Unified Provider must be additive to For[T](), not parallel.

---

## Moderate Pitfalls

Mistakes that cause delays or technical debt.

---

### Pitfall 5: Build Info ldflags Only Works with Strings

**What goes wrong:** Attempting to inject non-string build values (version as int, build time as time.Time) via ldflags.

**Why it happens:** Go's linker only supports `-X` for string package variables:
```bash
# Works
go build -ldflags "-X main.Version=1.0.0"

# DOES NOT WORK
go build -ldflags "-X main.BuildNumber=42"  # Expects string, not int
```

**Consequences:**
- Build fails silently or with confusing linker errors
- Version struct has mix of strings and parsed values
- Init() parsing adds startup overhead

**Prevention:**
```go
// All ldflags targets MUST be strings
var (
    Version   = "dev"      // string
    Commit    = "unknown"  // string  
    BuildTime = ""         // string - parse to time.Time later
)

// Parse in init or accessor, not in variable
func GetBuildTime() time.Time {
    if t, err := time.Parse(time.RFC3339, BuildTime); err == nil {
        return t
    }
    return time.Time{}
}
```

**Detection (warning signs):**
- `go build -ldflags` works but value is always default
- CI builds have wrong version info
- Type conversion panics at runtime

**Phase to address:** Phase 2 - Build Info design must use all-string storage.

---

### Pitfall 6: runtime.debug.ReadBuildInfo Conflicts with ldflags

**What goes wrong:** Using both `debug.ReadBuildInfo()` and ldflags without clear precedence causes dual sources of truth.

**Why it happens:** 
- `debug.ReadBuildInfo().Main.Version` comes from Go module/VCS info
- ldflags `-X main.Version` sets a separate variable
- They are NOT connected

```go
// These are independent!
info, _ := debug.ReadBuildInfo()
fmt.Println(info.Main.Version)  // "(devel)" or VCS tag
fmt.Println(Version)            // ldflags value
```

**Consequences:**
- `--version` shows ldflags value
- Health/debug endpoints show ReadBuildInfo value
- Two different version strings in production

**Prevention:**
Create a unified BuildInfo struct that prefers one source with fallback:
```go
type BuildInfo struct {
    Version   string
    Commit    string
    BuildTime time.Time
    GoVersion string
}

func GetBuildInfo() BuildInfo {
    bi := BuildInfo{
        Version: Version,  // ldflags first
    }
    
    // Fallback to ReadBuildInfo for values not set by ldflags
    if info, ok := debug.ReadBuildInfo(); ok {
        bi.GoVersion = info.GoVersion
        if bi.Version == "dev" || bi.Version == "" {
            // ldflags not set, try VCS
            for _, s := range info.Settings {
                if s.Key == "vcs.revision" {
                    bi.Commit = s.Value[:8]
                }
            }
        }
    }
    return bi
}
```

**Detection (warning signs):**
- Different version numbers in logs vs API response
- CI-built binary shows "dev" even with ldflags
- VCS info missing from debug endpoints

**Phase to address:** Phase 2 - Build Info must define single source of truth.

---

### Pitfall 7: Frame Utils Stack Depth Off-by-One Errors

**What goes wrong:** `runtime.Caller(skip)` returns wrong caller due to incorrect skip count.

**Why it happens:** Skip value depends on call depth:
- `skip=0`: Where runtime.Caller is called
- `skip=1`: Caller of that function
- `skip=2`: Caller of the caller

When frame utils are used through wrapper functions, the skip must increase:
```go
// If GetCallerInfo() wraps runtime.Caller...
func GetCallerInfo() string {
    _, file, line, _ := runtime.Caller(1)  // Caller of GetCallerInfo
    return fmt.Sprintf("%s:%d", file, line)
}

// And then someone wraps GetCallerInfo...
func LogWithCaller(msg string) {
    info := GetCallerInfo()  // WRONG! Returns LogWithCaller's location
    log.Printf("%s: %s", info, msg)
}
```

**Consequences:**
- Log messages show wrong file:line
- Debug output points to framework code, not user code
- Registration error messages show internal DI code

**Prevention:**
Pass skip as parameter (like testing.T.Helper pattern):
```go
// Allow caller to specify depth
func GetCallerInfo(skip int) string {
    _, file, line, _ := runtime.Caller(skip + 1)  // +1 for this function
    return fmt.Sprintf("%s:%d", file, line)
}

// OR: Use runtime.Callers for multiple frames
func GetCallStack(skip, depth int) []string {
    pcs := make([]uintptr, depth)
    n := runtime.Callers(skip+2, pcs)  // +2: Callers itself + this function
    frames := runtime.CallersFrames(pcs[:n])
    // ...
}
```

**Detection (warning signs):**
- Error messages show internal framework file paths
- Skip values need "magic number" adjustments
- Adding wrapper functions breaks caller detection

**Phase to address:** Phase 5 - Frame Utils must use configurable skip depth.

---

### Pitfall 8: Service Builder Hidden State (Fluent API Anti-pattern)

**What goes wrong:** Builder pattern with hidden mutable state causes unexpected side effects.

**Why it happens:** GAZ's current `RegistrationBuilder` is already at risk:
```go
// di/registration.go:21-30
type RegistrationBuilder[T any] struct {
    container    *Container
    name         string
    typeName     string
    scope        serviceScope
    lazy         bool         // MUTABLE
    allowReplace bool         // MUTABLE
    startHooks   []func(...)  // MUTABLE
    stopHooks    []func(...)  // MUTABLE
}
```

If someone reuses a builder:
```go
builder := di.For[*MyService](c).Transient()
builder.Provider(NewServiceA)  // Transient
builder.Provider(NewServiceB)  // ALSO transient? Or error?
```

**Consequences:**
- Second call overwrites first silently or errors
- State leaks between registrations
- Concurrent use causes race conditions

**Prevention:**
1. **Consume builder after terminal methods:** After `Provider()` or `Instance()`, builder should be invalidated:
   ```go
   func (b *RegistrationBuilder[T]) Provider(fn ...) error {
       if b.consumed {
           return errors.New("builder already used")
       }
       b.consumed = true
       // ...
   }
   ```

2. **Return new builder from each method:**
   ```go
   func (b *RegistrationBuilder[T]) Transient() *RegistrationBuilder[T] {
       return &RegistrationBuilder[T]{
           // Copy all fields
           scope: scopeTransient,  // Set new value
       }
   }
   ```

3. **Document single-use nature clearly**

**Detection (warning signs):**
- Tests fail intermittently (race on shared builder)
- Storing builder in variable then reusing it
- Multiple Provider() calls on same builder

**Phase to address:** Phase 6 - Service Builder should detect/prevent reuse.

---

### Pitfall 9: Test Builder Cleanup Ordering with t.Parallel()

**What goes wrong:** Test container cleanup runs before parallel subtests finish, causing "service not found" or nil pointer panics.

**Why it happens:** Go's `t.Cleanup` behavior with parallel tests:
```go
func TestParent(t *testing.T) {
    c := di.NewTestContainer()
    t.Cleanup(func() {
        c.Stop()  // Runs AFTER all subtests complete
    })
    
    t.Run("Sub1", func(t *testing.T) {
        t.Parallel()  // Detaches from parent
        svc := di.MustResolve[*MyService](c)  // May see stopped container!
    })
}
// Without t.Parallel(), cleanup waits for subtests
// WITH t.Parallel(), parent function returns immediately but cleanup DOES wait
```

The actual issue is when the TEST FUNCTION calls `t.Parallel()`:
```go
func TestMyService(t *testing.T) {
    t.Parallel()  // THIS test runs in parallel with others
    
    // If a shared container exists at package level...
    svc := di.MustResolve[*MyService](sharedContainer)  // RACE!
}
```

**Consequences:**
- Flaky tests that pass alone but fail in parallel
- Race detector finds container access races
- "service not found" errors for registered services

**Prevention:**
1. **Each parallel test gets its own container:**
   ```go
   func TestMyService(t *testing.T) {
       t.Parallel()
       c := di.NewTestContainer()  // Own container
       t.Cleanup(func() { c.Stop() })
       // ...
   }
   ```

2. **TestBuilder should create isolated containers:**
   ```go
   func (tb *TestBuilder) Build(t *testing.T) *Container {
       c := tb.container.Clone()  // Each test gets a clone
       t.Cleanup(func() { c.Stop() })
       return c
   }
   ```

3. **Warn in documentation about t.Parallel() + shared containers**

**Detection (warning signs):**
- Tests pass with `go test -p 1` but fail with default parallelism
- Race detector errors in container access
- Random "not found" errors only in CI

**Phase to address:** Phase 8 - Test Builder must document/enforce container isolation.

---

### Pitfall 10: Interface Auto-detection reflect.Implements() Panic

**What goes wrong:** `reflect.Type.Implements(u)` panics if `u` is not an interface type.

**Why it happens:**
```go
// This panics!
reflect.TypeOf(MyStruct{}).Implements(reflect.TypeOf(OtherStruct{}))
// panic: reflect: non-interface type passed to Type.Implements
```

The correct pattern:
```go
// Get interface type via nil pointer technique
var starterType = reflect.TypeOf((*Starter)(nil)).Elem()

// Now safe to use
if t.Implements(starterType) { ... }
```

**Consequences:**
- Panic at registration time if interface type obtained incorrectly
- Confusing panic message about "non-interface type"
- Works in tests with interface, fails in production with concrete type

**Prevention:**
Define interface types once at package level:
```go
var (
    starterType = reflect.TypeOf((*Starter)(nil)).Elem()
    stopperType = reflect.TypeOf((*Stopper)(nil)).Elem()
    // Add new lifecycle interfaces here
)

func implementsStarter(t reflect.Type) bool {
    return t.Implements(starterType) || 
           reflect.PtrTo(t).Implements(starterType)
}
```

**Detection (warning signs):**
- Panic with "non-interface type" message
- Works with some types but panics with others
- reflect.TypeOf() on wrong value

**Phase to address:** Phase 1 - Interface Auto-detection must use correct Elem() pattern.

---

## Minor Pitfalls

Mistakes that cause annoyance but are fixable.

---

### Pitfall 11: ldflags Package Path Mismatch

**What goes wrong:** ldflags `-X` silently fails because package path is wrong.

**Why it happens:**
```bash
# If go.mod says: module github.com/petabyte/gaz
# And Version is in: internal/build/version.go

# WRONG (uses relative path)
go build -ldflags "-X internal/build.Version=1.0.0"

# CORRECT (uses full module path)
go build -ldflags "-X github.com/petabyte/gaz/internal/build.Version=1.0.0"
```

**Prevention:**
- Use `go list ./...` to verify exact package paths
- Define version in `main` package for simpler path
- Document the exact ldflags in Makefile/CI

**Phase to address:** Phase 2 - Build Info documentation.

---

### Pitfall 12: As[Interface]() Before Type is Registered

**What goes wrong:** Using interface registration helpers before the concrete type is known.

**Why it happens:**
```go
// If As[Interface]() is called during registration...
di.For[*MyService](c).
    As[Logger]().       // Register also as Logger interface
    Provider(NewMyService)

// The check "does *MyService implement Logger?" 
// happens at registration, before instance exists
// This is fine - just check the type statically
```

The pitfall is if someone tries:
```go
// Type assertion on reflect.Type, not on instance
if !reflect.TypeOf(instance).AssignableTo(loggerType) {
    // This fails because instance might be nil during check
}
```

**Prevention:**
Check types, not instances, during registration:
```go
func (b *RegistrationBuilder[T]) As(interfaceTypes ...reflect.Type) {
    var zero T
    concreteType := reflect.TypeOf(zero)
    for _, iface := range interfaceTypes {
        if !concreteType.Implements(iface) {
            panic(fmt.Sprintf("%T does not implement %s", zero, iface))
        }
    }
}
```

**Phase to address:** Phase 7 - Unified Provider As[] implementation.

---

## Phase-Specific Warnings Summary

| Phase | Topic | Likely Pitfall | Mitigation |
|-------|-------|----------------|------------|
| 1 | Interface Auto-detection | Pointer vs value receiver detection | Check both T and *T for interface |
| 1 | Interface Auto-detection | Implements() panic on non-interface | Use (*Interface)(nil)).Elem() pattern |
| 2 | Build Info | String-only ldflags | All version vars must be strings |
| 2 | Build Info | Dual source of truth | Single BuildInfo struct with priority |
| 3 | Args Injection | Namespace collision | Separate args registry from services |
| 4 | Pre/Post Hooks | Ordering with existing hooks | Document explicit order contract |
| 5 | Frame Utils | Off-by-one skip depth | Configurable skip parameter |
| 6 | Service Builder | Hidden mutable state | Consume-once pattern |
| 7 | Unified Provider | API confusion | Extend For[T](), don't duplicate |
| 8 | Test Builder | Parallel test cleanup | Isolated container per test |

---

## Integration with Existing PITFALLS.md

This document focuses on v2.1 API enhancement features. For concurrency primitives (workers, cron, eventbus) pitfalls, see the existing `PITFALLS.md`.

**Cross-cutting concerns:**

1. **New hooks (Pre/Post) + Workers**: If PreStart/PostStart hooks are added, ensure worker services don't block in these hooks (same as existing WRK-2 pitfall).

2. **Test Builder + Worker tests**: TestBuilder isolation must work with worker goroutines - ensure worker contexts are properly cancelled on test cleanup.

3. **Interface Auto-detection + Lifecycle**: Auto-detection of Starter/Stopper must work with the existing lifecycle engine order (no changes to startup/shutdown sequence).

---

## Sources

**HIGH Confidence (Context7/Official):**
- [uber-go/fx Lifecycle Hooks](https://context7.com/uber-go/fx) - Hook ordering patterns
- [samber/do v2](https://pkg.go.dev/github.com/samber/do/v2) - Named dependencies, shutdown patterns
- [Go reflect package](https://pkg.go.dev/reflect) - Type.Implements() behavior

**MEDIUM Confidence (Verified WebSearch):**
- Go reflection laws: Value vs pointer method sets
- ldflags -X best practices: String-only, full package paths
- runtime.Caller skip parameter semantics
- t.Cleanup with t.Parallel() ordering

**GAZ Codebase Analysis:**
- `di/service.go:77-98` - Current hook ordering
- `di/inject.go:46-105` - Struct injection with reflection  
- `di/registration.go:21-30` - RegistrationBuilder state
- `di/resolution.go:25-48` - Named resolution patterns
- `lifecycle.go:28-38` - Starter/Stopper interfaces
