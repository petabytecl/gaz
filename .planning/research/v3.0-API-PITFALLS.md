# API Refactoring Pitfalls: gaz v3.0 API Harmonization

**Researched:** 2026-01-29
**Milestone:** v3.0 API Harmonization
**Overall Confidence:** HIGH (verified against Go ecosystem patterns, uber-go/fx, existing gaz codebase)

---

## Executive Summary

The v3.0 API Harmonization milestone represents a clean-break refactoring opportunity. Since backward compatibility is not required and migration tooling is out of scope, the primary risks shift from "how to migrate users" to "how to design APIs that are consistent, extensible, and maintainable."

The five highest-risk pitfalls for this milestone are:

1. **Inconsistent Naming After Merge** — Merging `service` package into core without aligning naming conventions
2. **Config System Inflexibility** — Designing `Unmarshal()` in a way that's hard to extend or test
3. **Error Context Loss** — Consolidating errors without preserving diagnostic information
4. **Testing Utilities Drift** — gaztest not matching new patterns, making tests harder to write
5. **Module API Fragmentation** — Different subsystems using incompatible factory patterns

This research addresses each area with specific warning signs, prevention strategies, and phase recommendations.

---

## Critical Pitfalls

### API-1: Inconsistent Naming After Service Package Merge

**Severity:** CRITICAL  
**Impact Area:** All users, discoverability, learning curve

**What goes wrong:**
When merging `service` package into core `gaz`, naming collisions or inconsistencies emerge. Functions that made sense in `service.New()` context become confusing when moved to `gaz.NewService()` or similar. The resulting API has competing patterns:
- `gaz.New()` for App
- `gaz.NewService()` for Service Builder
- `gaz.NewModule()` for Module Builder
- `For[T]()` for registration (different pattern entirely)

**Warning signs:**
- Godoc shows multiple "New*" functions with unclear relationships
- Users ask "what's the difference between New() and NewService()?"
- Examples use different registration patterns inconsistently
- Package-level docs don't explain the hierarchy

**Root cause:**
Each subsystem was designed independently, resulting in:
- `service.New()` returns a builder (fluent)
- `gaz.New()` returns an App (direct)
- `NewModule()` returns a builder that requires `.Build()` (deferred)

**Prevention:**

```go
// BEFORE (inconsistent):
app := gaz.New()                           // Returns *App directly
svc := service.New("name")                 // Returns *Builder (needs .Build())
mod := gaz.NewModule("name")               // Returns *ModuleBuilder (needs .Build())

// AFTER (consistent):
// Option A: All constructors return configured objects directly
app := gaz.New()                           // Returns *App
svc := gaz.NewService("name", opts...)     // Returns *Service directly
mod := gaz.NewModule("name", opts...)      // Returns Module directly

// Option B: All builders follow same pattern
app := gaz.NewApp().Build()                // Consistent builder pattern
svc := gaz.NewService("name").Build()      // Same pattern
mod := gaz.NewModule("name").Build()       // Same pattern
```

**Recommendation:** Option A is simpler but less flexible. Option B is more consistent with fluent APIs. Choose ONE pattern and apply universally.

**Phase:** Module System Consolidation — establish naming convention before merging

**Detection checklist:**
- [ ] All exported `New*` functions documented in package doc
- [ ] Clear hierarchy diagram in README
- [ ] Each constructor returns same "kind" (direct object or builder)
- [ ] Examples all use the same pattern

---

### API-2: Removing Fluent Lifecycle Hooks Without Clear Alternative

**Severity:** CRITICAL  
**Impact Area:** Existing lifecycle patterns, learning curve

**What goes wrong:**
The v3.0 goal is to remove fluent `OnStart`/`OnStop` from `For[T]()` in favor of interface-only lifecycle. However, this removes flexibility for cases where:
- External types can't implement interfaces (third-party structs)
- Ad-hoc cleanup is needed without modifying the type
- Testing requires lifecycle injection

Users attempt workarounds that are worse than the original API.

**Warning signs:**
- Stack Overflow: "How to add shutdown hook to third-party struct in gaz?"
- Wrapper types proliferate just to implement Starter/Stopper
- Tests become verbose to set up lifecycle
- Examples show boilerplate "adapter" patterns

**Root cause:**
Interface-only lifecycle works well when you control the types. It fails for:
- `*sql.DB` (stdlib, can't add methods)
- `*http.Server` (can add, but feels wrong to modify for DI)
- `*redis.Client` (third-party)

**Prevention:**

Provide an escape hatch that's clearly documented as "for external types":

```go
// Option A: Wrapper registration for external types
gaz.For[*sql.DB](c).
    Provider(NewDB).
    WithLifecycle(dbStarter, dbStopper) // Explicit "I know what I'm doing"

// Option B: Lifecycle registration separate from type
gaz.OnStop[*sql.DB](c, func(ctx context.Context, db *sql.DB) error {
    return db.Close()
})

// Option C: Adapter helper (recommended for v3.0)
gaz.For[*sql.DB](c).
    Provider(NewDB).
    Adapt(func(db *sql.DB) Stopper {
        return StopFunc(func(ctx context.Context) error {
            return db.Close()
        })
    })
```

**Recommendation:** Option C is cleanest — keeps interface requirement but provides adapter. Document clearly: "Use Adapt() only for external types. For your own types, implement Starter/Stopper."

**Phase:** Lifecycle Interface Alignment — design escape hatch before removing fluent hooks

**Detection checklist:**
- [ ] Third-party type lifecycle works without wrapper type
- [ ] Examples show pattern for *sql.DB, *http.Server
- [ ] Error message if no lifecycle and type needs cleanup
- [ ] gaztest can inject mock lifecycle

---

### API-3: Config System That's Hard to Extend

**Severity:** HIGH  
**Impact Area:** Provider configuration, module configuration

**What goes wrong:**
`ProviderValues.Unmarshal()` is designed narrowly for current use cases. Later requirements (nested config, slice values, custom unmarshaling) require breaking changes or awkward workarounds.

**Warning signs:**
- Feature requests: "Support nested structs in ProviderValues"
- Workarounds: Users manually call viper.UnmarshalKey
- Inconsistency: Some config uses Unmarshal, some uses Get* methods
- Testing: Hard to mock ProviderValues for unit tests

**Root cause:**
ProviderValues wraps config.Backend but only exposes narrow API. The underlying backend (Viper) is capable of more, but gaz doesn't surface it.

**Prevention:**

```go
// BEFORE (narrow):
type ProviderValues struct {
    backend config.Backend
}

func (pv *ProviderValues) Get(key string) any { ... }
func (pv *ProviderValues) GetString(key string) string { ... }

// AFTER (extensible):
// Option A: Expose sub-config accessor
func (pv *ProviderValues) Sub(namespace string) *ProviderValues { ... }
func (pv *ProviderValues) Unmarshal(target any) error { ... }
func (pv *ProviderValues) UnmarshalKey(key string, target any) error { ... }

// Option B: Compose with interface for testability
type ConfigAccessor interface {
    Get(key string) any
    GetString(key string) string
    Unmarshal(target any) error
    Sub(namespace string) ConfigAccessor
}

// ProviderValues implements ConfigAccessor
```

**Recommendation:** Option B with interface enables:
- Unit testing with mock ConfigAccessor
- Nested namespace navigation
- Future backends without API changes

**Phase:** Configuration System Harmonization — design interface before implementing

**Detection checklist:**
- [ ] ProviderValues is testable (interface or constructor injection)
- [ ] Nested config structs work with single Unmarshal call
- [ ] Sub-namespaces navigable without string concatenation
- [ ] Config example shows complex nested config

---

### API-4: Error Context Loss During Consolidation

**Severity:** HIGH  
**Impact Area:** Debugging, error handling, logging

**What goes wrong:**
Consolidating sentinel errors from `di`, `config`, and `gaz` into `gaz/errors.go` loses package context. Errors that were distinguishable become ambiguous.

**Warning signs:**
- Log: "gaz: not found" — was it config key or DI service?
- `errors.Is(err, gaz.ErrNotFound)` matches too broadly
- Debug sessions require printf to understand error source
- Stack traces don't indicate which subsystem failed

**Root cause:**
Simple sentinel errors like `ErrNotFound` are generic. When multiple subsystems have "not found" semantics, consolidation conflates them.

**Prevention:**

```go
// BEFORE (conflated):
var (
    ErrNotFound = errors.New("gaz: not found")  // DI? Config? Module?
)

// AFTER (scoped but unified):
// Option A: Namespaced sentinels
var (
    ErrDINotFound     = errors.New("gaz: di: service not found")
    ErrConfigNotFound = errors.New("gaz: config: key not found")
    ErrModuleNotFound = errors.New("gaz: module: module not found")
)

// Option B: Typed errors with common interface
type NotFoundError struct {
    Subsystem string  // "di", "config", "module"
    Key       string  // service name, config key, module name
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("gaz: %s: %s not found", e.Subsystem, e.Key)
}

func (e *NotFoundError) Is(target error) bool {
    _, ok := target.(*NotFoundError)
    return ok
}

// Usage:
errors.Is(err, &NotFoundError{}) // Match any not found
errors.As(err, &nf) && nf.Subsystem == "di" // Match specific
```

**Recommendation:** Option B is more flexible but Option A is simpler. For v3.0, Option A with clear naming. Consider Option B if error handling becomes complex.

**Always preserve context when wrapping:**
```go
// BAD: Loses context
if err := container.Resolve(...); err != nil {
    return err  // Caller sees raw di.ErrNotFound
}

// GOOD: Adds context
if err := container.Resolve(...); err != nil {
    return fmt.Errorf("resolving %s for worker: %w", typeName, err)
}
```

**Phase:** Error Standardization — define error categories before consolidating

**Detection checklist:**
- [ ] Each sentinel error identifies its subsystem
- [ ] Error messages include actionable information (key name, type name)
- [ ] errors.Is/As work as documented in godoc
- [ ] Error handling guide in docs shows disambiguation

---

### API-5: Testing Utilities That Don't Match New Patterns

**Severity:** HIGH  
**Impact Area:** Test writability, developer experience, adoption

**What goes wrong:**
gaztest was designed for v2.x patterns. After v3.0 changes:
- `Replace()` doesn't work with new registration API
- Lifecycle testing harder without fluent hooks
- Config testing doesn't match new ProviderValues
- Examples in godoc don't work

Users either:
1. Write verbose test setup duplicating production code
2. Abandon gaztest and use raw mocks
3. File bugs about "gaztest doesn't work with v3"

**Warning signs:**
- gaztest godoc examples fail to compile
- Integration tests more complex than unit tests
- Mock injection requires understanding internals
- Tests don't use gaz features, just manual setup

**Root cause:**
Test utilities are afterthoughts, updated last. When core APIs change, test helpers lag.

**Prevention:**

**Update gaztest alongside each API change:**

```go
// v3.0 gaztest must support:

// 1. New registration patterns
builder := gaztest.New(t).
    WithModule(MyModule).            // Module-based composition
    WithProvider[*DB](mockDB).       // Direct instance injection
    ReplaceProvider[*DB](func() *DB { // Provider replacement
        return mockDB
    })

// 2. Lifecycle testing without fluent hooks
builder := gaztest.New(t).
    WithLifecycleTest().             // Enable lifecycle assertions
    AssertStarted[*Server]().        // Verify Start called
    AssertStopped[*Server]()         // Verify Stop called

// 3. Config testing with new ProviderValues
builder := gaztest.New(t).
    WithConfig(map[string]any{       // Provide test config
        "database.host": "localhost",
        "database.port": 5432,
    }).
    Build()

// 4. Subsystem isolation
builder := gaztest.New(t).
    WithDI().                        // Only DI, no config/lifecycle
    WithConfig().                    // Only config
    Build()
```

**Phase:** Testing Infrastructure — update gaztest WITH each prior phase, not after

**Detection checklist:**
- [ ] gaztest examples compile against current API
- [ ] Each API change includes gaztest update in same PR
- [ ] Test coverage doesn't drop after refactoring
- [ ] Example apps use gaztest in their tests

---

## High-Priority Pitfalls

### API-6: Module Factory Pattern Fragmentation

**Severity:** HIGH  
**Impact Area:** Consistency, discoverability

**What goes wrong:**
Different subsystems use different factory/builder patterns:
- `NewModule("name").Provide().Build()` — builder returns Module
- `worker.New("name", opts...)` — direct with options
- `cron.NewScheduler(ctx, logger)` — constructor with dependencies
- `eventbus.New(logger)` — constructor with dependencies

Users can't predict patterns, must read docs for each subsystem.

**Warning signs:**
- "How do I create a X?" questions for each subsystem
- Godoc requires subsystem-by-subsystem reading
- Inconsistent error handling (some constructors panic, some return error)

**Prevention:**

Establish standard patterns and apply to all subsystems:

```go
// Pattern A: Functional Options (recommended for most)
mod := gaz.NewModule("name",
    gaz.WithModuleProvider(provider),
    gaz.WithModuleFlags(flagsFn),
)

wkr := worker.New("name",
    worker.WithInterval(time.Second),
    worker.WithCritical(true),
)

// Pattern B: Builder (when many optional configs)
// Use only when >5 configuration options

// Pattern C: Simple Constructor (when minimal config)
bus := eventbus.New() // No options needed, sensible defaults
```

**Decision tree for which pattern:**
1. **0-1 required args, 0-2 options:** Simple constructor
2. **1-2 required args, 3-5 options:** Functional options
3. **Complex configuration or fluent chaining:** Builder pattern

**Phase:** Module System Consolidation — establish pattern before implementing

---

### API-7: Breaking Type Compatibility Silently

**Severity:** HIGH  
**Impact Area:** Compile errors, frustration

**What goes wrong:**
Renaming types or changing signatures causes confusing errors. Go's type system catches mismatches, but error messages aren't helpful:
- `cannot use x (type *OldType) as type *NewType`
- Interface satisfaction failures with unclear "missing method" errors
- Generic constraint violations that don't explain what changed

**Warning signs:**
- GitHub issues: "v3 doesn't compile, unclear what changed"
- Users grep through changelog trying to map old → new
- Test updates require trial-and-error

**Prevention:**

**1. Use type aliases for renames (in transitional releases if any):**
```go
// In gaz package after merging service package:
// Type alias preserves compatibility temporarily
type ServiceBuilder = service.Builder  // Deprecated: use gaz.Service
```

**2. Clear migration comments in breaking changes:**
```go
// Starter is the interface for services with start hooks.
// 
// Breaking change from v2.x: Previously, OnStart() was a fluent method
// on For[T](). In v3.0, implement this interface instead.
// 
// Migration: Replace For[T]().OnStart(fn) with implementing Starter.
type Starter interface {
    OnStart(context.Context) error
}
```

**3. Compile-time assertions for interface changes:**
```go
// Verify Worker interface is compatible with Starter/Stopper
var _ Starter = (*baseWorker)(nil)
var _ Stopper = (*baseWorker)(nil)
```

**Phase:** All phases — add migration comments as you change

---

### API-8: Losing 92.9% Test Coverage

**Severity:** HIGH  
**Impact Area:** Quality, regression prevention

**What goes wrong:**
Refactoring creates new code paths but test updates lag. Coverage drops from 92.9% to below threshold. Regressions slip in.

**Warning signs:**
- Coverage report shows new files at <50%
- Renamed packages have 0% coverage
- Edge cases that were tested are now untested
- CI fails on coverage threshold

**Prevention:**

**1. Coverage as part of each PR:**
```bash
# Before merging any refactoring PR:
make cover
# Verify coverage didn't drop more than 1%
```

**2. Test alongside code, not after:**
```go
// When moving service.Builder to gaz.Service:
// - Move service/builder_test.go to service_test.go
// - Update imports in same PR
// - Verify tests pass before committing
```

**3. Coverage regression check in CI:**
```yaml
# In CI pipeline
- name: Coverage Check
  run: |
    CURRENT=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | tr -d '%')
    if (( $(echo "$CURRENT < 90" | bc -l) )); then
      echo "Coverage dropped below 90%: $CURRENT%"
      exit 1
    fi
```

**Phase:** All phases — maintain coverage gate

---

### API-9: Documentation Drift

**Severity:** MEDIUM  
**Impact Area:** Adoption, user experience

**What goes wrong:**
Code changes but documentation (README, godoc, examples) doesn't. Users follow outdated examples that don't compile. Godoc shows deprecated patterns.

**Warning signs:**
- README examples use old API
- godoc Example* functions fail to compile
- Tutorial links to v2.x patterns
- FAQ answers don't match current behavior

**Prevention:**

**1. Examples are tests (compile-verified):**
```go
// In example_test.go — these compile as part of test suite
func Example_serviceRegistration() {
    app := gaz.New()
    // Current pattern...
    // Output:
}
```

**2. Documentation update checklist in PR template:**
```markdown
## Documentation Checklist
- [ ] README examples updated if API changed
- [ ] godoc comments reflect new behavior
- [ ] Example apps compile and run
- [ ] CHANGELOG entry added
```

**3. Doc review as explicit phase:**
Dedicate final sub-phase of v3.0 to documentation sweep.

**Phase:** Documentation & Polish — explicit doc verification

---

### API-10: Implicit Dependencies Between Packages

**Severity:** MEDIUM  
**Impact Area:** Import cycles, package boundaries

**What goes wrong:**
After merging service package into gaz, circular dependencies emerge:
- `gaz` imports `health` for auto-registration
- `health` imports `gaz` for container access
- Import cycle: compile failure

Or: Implicit assumptions about initialization order break.

**Warning signs:**
- `import cycle not allowed`
- "nil pointer dereference" during init
- "which package do I import?" confusion
- Internal types exposed just to break cycles

**Prevention:**

**1. Define clear package boundaries before merging:**
```
gaz/
  ├── di/       → standalone, no gaz imports
  ├── config/   → standalone, no gaz imports
  ├── health/   → may import di for registration, NOT gaz
  ├── worker/   → may import di, NOT gaz
  ├── cron/     → may import di and worker, NOT gaz
  ├── eventbus/ → standalone
  ├── gaztest/  → imports gaz (test utility, allowed)
  └── (core)    → imports subpackages, not vice versa
```

**2. Use interfaces at boundaries:**
```go
// In health package, don't import gaz.Container
// Instead, accept an interface:
type ServiceResolver interface {
    Resolve(name string) (any, error)
}

func NewManager(resolver ServiceResolver) *Manager { ... }
```

**3. Test for import cycles in CI:**
```bash
# Detect cycles before they merge
go build ./... 2>&1 | grep -q "import cycle" && exit 1
```

**Phase:** Module System Consolidation — design package structure first

---

## Prevention Checklist

### Before Starting Any Refactoring Phase

- [ ] Document current behavior being changed
- [ ] Identify all callers of affected APIs (grep codebase + examples)
- [ ] Write migration notes in ticket/PR description
- [ ] Verify tests exist for current behavior

### During Refactoring

- [ ] Update tests alongside code, not after
- [ ] Update godoc comments when changing signatures
- [ ] Add compile-time assertions for interface changes
- [ ] Run `make lint` and `make test` frequently

### Before Completing Phase

- [ ] Coverage at or above 90%
- [ ] All example apps compile and run
- [ ] godoc examples compile (go test -run=Example)
- [ ] README examples reflect current API
- [ ] No TODO comments referencing old patterns

### v3.0 Specific Checks

- [ ] `For[T]()` no longer has OnStart/OnStop methods
- [ ] `service` package removed, all types in `gaz`
- [ ] `ProviderValues.Unmarshal()` works for complex structs
- [ ] All sentinel errors in `gaz/errors.go`
- [ ] `gaztest.Replace()` works with new registration
- [ ] `worker.Worker` compatible with Starter/Stopper
- [ ] `NewModule()` pattern consistent across subsystems

---

## Phase-Specific Warnings

| Phase | Likely Pitfall | Priority | Mitigation |
|-------|---------------|----------|------------|
| Configuration Harmonization | API-3 (Inflexible config) | P0 | Design interface before implementing |
| Lifecycle Alignment | API-2 (No escape hatch) | P0 | Plan Adapt() pattern for external types |
| Module Consolidation | API-1 (Naming inconsistency) | P0 | Establish naming convention first |
| Module Consolidation | API-10 (Import cycles) | P0 | Design package boundaries before moving code |
| Error Standardization | API-4 (Context loss) | P1 | Use namespaced sentinels |
| Testing Infrastructure | API-5 (Utilities drift) | P0 | Update gaztest WITH each change |
| Documentation | API-9 (Doc drift) | P1 | Compile-verified examples |
| All Phases | API-8 (Coverage loss) | P0 | Coverage gate in CI |

---

## Confidence Assessment

| Area | Level | Reason |
|------|-------|--------|
| Naming conventions | HIGH | Go standard patterns, uber-go/fx precedent |
| Error handling | HIGH | Go 1.13+ errors package patterns |
| Config design | MEDIUM | Specific to gaz, based on viper/koanf patterns |
| Testing utilities | HIGH | Testing patterns well-established in Go |
| Package boundaries | HIGH | Go import cycle rules are strict |
| Coverage maintenance | HIGH | Existing CI/coverage infrastructure |

---

## Sources

| Topic | Source | Confidence |
|-------|--------|------------|
| Go API design | Effective Go, Go Code Review Comments | HIGH |
| Functional options | Dave Cheney blog, uber-go/fx patterns | HIGH |
| Error handling | Go 1.13+ errors package, blog posts | HIGH |
| DI patterns | uber-go/fx Context7 docs | HIGH |
| Testing patterns | Go testing package, testify conventions | HIGH |
| gaz current state | Local codebase analysis | HIGH |
| Config patterns | viper, koanf documentation | MEDIUM |

---

## Open Questions

1. **Adapter vs Wrapper** — Should external type lifecycle use `Adapt()` or explicit wrapper types? Needs design decision.

2. **Error interface vs sentinels** — Should errors implement `Is()` for broad matching or stay as simple sentinels? Depends on error handling complexity.

3. **gaztest scope** — Should gaztest also provide helpers for integration tests (testcontainers) or stay focused on unit tests?
