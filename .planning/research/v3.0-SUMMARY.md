# Research Summary: v3.0 API Harmonization

**Milestone:** gaz v3.0 API Harmonization
**Domain:** Go DI Framework - API Consistency Refactoring
**Researched:** 2026-01-29
**Confidence:** HIGH

## Executive Summary

The v3.0 API Harmonization milestone is a clean-break refactoring opportunity to align gaz's API patterns with established Go DI framework conventions. Research of uber-go/fx, google/wire, and samber/do reveals strong consensus: **interface-based lifecycle management** (not fluent hooks), **module factory functions** (not package-level variables), and **config struct unmarshaling** (not per-key getters) are the industry standard patterns. gaz already has the right foundations (Starter/Stopper interfaces, ModuleBuilder, ProviderValues) but needs to remove redundant fluent APIs, consolidate the service package, and standardize patterns across subsystems.

The recommended approach is to proceed in dependency order: establish naming conventions first, then align lifecycle interfaces, harmonize configuration, consolidate modules, standardize errors, update testing utilities, and finally polish documentation. This ordering avoids the most critical pitfall identified in research: **inconsistent naming after service package merge**. Each phase should update gaztest alongside the core changes, not after, to prevent the second-most-critical pitfall: **testing utilities drift**.

Key risks are manageable with explicit mitigation strategies. The removal of fluent OnStart/OnStop requires an escape hatch for third-party types (sql.DB, http.Server) that can't implement interfaces - an Adapt() helper pattern resolves this. Error consolidation must preserve subsystem context through namespaced sentinels (ErrDINotFound, ErrConfigNotFound) rather than generic errors. Test coverage (currently 92.9%) must be maintained through coverage gates in CI.

## Key Findings

### Recommended Stack/Patterns

gaz's current stack is appropriate - no technology changes needed. The harmonization is about API patterns, not replacing dependencies.

**Patterns to adopt:**
- **Module Factory Functions**: Replace inline module definitions with `NewModule() gaz.Module` exported from each package (uber-go/fx pattern)
- **Interface-Only Lifecycle**: Remove `OnStart()`/`OnStop()` fluent methods from `For[T]()`, rely on `Starter`/`Stopper` interfaces (samber/do pattern)
- **Config Unmarshaling**: Add `ProviderValues.Unmarshal(prefix, &target)` for struct-based config (viper/mapstructure pattern)
- **Consistent Error Wrapping**: Standardize on `fmt.Errorf("verb-ing noun: %w", err)` pattern across all packages
- **Providers Always Return Error**: Deprecate `ProviderFunc()` variant, standardize on `func(*Container) (T, error)`

**Patterns to avoid:**
- fx.In/fx.Out parameter objects (too much boilerplate for Go)
- wire.Struct field injection (implicit, hard to reason about)
- Global provider sets (testing nightmare)
- Lifecycle hooks via separate Append calls (gaz's interface approach is better)

### Expected Features

**Table Stakes (must have for v3.0):**
- Type-safe generic registration API (DONE - `For[T]()` already works)
- Context-aware lifecycle hooks (DONE - Starter/Stopper accept context)
- Builder pattern with validation (DONE - ModuleBuilder exists)
- Config with defaults and validation (DONE - config.LoadInto works)
- Testing utilities (DONE - gaztest exists)
- **Consistent error types** (PARTIAL - needs consolidation)

**Differentiators (competitive advantage):**
- **Interface auto-detection for lifecycle** (HIGH value) - Services implementing Starter/Stopper are automatically wired
- **Unified module pattern** (MEDIUM value) - Modules bundle providers, flags, and config prefix
- **Consistent fluent API across packages** (HIGH value) - Learn once, use everywhere
- **Rich error context** (MEDIUM value) - Errors include subsystem, key name, hints

**Defer to v4.0+:**
- Opt-in debug mode (nice but not essential for API harmonization)
- Automatic sub-issue hierarchy in errors

**Anti-features (explicitly NOT building):**
- Global container / singleton access
- Spring-style field injection tags
- Automatic retry for failed providers
- Dynamic registration after Build()

### Architecture Approach

No dedicated ARCHITECTURE.md was produced, but architecture insights emerge from stack and pitfalls research:

**Package Boundaries (post-merge):**
```
gaz/
  ├── di/       -> standalone, imports nothing from gaz
  ├── config/   -> standalone, imports nothing from gaz  
  ├── health/   -> may import di for registration
  ├── worker/   -> may import di, implements Starter/Stopper
  ├── cron/     -> may import di and worker
  ├── eventbus/ -> standalone
  ├── gaztest/  -> imports gaz (test utility, allowed)
  └── (core)    -> imports subpackages, coordinates
```

**Key Architectural Decisions:**
1. **service package merges into gaz core** - Remove redundancy between service.Builder and gaz.App
2. **Worker becomes Starter/Stopper compliant** - Unify lifecycle management across all service types
3. **Errors consolidated in gaz/errors.go** - Single source of truth for sentinel errors
4. **Interfaces at package boundaries** - Prevent import cycles via interfaces (ServiceResolver, ConfigAccessor)

### Critical Pitfalls

1. **Inconsistent Naming After Merge (API-1)** - Merging service package without establishing naming convention first creates confusion (`gaz.New()` vs `gaz.NewService()` vs `gaz.NewModule()`). **Prevention:** Establish that all constructors follow same pattern (either all direct-return or all builder) before moving any code.

2. **No Escape Hatch for Third-Party Types (API-2)** - Removing fluent OnStart/OnStop breaks lifecycle management for types you don't control (sql.DB, http.Server). **Prevention:** Design and document `Adapt()` helper pattern for external types before removing fluent methods.

3. **Config System Inflexibility (API-3)** - Designing Unmarshal() narrowly prevents future extension. **Prevention:** Define ConfigAccessor interface with Sub(), Unmarshal(), UnmarshalKey() before implementing.

4. **Error Context Loss (API-4)** - Consolidating errors without subsystem prefixes makes debugging impossible. **Prevention:** Use namespaced sentinels (ErrDINotFound, ErrConfigNotFound) not generic ErrNotFound.

5. **Testing Utilities Drift (API-5)** - Updating gaztest last means tests break or become verbose during transition. **Prevention:** Update gaztest in the SAME PR as each API change, not after.

## Implications for Roadmap

Based on research, suggested phase structure:

### Phase 1: Foundation & Package Boundaries
**Rationale:** Establish conventions before merging anything - API-1 and API-10 prevention
**Delivers:** Naming convention document, package boundary diagram, error naming scheme
**Addresses:** Foundational consistency (prevents downstream rework)
**Avoids:** API-1 (naming inconsistency), API-10 (import cycles)

### Phase 2: Lifecycle Interface Alignment  
**Rationale:** Lifecycle is core to everything else - Worker, health, service all depend on it
**Delivers:** Remove fluent OnStart/OnStop, add Adapt() for external types, align worker.Worker with Starter/Stopper
**Addresses:** Interface auto-detection (differentiator), Worker alignment (v3 goal)
**Avoids:** API-2 (no escape hatch for third-party types)

### Phase 3: Configuration Harmonization
**Rationale:** Config is used everywhere - must be right before module consolidation
**Delivers:** ProviderValues.Unmarshal(), ConfigAccessor interface, Sub() for namespacing
**Addresses:** Config unmarshaling (v3 goal), consistent API (differentiator)
**Avoids:** API-3 (inflexible config)

### Phase 4: Module & Service Consolidation
**Rationale:** Depends on stable lifecycle and config patterns
**Delivers:** Merge service package into gaz, standardize NewModule() pattern, remove ModuleBuilder internals from public API
**Addresses:** Service merge (v3 goal), module standardization (v3 goal)
**Avoids:** API-6 (factory pattern fragmentation)

### Phase 5: Error Standardization
**Rationale:** Can happen after API stabilizes - avoids churn in error messages
**Delivers:** Consolidated gaz/errors.go, namespaced sentinels, consistent wrapping
**Addresses:** Error consolidation (v3 goal), rich error context (differentiator)
**Avoids:** API-4 (context loss)

### Phase 6: Testing Infrastructure
**Rationale:** While gaztest should update WITH each phase, a final dedicated phase ensures completeness
**Delivers:** Updated gaztest for all v3 patterns, lifecycle testing helpers, config test helpers
**Addresses:** Testing utilities (table stakes), comprehensive test patterns
**Avoids:** API-5 (utilities drift) - but this should be ongoing, not just final phase

### Phase 7: Documentation & Style Guides
**Rationale:** Final polish after API is stable
**Delivers:** Updated README, godoc examples, style guide, migration notes
**Addresses:** Documentation (v3 goal)
**Avoids:** API-9 (documentation drift)

### Phase Ordering Rationale

- **Foundation first (Phase 1):** Naming conventions must exist before any merging to prevent API-1
- **Lifecycle before modules (Phase 2 before 4):** Worker alignment and Starter/Stopper patterns affect how services and modules work
- **Config before modules (Phase 3 before 4):** Module configuration depends on ProviderValues patterns
- **Errors after API changes (Phase 5):** Avoids churn - finalize errors after API stabilizes
- **Testing throughout + final sweep (Phase 6):** Update gaztest WITH each change, then sweep for completeness
- **Docs last (Phase 7):** Document stable API, not moving target

### Research Flags

**Phases likely needing deeper research during planning:**
- **Phase 2 (Lifecycle):** The Adapt() pattern for external types needs design exploration - how exactly should it work?
- **Phase 4 (Module Consolidation):** Package boundary enforcement and import cycle prevention needs careful planning

**Phases with standard patterns (can skip research-phase):**
- **Phase 3 (Configuration):** Viper's UnmarshalKey is well-documented, straightforward
- **Phase 5 (Errors):** Go error patterns are well-established
- **Phase 7 (Documentation):** Standard godoc and example patterns

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack/Patterns | HIGH | Verified via Context7 for uber-go/fx, google/wire, samber/do |
| Features | HIGH | Combination of industry patterns + existing gaz codebase analysis |
| Architecture | MEDIUM | Inferred from stack and pitfalls (no dedicated architecture research) |
| Pitfalls | HIGH | Comprehensive analysis of API refactoring risks |

**Overall confidence:** HIGH

### Gaps to Address

- **Adapt() Pattern Design:** The exact API for lifecycle adaptation of external types needs design work during Phase 2 planning. Options: `Adapt()`, `WithLifecycle()`, or separate `OnStop[T]()` function.

- **Worker Interface Migration:** Whether to modify `worker.Worker` interface directly or create compatibility layer needs decision. Research suggests interface modification to add context/error, but breaking change implications need assessment.

- **gaztest Scope:** Should gaztest provide integration test helpers (testcontainers) or stay unit-focused? Current research doesn't resolve this - defer decision to Phase 6.

- **Error Interface Design:** Whether to use simple namespaced sentinels or typed errors with `Is()` implementation depends on actual error handling complexity. Can decide during Phase 5.

## Sources

### Primary (HIGH confidence)
- `/uber-go/fx` via Context7 - Module patterns, lifecycle hooks, error handling (176 code snippets)
- `/google/wire` via Context7 - Provider patterns, interface binding (81 code snippets)  
- `/samber/do` via Context7 - Generic DI, lifecycle interfaces (186 code snippets)
- gaz codebase analysis - Existing patterns in di/, config/, worker/, health/, gaztest/

### Secondary (MEDIUM confidence)
- Viper/mapstructure patterns - Config unmarshaling conventions
- Go Code Review Comments - API design conventions
- Dave Cheney functional options blog - Constructor pattern recommendations

### Tertiary (needs validation during implementation)
- Worker interface modification impact - Inferred from patterns, needs codebase verification
- gaztest coverage of new patterns - Requires implementation to validate

---
*Research completed: 2026-01-29*
*Ready for roadmap: yes*
