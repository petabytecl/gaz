# Technology Stack: API Harmonization Patterns

**Project:** gaz v3.0 API Harmonization
**Researched:** 2026-01-29
**Focus:** Patterns from uber-go/fx, google/wire, samber/do

## Executive Summary

Research of established Go DI frameworks reveals strong consensus on several API patterns that gaz should adopt for v3.0 harmonization. The key insights:

1. **Interface-based lifecycle management** (samber/do) is superior to fluent hook chains (uber-go/fx) for Go's idioms - gaz already has `Starter`/`Stopper` interfaces, should remove fluent `OnStart()`/`OnStop()` from registration API
2. **Module factory functions** returning `Module` (uber-go/fx pattern) is the industry standard for module composition - gaz should adopt `NewModule() Module` factory pattern  
3. **Config unmarshaling via generic methods** (mapstructure pattern) is preferred over per-key getters - gaz's `ProviderValues.Unmarshal(prefix, &target)` proposal aligns with this
4. **Error wrapping with context** is consistent across all frameworks - gaz should standardize on `fmt.Errorf("context: %w", err)` pattern

**Overall Confidence:** HIGH - All patterns verified via Context7 official documentation.

---

## Patterns to Adopt

### 1. Module Factory Function Pattern

**Source:** uber-go/fx (HIGH confidence)
**Applicability:** Replaces gaz's current inline module definition with explicit factory pattern

**Current gaz pattern (mixed usage):**
```go
// Some places use inline
module := gaz.NewModule("health").
    Provide(health.Module).
    Build()
app.Use(module)

// Other places define modules in packages (good)
healthModule := gaz.NewModule("health").
    Provide(health.Module).
    Build()
```

**Recommended standardized pattern (from fx):**
```go
// health/module.go - Package exports factory function
func NewModule() gaz.Module {
    return gaz.NewModule("health").
        Provide(RegisterHealthChecks).
        Provide(RegisterServer).
        Build()
}

// Parameterized variant for configuration
func NewModuleWithConfig(cfg Config) gaz.Module {
    return gaz.NewModule("health").
        Provide(func(c *gaz.Container) error {
            return gaz.For[Config](c).Instance(cfg)
        }).
        Provide(RegisterHealthChecks).
        Build()
}

// Usage - clean and explicit
app.Use(health.NewModule())
app.Use(health.NewModuleWithConfig(cfg))
```

**Why this works:**
- Factory functions can accept configuration parameters
- Enables lazy module construction - caller controls when module is built
- Matches Go's idiomatic constructor pattern (`NewX()` returns configured type)
- Clear ownership: package owns its module definition
- uber-go/fx uses exactly this pattern: `fx.Module("name", fx.Provide(...))` returns composable unit

**Implementation notes for gaz:**
- Keep `ModuleBuilder` as internal implementation detail
- Export `NewModule(name)` for simple cases
- Document factory function pattern as recommended approach
- Example: `health.NewModule()`, `worker.NewModule()`, `eventbus.NewModule()`

---

### 2. Interface-Based Lifecycle (Remove Fluent Hooks)

**Source:** samber/do (HIGH confidence)
**Applicability:** Removes `OnStart()`/`OnStop()` from `RegistrationBuilder`, relies on `Starter`/`Stopper` interfaces

**Current gaz pattern in health/module.go (to refactor):**
```go
// Current: Fluent hooks on registration
gaz.For[*ManagementServer](c).
    OnStart(func(ctx context.Context, s *ManagementServer) error {
        return s.Start(ctx)
    }).
    OnStop(func(ctx context.Context, s *ManagementServer) error {
        return s.Stop(ctx)
    }).
    Eager().
    Provider(NewManagementServer)
```

**Recommended pattern (samber/do style):**
```go
// ManagementServer implements gaz.Starter and gaz.Stopper
type ManagementServer struct { ... }

func (s *ManagementServer) OnStart(ctx context.Context) error {
    return s.start(ctx) // internal start logic
}

func (s *ManagementServer) OnStop(ctx context.Context) error {
    return s.stop(ctx) // internal stop logic
}

// Registration is now simpler - lifecycle detected automatically
gaz.For[*ManagementServer](c).Eager().Provider(NewManagementServer)
```

**Why this works:**
- Go interfaces are discoverable via type assertion at runtime (gaz already does this)
- No closure overhead for lifecycle hooks
- Service owns its lifecycle logic (encapsulation principle)
- Testable: mock services can implement same interfaces
- samber/do uses exact same pattern: `Shutdowner`, `Healthchecker` interfaces
- Reduces API surface area - fewer methods to learn

**samber/do reference (from Context7):**
```go
// do's interface-based lifecycle
type Database struct { db *sql.DB }

func (d *Database) HealthCheck() error {
    return d.db.Ping()
}

func (d *Database) Shutdown(ctx context.Context) error {
    return d.db.Close()
}
```

**Migration path:**
1. Document that `Starter`/`Stopper` interfaces are preferred approach
2. Deprecate `OnStart()`/`OnStop()` on `RegistrationBuilder` (v3.0)
3. Remove fluent methods in v4.0 (breaking change but clean API)

---

### 3. ProviderValues.Unmarshal() Pattern

**Source:** samber/do + Viper conventions (MEDIUM confidence)
**Applicability:** Replaces per-key getters with struct unmarshaling for config

**Current gaz pattern:**
```go
func NewRedisClient(c *gaz.Container) (*RedisClient, error) {
    pv := gaz.MustResolve[*gaz.ProviderValues](c)
    host := pv.GetString("redis.host")
    port := pv.GetInt("redis.port")
    timeout := pv.GetDuration("redis.timeout")
    // ... 
}
```

**Recommended pattern:**
```go
type RedisConfig struct {
    Host    string        `mapstructure:"host"`
    Port    int           `mapstructure:"port"`
    Timeout time.Duration `mapstructure:"timeout"`
}

func NewRedisClient(c *gaz.Container) (*RedisClient, error) {
    pv := gaz.MustResolve[*gaz.ProviderValues](c)
    
    var cfg RedisConfig
    if err := pv.Unmarshal("redis", &cfg); err != nil {
        return nil, fmt.Errorf("unmarshal redis config: %w", err)
    }
    
    // cfg.Host, cfg.Port, cfg.Timeout are now populated
    return NewRedisClientWithConfig(cfg), nil
}
```

**Why this works:**
- Single call replaces N getter calls
- Struct tags provide documentation and validation hooks
- Type safety at compile time (wrong field type = unmarshal error)
- Aligns with Viper's `UnmarshalKey()` pattern (gaz already uses Viper backend)
- samber/do's `Eager()` pattern shows value of pre-built config structs

**Implementation for gaz:**
```go
// Add to ProviderValues struct
func (pv *ProviderValues) Unmarshal(prefix string, target any) error {
    return pv.backend.UnmarshalKey(prefix, target)
}

// Optional: Add validation hook
func (pv *ProviderValues) UnmarshalAndValidate(prefix string, target any) error {
    if err := pv.backend.UnmarshalKey(prefix, target); err != nil {
        return err
    }
    if v, ok := target.(Validatable); ok {
        return v.Validate()
    }
    return nil
}
```

**Keep per-key getters:** Still useful for simple cases and backward compat.

---

### 4. Consistent Error Wrapping Convention

**Source:** All frameworks (HIGH confidence)
**Applicability:** Standardize error messages across gaz packages

**Pattern from uber-go/fx:**
```go
// Always wrap with context, use past tense verb
return nil, fmt.Errorf("failed to listen: %w", err)
return nil, fmt.Errorf("failed to shutdown gracefully: %w", err)
```

**Pattern from google/wire:**
```go
// Providers return descriptive errors
if bar.X == 0 {
    return Baz{}, errors.New("cannot provide baz when bar is zero")
}
```

**Recommended gaz convention:**
```go
// Package-level sentinel errors (already in gaz/errors.go)
var (
    ErrNotFound  = errors.New("gaz: service not found")
    ErrCycle     = errors.New("gaz: circular dependency detected")
    ErrDuplicate = errors.New("gaz: duplicate registration")
)

// Wrapped errors with action context
return fmt.Errorf("starting service %s: %w", name, err)
return fmt.Errorf("stopping service %s: %w", name, err)
return fmt.Errorf("resolving %s: %w", typeName, ErrNotFound)
return fmt.Errorf("registering %s: %w", typeName, ErrDuplicate)
return fmt.Errorf("unmarshal %s config: %w", namespace, err)

// Error message pattern: "verb-ing noun: %w"
// Verbs: starting, stopping, resolving, registering, unmarshaling, loading
```

**Error consolidation for gaz v3:**
- Keep sentinel errors in `gaz/errors.go`
- Document wrapping conventions in CONTRIBUTING.md
- Apply consistent pattern across all packages

---

### 5. Constructor Signature: Provider Always Returns Error

**Source:** All frameworks (HIGH confidence)
**Applicability:** Remove `ProviderFunc()` variant, standardize on error-returning providers

**Consistent pattern across fx, wire, do:**
```go
// Provider ALWAYS returns error - this is the universal pattern
func NewService(c *Container) (*Service, error) {
    dep, err := Resolve[*Dependency](c)
    if err != nil {
        return nil, err
    }
    return &Service{dep: dep}, nil
}
```

**samber/do enforces this (from Context7):**
```go
// do requires error return
func NewUserService(i do.Injector) (*UserService, error) {
    db := do.MustInvoke[*Database](i)  // panics on error
    return &UserService{db: db}, nil   // still returns error
}
```

**Current gaz has two variants:**
```go
// Provider - with error (correct)
func (b *RegistrationBuilder[T]) Provider(fn func(*Container) (T, error)) error

// ProviderFunc - without error (to deprecate)
func (b *RegistrationBuilder[T]) ProviderFunc(fn func(*Container) T) error
```

**Recommendation:**
- Deprecate `ProviderFunc()` in v3.0 documentation
- Remove in v4.0
- For infallible providers: `return &Config{}, nil` (explicit nil error)

---

### 6. Invoke Dependencies in Provider, Not Later

**Source:** samber/do (HIGH confidence)
**Applicability:** Best practice documentation for gaz providers

**Anti-pattern (from do docs):**
```go
// DON'T store container/injector for later resolution
type MyService struct {
    container *gaz.Container  // Anti-pattern!
}
func NewMyService(c *gaz.Container) (*MyService, error) {
    return &MyService{container: c}, nil  // Deferred resolution
}

// Later in method - errors surface at RUNTIME
func (s *MyService) DoWork() error {
    dep, err := gaz.Resolve[*Dependency](s.container)  // Runtime failure!
    // ...
}
```

**Correct pattern:**
```go
// DO resolve dependencies immediately in constructor
type MyService struct {
    dependency *Dependency  // Resolved at construction
}
func NewMyService(c *gaz.Container) (*MyService, error) {
    dep, err := gaz.Resolve[*Dependency](c)
    if err != nil {
        return nil, err  // Error surfaces at BUILD time
    }
    return &MyService{dependency: dep}, nil
}
```

**Why this matters:**
- Errors surface at startup (Build()), not runtime
- Dependency graph is fully validated during Build()
- No hidden runtime failures
- Easier to test - dependencies are explicit

**gaz action:** Document this as best practice in provider documentation.

---

## Patterns to AVOID

### 1. fx.In/fx.Out Parameter Objects

**Source:** uber-go/fx (avoid for gaz)
**What it is:**

```go
// fx pattern - struct-based dependency declaration
type RepositoryParams struct {
    fx.In
    WriteDB *sql.DB `name:"rw"`
    ReadDB  *sql.DB `name:"ro"`
    Logger  *zap.Logger
}

func NewRepository(p RepositoryParams) *Repository {
    return &Repository{writeDB: p.WriteDB, readDB: p.ReadDB}
}
```

**Why gaz should NOT adopt:**
- Adds struct boilerplate for simple dependency injection
- gaz's generic `Resolve[T]()` is more Go-idiomatic
- Named dependencies via `Named("alias")` is sufficient
- fx.In/fx.Out relies on reflection; gaz uses compile-time generics
- Increases cognitive load for simple cases

**gaz alternative (already good):**
```go
func NewRepository(c *gaz.Container) (*Repository, error) {
    writeDB := gaz.MustResolve[*sql.DB](c, gaz.Named("rw"))
    readDB := gaz.MustResolve[*sql.DB](c, gaz.Named("ro"))
    logger := gaz.MustResolve[*slog.Logger](c)
    return &Repository{writeDB: writeDB, readDB: readDB, logger: logger}, nil
}
```

---

### 2. wire.Struct Field Injection

**Source:** google/wire (avoid for gaz)
**What it is:**

```go
// wire pattern - implicit field filling
var Set = wire.NewSet(
    ProvideFoo,
    ProvideBar,
    wire.Struct(new(FooBar), "*"))  // Auto-fills all fields
```

**Why gaz should NOT adopt:**
- Implicit behavior hides dependencies
- Fields can be accidentally injected
- Go convention: explicit construction in constructors
- gaz's explicit `Provider()` function is clearer
- Hard to reason about what's being injected

---

### 3. Lifecycle Hooks via Separate Append Calls

**Source:** uber-go/fx lc.Append pattern (avoid for gaz)
**What it is:**

```go
// fx pattern - lifecycle injected as dependency
func NewHTTPServer(lc fx.Lifecycle, cfg *Config) *http.Server {
    srv := &http.Server{Addr: cfg.Addr}
    
    lc.Append(fx.Hook{
        OnStart: func(ctx context.Context) error {
            ln, err := net.Listen("tcp", srv.Addr)
            // ...
        },
        OnStop: func(ctx context.Context) error {
            return srv.Shutdown(ctx)
        },
    })
    
    return srv
}
```

**Why gaz should NOT adopt:**
- Requires injecting lifecycle dependency (`fx.Lifecycle`)
- Separates lifecycle logic from service definition
- Interface-based (`Starter`/`Stopper`) is cleaner for gaz
- gaz already has the right pattern - would be regression

**gaz's better pattern:**
```go
// Server implements Starter/Stopper interfaces
type Server struct { ... }

func (s *Server) OnStart(ctx context.Context) error { ... }
func (s *Server) OnStop(ctx context.Context) error { ... }

// Registration - no lifecycle dependency needed
gaz.For[*Server](c).Provider(NewServer)
```

---

### 4. Global Provider Sets (wire pattern)

**Source:** google/wire (avoid for gaz)
**What it is:**

```go
// wire pattern - package-level variable
var SuperSet = wire.NewSet(ProvideFoo, ProvideBar, ProvideBaz)
```

**Why gaz should NOT adopt:**
- Package-level variables are anti-pattern in Go
- Makes testing harder (global state)
- gaz's `Module` factory functions are superior
- Modules are passed explicitly, not imported as side-effect
- Can't parameterize based on configuration

---

## Framework Comparison Matrix

| Feature | uber-go/fx | google/wire | samber/do | gaz (current) | gaz v3 (recommended) |
|---------|-----------|-------------|-----------|---------------|----------------------|
| **DI Mechanism** | Runtime reflection | Compile-time codegen | Runtime + generics | Runtime + generics | Keep current |
| **Lifecycle** | Fluent lc.Append | None | Interfaces | Both fluent + interfaces | **Interfaces only** |
| **Modules** | fx.Module() | wire.NewSet | do.Package() | ModuleBuilder | **Factory functions** |
| **Config** | fx.Supply | N/A | ProvideValue | ConfigProvider + getters | **Add Unmarshal()** |
| **Error handling** | fx.ErrorHook | Compile-time | Invoke returns error | errors.Join | Keep, improve wrapping |
| **Generics** | No (pre-generics) | No (codegen) | Yes | Yes | Keep |
| **Named deps** | Struct tags | N/A | NamedFunctions | Named() method | Keep |

---

## Specific Recommendations for API Harmonization

### Priority 1: Remove Fluent Lifecycle Hooks
**Impact:** Breaking change, cleaner API

```go
// Remove from di/registration.go
func (b *RegistrationBuilder[T]) OnStart(...) *RegistrationBuilder[T]  // REMOVE
func (b *RegistrationBuilder[T]) OnStop(...) *RegistrationBuilder[T]   // REMOVE

// Rely entirely on interface detection (already implemented)
type Starter interface { OnStart(context.Context) error }
type Stopper interface { OnStop(context.Context) error }
```

**Migration for existing code (health/module.go):**
```go
// BEFORE
gaz.For[*ManagementServer](c).
    OnStart(func(ctx context.Context, s *ManagementServer) error { return s.Start(ctx) }).
    OnStop(func(ctx context.Context, s *ManagementServer) error { return s.Stop(ctx) }).
    Eager().Provider(NewManagementServer)

// AFTER - ManagementServer implements Starter/Stopper
gaz.For[*ManagementServer](c).Eager().Provider(NewManagementServer)
```

---

### Priority 2: Add ProviderValues.Unmarshal()

```go
// Add to provider_config.go
func (pv *ProviderValues) Unmarshal(prefix string, target any) error {
    return pv.backend.UnmarshalKey(prefix, target)
}
```

---

### Priority 3: Standardize Module Factory Pattern

```go
// Document and enforce pattern across all packages:
// health/module.go
func NewModule() gaz.Module {
    return gaz.NewModule("health").
        Provide(registerComponents).
        Build()
}

// worker/module.go  
func NewModule() gaz.Module { ... }

// eventbus/module.go
func NewModule() gaz.Module { ... }
```

---

### Priority 4: Worker Interface Alignment

**Current worker.Worker:**
```go
type Worker interface {
    Start()           // Non-blocking, no error, no context
    Stop()            // May block, no error, no context
    Name() string
}
```

**Recommend aligning with Starter/Stopper:**
```go
// Option A: Workers just implement Starter/Stopper
type WorkerService struct { ... }

func (w *WorkerService) OnStart(ctx context.Context) error {
    go w.run(ctx)  // Non-blocking
    return nil
}

func (w *WorkerService) OnStop(ctx context.Context) error {
    return w.stop(ctx)
}

// Option B: Keep Worker interface but add context/error
type Worker interface {
    Name() string
    Start(context.Context) error
    Stop(context.Context) error
}
```

This unifies lifecycle management: workers and services use same interface pattern.

---

### Priority 5: Merge or Deprecate service Package

The `service.Builder` duplicates `gaz.App` functionality:

| service.Builder | gaz.App equivalent |
|-----------------|-------------------|
| `WithCmd()` | `WithCobra()` |
| `WithConfig()` | `WithConfig()` |
| `Use()` | `Use()` |
| `Build()` | `Build()` |

**Recommendation:** Deprecate `service.Builder` in favor of direct `gaz.App` usage with builder methods.

---

## Sources

All patterns verified via Context7 official documentation:

- `/uber-go/fx` - Module patterns, lifecycle hooks, error handling (176 code snippets, High reputation)
- `/google/wire` - Provider sets, struct providers, interface binding (81 code snippets, High reputation)
- `/samber/do` - Generic DI, lifecycle interfaces, scope management (186 code snippets, High reputation)

**Confidence Assessment:**

| Area | Confidence | Source |
|------|------------|--------|
| Module factory pattern | HIGH | Consistent across fx, do |
| Interface-based lifecycle | HIGH | samber/do primary pattern |
| Error wrapping conventions | HIGH | All frameworks consistent |
| ProviderValues.Unmarshal() | MEDIUM | Viper convention, do pattern |
| Worker alignment | MEDIUM | Inference from lifecycle patterns |
| service package merge | MEDIUM | Code analysis, not framework pattern |
