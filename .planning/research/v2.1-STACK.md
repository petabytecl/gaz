# Technology Stack: GAZ v2.1 API Enhancement

**Project:** GAZ v2.1 - RuntimeX-inspired API improvements
**Researched:** 2026-01-29
**Confidence:** HIGH (verified via Context7 + official sources)

## Executive Summary

GAZ v2.1 adds RuntimeX-inspired features to the existing framework. The good news: **no new external dependencies required**. All eight features can be implemented using Go's standard library capabilities already available in Go 1.25.6.

The existing stack (Cobra 1.10.2, Viper 1.21.0, testify 1.11.1) is current and sufficient. This milestone is purely additive code, not dependency changes.

## Current Stack (Verified Current)

| Dependency | Current Version | Latest | Status | Source |
|------------|-----------------|--------|--------|--------|
| Go | 1.25.6 | 1.25.6 | Current | go.mod |
| github.com/spf13/cobra | 1.10.2 | 1.10.2 | Current | GitHub releases |
| github.com/spf13/viper | 1.21.0 | - | Current | go.mod |
| github.com/stretchr/testify | 1.11.1 | 1.11.1 | Current | GitHub releases |
| github.com/jpillora/backoff | 1.0.0 | 1.0.0 | Current | go.mod |
| github.com/robfig/cron/v3 | 3.0.1 | 3.0.1 | Current | go.mod |

**No updates required for v2.1.**

## Feature-by-Feature Stack Analysis

### 1. Interface Auto-Detection for Starter/Stopper

**Requirement:** Automatically detect if services implement `Starter`/`Stopper` interfaces after construction.

**Stack:** Go standard library only

| Package | Purpose | Why |
|---------|---------|-----|
| `reflect` | Type introspection | Check if value implements interface via `reflect.Type.Implements()` |

**Implementation pattern (verified via Context7):**
```go
import "reflect"

var starterType = reflect.TypeOf((*Starter)(nil)).Elem()
var stopperType = reflect.TypeOf((*Stopper)(nil)).Elem()

func implementsStarter(v any) bool {
    t := reflect.TypeOf(v)
    return t.Implements(starterType)
}
```

**Why no external library:**
- Go's `reflect.Type.Implements()` is the canonical way
- No third-party alternatives exist that are simpler
- Pattern already used in GAZ for EventBus type routing

**Confidence:** HIGH (Context7 Go documentation verified)

---

### 2. Build Info Package (ldflags Integration)

**Requirement:** Package to capture and expose version, commit, build time from ldflags.

**Stack:** Go standard library only

| Package | Purpose | Why |
|---------|---------|-----|
| `runtime/debug` | Read build info | `debug.ReadBuildInfo()` provides module version automatically |

**Implementation pattern (verified via Context7):**
```go
package buildinfo

import "runtime/debug"

var (
    Version   = "dev"      // Set via -ldflags "-X pkg.Version=v1.0.0"
    Commit    = "unknown"  // Set via -ldflags "-X pkg.Commit=$(git rev-parse HEAD)"
    BuildTime = "unknown"  // Set via -ldflags "-X pkg.BuildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
)

func Info() BuildInfo {
    info, ok := debug.ReadBuildInfo()
    // Merge ldflags values with debug.ReadBuildInfo for VCS info
}
```

**Go 1.18+ bonus:** `debug.ReadBuildInfo()` automatically captures VCS revision and modified status when built with `go build`. This supplements ldflags for dev builds.

**Why no external library:**
- `runtime/debug.ReadBuildInfo()` is the standard approach
- ldflags injection is standard Go toolchain (`-X`)
- No alternatives provide value over stdlib

**Confidence:** HIGH (Context7 Go documentation verified)

---

### 3. Command Arguments Injection

**Requirement:** Allow injecting `[]string` args into providers/commands.

**Stack:** Go standard library + existing Cobra

| Package | Purpose | Why |
|---------|---------|-----|
| Standard Go | Slice type | `[]string` is primitive |
| `github.com/spf13/cobra` (existing) | CLI args | Already captures args in `RunE(cmd, args []string)` |

**Implementation pattern:**
```go
// Store args in App for injection
type App struct {
    args []string
}

func (a *App) SetArgs(args []string) {
    a.args = args
}

// In PersistentPreRunE, capture args
cmd.PersistentPreRunE = func(c *cobra.Command, args []string) error {
    a.SetArgs(args)
    // ... rest of bootstrap
}

// Provider can receive args via special resolution
```

**Why no external library:**
- Args are already available in Cobra handlers
- Just need internal plumbing to make them injectable
- No external alternatives exist

**Confidence:** HIGH (pattern is straightforward)

---

### 4. Pre/Post Run Hooks

**Requirement:** Allow registering hooks that run before/after lifecycle Start/Stop.

**Stack:** Go standard library only

| Package | Purpose | Why |
|---------|---------|-----|
| Standard Go | Slice storage | `[]HookFunc` for pre/post hook lists |
| `context` | Timeout/cancel | Already used in lifecycle |

**Implementation pattern:**
```go
type LifecycleEngine struct {
    preStartHooks  []HookFunc
    postStartHooks []HookFunc
    preStopHooks   []HookFunc
    postStopHooks  []HookFunc
}

func (e *LifecycleEngine) OnPreStart(fn HookFunc) {
    e.preStartHooks = append(e.preStartHooks, fn)
}
```

**Why no external library:**
- Hook registration is slice management
- Execution order is straightforward
- Already have `HookFunc` type defined

**Confidence:** HIGH (pattern exists in codebase)

---

### 5. Frame Introspection Utilities

**Requirement:** Better error messages with caller information (file, line, function).

**Stack:** Go standard library only

| Package | Purpose | Why |
|---------|---------|-----|
| `runtime` | Stack frames | `runtime.Caller()`, `runtime.Callers()` for stack inspection |

**Implementation pattern (verified via Context7):**
```go
import "runtime"

// CallerInfo returns file:line for the caller N frames up
func CallerInfo(skip int) (file string, line int, ok bool) {
    _, file, line, ok = runtime.Caller(skip + 1)
    return
}

// For registration errors, capture registration site
type registration struct {
    file string
    line int
}
```

**Why no external library:**
- `runtime.Caller()` is the only way to get this info
- Error wrapping with location is standard pattern
- pkg/errors is deprecated, std library `errors` + `runtime` is preferred

**Confidence:** HIGH (Context7 verified, already used in eventbus)

---

### 6. Service Builder Pattern

**Requirement:** Fluent builder API for complex service configuration.

**Stack:** Go standard library only

**Implementation pattern:**
```go
type ServiceBuilder[T any] struct {
    app      *App
    provider func() T
    name     string
    asTypes  []reflect.Type
    hooks    []HookFunc
}

func NewServiceBuilder[T any](app *App) *ServiceBuilder[T] {
    return &ServiceBuilder[T]{app: app}
}

func (b *ServiceBuilder[T]) Provider(fn func() T) *ServiceBuilder[T] {
    b.provider = fn
    return b
}

func (b *ServiceBuilder[T]) Name(name string) *ServiceBuilder[T] {
    b.name = name
    return b
}

func (b *ServiceBuilder[T]) Build() error {
    // Register with container
}
```

**Why no external library:**
- Builder pattern is idiomatic Go struct + methods
- Generics (Go 1.18+) enable type-safe builders
- No builder library provides value

**Confidence:** HIGH (pattern is well-established)

---

### 7. Unified Provider Type

**Requirement:** Single `Provider[T]` type that can be provider func, instance, or factory.

**Stack:** Go standard library only

| Package | Purpose | Why |
|---------|---------|-----|
| `reflect` | Type introspection | Determine if provider is func vs value |

**Implementation pattern:**
```go
// Provider wraps different construction strategies
type Provider[T any] struct {
    instance *T
    factory  func() (T, error)
    provider func(...any) (T, error) // With dependencies
}

// AsInstance creates a provider from a pre-constructed value
func AsInstance[T any](v T) Provider[T] {
    return Provider[T]{instance: &v}
}

// AsFactory creates a provider from a zero-dependency factory
func AsFactory[T any](fn func() (T, error)) Provider[T] {
    return Provider[T]{factory: fn}
}
```

**Why no external library:**
- Generic wrapper struct is sufficient
- reflect package handles type inspection
- No external alternatives

**Confidence:** HIGH (pattern is straightforward)

---

### 8. Enhanced Test Builder (fxtest-inspired)

**Requirement:** Better testing utilities with `RequireStart()`/`RequireStop()` and lifecycle control.

**Stack:** Existing testify (already in go.mod)

| Package | Purpose | Why |
|---------|---------|-----|
| `github.com/stretchr/testify` | Assertions | Already a dependency, provides `require` package |
| `testing` | Test framework | Standard Go |

**fxtest API analysis (verified via pkg.go.dev):**
```go
// fxtest.App wraps fx.App with test helpers
type App struct {
    *fx.App
    tb testing.TB
}

func (app *App) RequireStart() *App  // Start or fail test
func (app *App) RequireStop()        // Stop or fail test

// fxtest.Lifecycle for unit testing hooks
type Lifecycle struct{}
func (l *Lifecycle) RequireStart() *Lifecycle
func (l *Lifecycle) RequireStop()
```

**GAZ implementation pattern:**
```go
package gaztest

import (
    "testing"
    "github.com/stretchr/testify/require"
)

// TestApp wraps gaz.App with test helpers
type TestApp struct {
    *gaz.App
    t testing.TB
}

func New(t testing.TB, opts ...gaz.Option) *TestApp {
    return &TestApp{
        App: gaz.New(opts...),
        t:   t,
    }
}

func (a *TestApp) RequireStart() *TestApp {
    require.NoError(a.t, a.Build())
    require.NoError(a.t, a.Start(context.Background()))
    return a
}

func (a *TestApp) RequireStop() {
    require.NoError(a.t, a.Stop(context.Background()))
}
```

**Why no additional dependencies:**
- testify 1.11.1 is already a dependency
- `require.NoError()` provides fail-fast behavior
- fxtest pattern is simple wrapper, not library

**Confidence:** HIGH (pkg.go.dev verified, testify already present)

---

## Stack NOT to Add

| Library | Why Considered | Why NOT Added |
|---------|----------------|---------------|
| `uber-go/fx` | RuntimeX inspiration | Would replace GAZ's custom DI; GAZ is intentionally lighter |
| `pkg/errors` | Stack traces | Deprecated; use stdlib `errors` + `runtime.Caller()` |
| `go.uber.org/multierr` | Error aggregation | `errors.Join()` available in Go 1.20+ |
| `github.com/hashicorp/go-multierror` | Error aggregation | Same as above, stdlib is sufficient |
| Any DI framework | Feature parity | GAZ IS the DI framework being enhanced |

---

## Go Version Requirements

**Current:** Go 1.25.6 (per go.mod)

**Required features used:**
| Feature | Available Since | Used For |
|---------|-----------------|----------|
| Generics | Go 1.18 | Type-safe DI, Provider[T], ServiceBuilder[T] |
| `errors.Join()` | Go 1.20 | Multi-error aggregation in lifecycle |
| `debug.ReadBuildInfo()` VCS | Go 1.18 | Auto-capture git revision |
| `sync.WaitGroup.Go()` | Go 1.25 | Cleaner goroutine spawning (optional) |
| `reflect.Type.Implements()` | Go 1.0 | Interface detection |

**No Go version upgrade required.**

---

## Dependency Update Recommendations

**None.** Current versions are at latest stable.

| Dependency | Current | Action |
|------------|---------|--------|
| cobra | 1.10.2 | Keep (latest as of Dec 2025) |
| viper | 1.21.0 | Keep |
| testify | 1.11.1 | Keep (latest as of Aug 2025) |
| backoff | 1.0.0 | Keep |
| cron/v3 | 3.0.1 | Keep |

---

## Integration Points with Existing Stack

### Interface Auto-Detection
- Integrates with: `di/lifecycle.go` Starter/Stopper interfaces
- Modify: `di/service.go` to detect interfaces after construction
- Pattern: Same `reflect.TypeOf((*T)(nil)).Elem()` as EventBus

### Build Info
- New package: `buildinfo/`
- Integrates with: App construction, health endpoints, version command
- Uses: Same ldflags pattern as common Go projects

### Command Args
- Integrates with: `cobra.go` WithCobra function
- Modify: App struct to store args
- New: Provider for `[]string` args

### Pre/Post Hooks
- Integrates with: `lifecycle_engine.go`
- Modify: LifecycleEngine to support hook phases
- Uses: Existing HookFunc type

### Frame Introspection
- New utility package or extend: `di/errors.go`
- Uses: `runtime.Caller()` for registration site capture
- Improves: Error messages throughout

### Service Builder
- New: Alternative API alongside existing `For[T]()`
- Integrates with: Container registration
- Uses: Generics for type safety

### Unified Provider
- Evolves: Current registration patterns
- Integrates with: `di/registration.go`
- Uses: Generic wrapper type

### Test Builder
- New package: `gaztest/`
- Integrates with: App, Container
- Uses: Existing testify dependency

---

## Verification Checklist

- [x] Versions verified with Context7 and GitHub releases
- [x] Go standard library capabilities confirmed for each feature
- [x] No new external dependencies required
- [x] Existing dependencies are current
- [x] Integration points with existing code identified
- [x] fxtest pattern analyzed for TestBuilder design

---

## Sources

| Source | Type | Used For |
|--------|------|----------|
| Context7 `/golang/go` | HIGH | reflect, runtime, debug package APIs |
| Context7 `/uber-go/fx` | HIGH | fxtest API patterns for TestBuilder |
| Context7 `/stretchr/testify` | HIGH | require package verification |
| GitHub uber-go/fx releases | HIGH | v1.24.0 release notes (May 2025) |
| GitHub stretchr/testify releases | HIGH | v1.11.1 release notes (Aug 2025) |
| GitHub spf13/cobra releases | HIGH | v1.10.2 release notes (Dec 2025) |
| pkg.go.dev/go.uber.org/fx/fxtest | HIGH | fxtest API documentation |
| /home/coto/dev/petabyte/gaz/go.mod | HIGH | Current dependency versions |
