# Architecture Research: v2.0 Concurrency

**Researched:** 2026-01-27
**Focus:** Workers, Cron, EventBus integration with existing DI and lifecycle
**Confidence:** HIGH (verified with Context7 for uber-go/fx, robfig/cron, watermill)

## Executive Summary

The v2.0 concurrency features (workers, cron, eventbus) integrate naturally with gaz's existing architecture. The key insight is that gaz already has the infrastructure needed:

1. **Starter/Stopper interfaces** - Workers just implement these
2. **Lifecycle engine** - Handles dependency-ordered start/stop
3. **serviceWrapper** - Abstraction for any lifecycle-aware component
4. **Container** - DI for worker dependencies

The main work is creating new packages that leverage these primitives, not modifying core architecture.

## Integration Points

### Workers with Lifecycle

Workers integrate via the existing `Starter`/`Stopper` interfaces. This is the same pattern used by uber-go/fx.

**Current gaz interfaces (lifecycle.go:28-38):**
```go
type Starter interface {
    OnStart(context.Context) error
}

type Stopper interface {
    OnStop(context.Context) error
}
```

**Worker implementation pattern:**
```go
type Worker struct {
    // Dependencies injected via provider
    db     *sql.DB
    logger *slog.Logger
    
    // Lifecycle
    quit   chan struct{}
    done   chan struct{}
}

func (w *Worker) OnStart(ctx context.Context) error {
    w.logger.Info("starting worker")
    go w.run()  // Must spawn goroutine, not block
    return nil
}

func (w *Worker) OnStop(ctx context.Context) error {
    close(w.quit)
    select {
    case <-w.done:
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

**Key integration points:**
- `eagerSingleton.start()` calls `runStartLifecycle()` which detects `Starter` interface
- `eagerSingleton.stop()` calls `runStopLifecycle()` which detects `Stopper` interface
- Workers MUST be eager (instantiated at Build time) to participate in lifecycle
- Startup order respects dependencies via `ComputeStartupOrder()`

### Workers with DI

Workers receive dependencies through their provider functions, exactly like any other service.

**Registration pattern:**
```go
// In worker/module.go
func Module(c *gaz.Container) error {
    return gaz.For[*EmailWorker](c).
        OnStart(func(ctx context.Context, w *EmailWorker) error {
            return w.Start(ctx)
        }).
        OnStop(func(ctx context.Context, w *EmailWorker) error {
            return w.Stop(ctx)
        }).
        Eager().
        Provider(func(c *gaz.Container) (*EmailWorker, error) {
            db, _ := gaz.Resolve[*sql.DB](c)
            logger, _ := gaz.Resolve[*slog.Logger](c)
            return NewEmailWorker(db, logger), nil
        })
}
```

**Dependency flow:**
1. Worker depends on DB, Logger → recorded in dependencyGraph
2. At startup: DB starts first, then Logger, then Worker (topological order)
3. At shutdown: Worker stops first, then Logger, then DB (reverse order)

### Cron with Lifecycle

Cron scheduler follows the same pattern. The `robfig/cron` library has Start/Stop methods that map directly to Starter/Stopper.

**Integration approach:**
```go
type CronScheduler struct {
    cron   *cron.Cron
    logger *slog.Logger
}

func (s *CronScheduler) OnStart(ctx context.Context) error {
    s.cron.Start()  // Non-blocking, runs in background
    return nil
}

func (s *CronScheduler) OnStop(ctx context.Context) error {
    // cron.Stop() returns context when all jobs finish
    stopCtx := s.cron.Stop()
    select {
    case <-stopCtx.Done():
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

**Job registration pattern:**
Jobs can be registered before Start() via a builder pattern or after via AddFunc(). Recommend registration during provider construction.

### EventBus with DI

EventBus is a singleton service that other services depend on. Publishers and subscribers resolve it from the container.

**Integration approach (inspired by Watermill):**
```go
type EventBus struct {
    subscribers map[string][]Handler
    logger      *slog.Logger
    mu          sync.RWMutex
}

func (eb *EventBus) Publish(ctx context.Context, topic string, event any) error
func (eb *EventBus) Subscribe(topic string, handler Handler) Unsubscribe
```

**DI flow:**
```go
// EventBus registered as singleton
gaz.For[*EventBus](c).Provider(NewEventBus)

// Other services depend on it
gaz.For[*OrderService](c).Provider(func(c *gaz.Container) (*OrderService, error) {
    bus, _ := gaz.Resolve[*EventBus](c)
    return &OrderService{eventBus: bus}, nil
})
```

**Lifecycle considerations:**
- EventBus itself is stateless (no Start/Stop needed for in-memory version)
- Subscribers are registered during service construction
- Publishers call Publish() during normal operation
- On shutdown, services stop first, then EventBus (if it had cleanup)

## New Components

### Worker Package (`worker/`)

**Responsibilities:**
- Base `Worker` interface with Run()/Stop() pattern
- `WorkerManager` to track and manage multiple workers
- `WorkerGroup` for parallel worker coordination
- Health check integration

**Proposed structure:**
```
worker/
  worker.go      # Worker interface, base implementation
  manager.go     # WorkerManager service
  pool.go        # WorkerPool for queued tasks
  health.go      # Health check integration
  module.go      # Gaz module registration
```

**Key types:**
```go
// Worker is a long-running background task
type Worker interface {
    Run(ctx context.Context) error  // Blocks until done or context cancelled
}

// WorkerManager manages registered workers
type WorkerManager struct {
    workers []managedWorker
    logger  *slog.Logger
}

// Implements Starter/Stopper for gaz lifecycle
func (m *WorkerManager) OnStart(ctx context.Context) error
func (m *WorkerManager) OnStop(ctx context.Context) error
```

### WorkerPool Package (or part of `worker/`)

**Responsibilities:**
- Bounded worker pool for queued task processing
- Configurable concurrency
- Graceful shutdown (drain queue or cancel in-flight)

**Proposed types:**
```go
type Pool struct {
    workers  int
    queue    chan Task
    quit     chan struct{}
    wg       sync.WaitGroup
}

type Task func(ctx context.Context) error

func (p *Pool) Submit(task Task) error
func (p *Pool) OnStart(ctx context.Context) error
func (p *Pool) OnStop(ctx context.Context) error
```

### Cron Package (`cron/`)

**Responsibilities:**
- Wrap robfig/cron with gaz lifecycle integration
- Job registration API
- Health check integration

**Proposed structure:**
```
cron/
  scheduler.go   # Scheduler wrapper
  job.go         # Job interface and helpers
  module.go      # Gaz module registration
```

**Key types:**
```go
type Scheduler struct {
    cron   *cron.Cron
    logger *slog.Logger
}

// Registration pattern
func (s *Scheduler) AddFunc(spec string, cmd func()) error
func (s *Scheduler) AddJob(spec string, job cron.Job) error

// Lifecycle integration
func (s *Scheduler) OnStart(ctx context.Context) error
func (s *Scheduler) OnStop(ctx context.Context) error
```

### EventBus Package (`eventbus/`)

**Responsibilities:**
- Type-safe pub/sub for in-process events
- Synchronous delivery (subscriber errors propagate)
- Optional async mode

**Proposed structure:**
```
eventbus/
  bus.go         # Core EventBus implementation
  handler.go     # Handler types and helpers  
  module.go      # Gaz module registration
```

**Key types:**
```go
type Handler[T any] func(ctx context.Context, event T) error

type EventBus struct {
    handlers map[reflect.Type][]any
    mu       sync.RWMutex
    logger   *slog.Logger
}

func Publish[T any](ctx context.Context, bus *EventBus, event T) error
func Subscribe[T any](bus *EventBus, handler Handler[T]) func()
```

## Data Flow

### Worker Lifecycle Flow

```
App.Run()
    │
    ├─→ ComputeStartupOrder()           # Topological sort
    │       │
    │       └─→ [Layer 1: DB, Logger]   # Dependencies first
    │       └─→ [Layer 2: Services]
    │       └─→ [Layer 3: Workers]      # Workers last
    │
    ├─→ Start layers in order
    │       │
    │       └─→ WorkerManager.OnStart()
    │               │
    │               └─→ for each worker: go worker.Run(ctx)
    │
    ├─→ Wait for shutdown signal
    │
    └─→ ComputeShutdownOrder()          # Reverse of startup
            │
            └─→ [Layer 1: Workers]      # Stop workers first
            │       │
            │       └─→ WorkerManager.OnStop()
            │               │
            │               └─→ cancel worker contexts, wait
            │
            └─→ [Layer 2: Services]
            └─→ [Layer 3: DB, Logger]   # Dependencies last
```

### EventBus Data Flow

```
OrderService                    EventBus                    NotificationService
     │                             │                               │
     │  Publish(OrderCreated)      │                               │
     │────────────────────────────►│                               │
     │                             │  call handler(OrderCreated)   │
     │                             │──────────────────────────────►│
     │                             │                               │
     │                             │◄──────────────────────────────│
     │◄────────────────────────────│  return error (if any)        │
     │                             │                               │
```

### Cron Execution Flow

```
App.Run()
    │
    └─→ Scheduler.OnStart()
            │
            └─→ cron.Start()  # Background goroutine
                    │
                    │ (time passes)
                    │
                    └─→ trigger job at scheduled time
                            │
                            └─→ job.Run()  # In goroutine
                                    │
                                    └─→ (job has container dependencies)

App.Stop()
    │
    └─→ Scheduler.OnStop()
            │
            └─→ cron.Stop()   # Returns when jobs finish
```

## Build Order

Recommended implementation sequence based on dependencies:

### Phase 1: Base Worker Infrastructure

**Files:** `worker/worker.go`, `worker/manager.go`

1. Define `Worker` interface
2. Implement `WorkerManager` with Starter/Stopper
3. Add to lifecycle via module pattern

**Rationale:** Foundation for all background work. No external dependencies.

### Phase 2: Worker Pool

**Files:** `worker/pool.go`

1. Implement bounded task pool
2. Integrate with WorkerManager for lifecycle
3. Add queue draining on shutdown

**Rationale:** Builds on Phase 1 infrastructure.

### Phase 3: Cron Scheduler

**Files:** `cron/scheduler.go`, `cron/module.go`

1. Wrap `robfig/cron/v3`
2. Implement Starter/Stopper
3. Job registration API

**Rationale:** Independent of workers, can be done in parallel with Phase 2.

### Phase 4: EventBus

**Files:** `eventbus/bus.go`, `eventbus/module.go`

1. Core pub/sub implementation
2. Type-safe generics API
3. Sync and async modes

**Rationale:** Independent component. Can integrate with workers later.

### Phase 5: Integration & Health

**Files:** `worker/health.go`, `cron/health.go`

1. Health check integration for all components
2. Example applications
3. Documentation

**Rationale:** Polish after core functionality works.

## Patterns from Research

### uber-go/fx: Lifecycle Hooks Pattern

**Key insight:** Hooks schedule work, they don't block. Long-running work spawns goroutines.

```go
// From fx documentation:
// hooks **must not** block to run long-running tasks synchronously
// hooks **should** schedule long-running tasks in background goroutines
// shutdown hooks **should** stop the background work started by startup hooks
```

**Gaz equivalent:** Same principle. OnStart spawns goroutine, OnStop signals and waits.

### uber-go/fx: Group Pattern for Multiple Workers

**Key insight:** fx uses `group` tags to collect multiple providers into a slice.

**Gaz approach:** WorkerManager accepts workers via registration:
```go
manager.Register("email-worker", emailWorker)
manager.Register("cleanup-worker", cleanupWorker)
```

Or use a builder pattern:
```go
worker.NewManager().
    Add(emailWorker).
    Add(cleanupWorker).
    Build()
```

### robfig/cron: Graceful Shutdown Pattern

**Key insight:** `cron.Stop()` returns a context that completes when all running jobs finish.

```go
ctx := c.Stop()
<-ctx.Done()  // Wait for jobs
```

**Gaz integration:** OnStop waits with timeout:
```go
func (s *Scheduler) OnStop(ctx context.Context) error {
    stopCtx := s.cron.Stop()
    select {
    case <-stopCtx.Done():
        return nil
    case <-ctx.Done():
        return ctx.Err()  // Timeout exceeded
    }
}
```

### Watermill: Router Lifecycle Pattern

**Key insight:** Router.Run(ctx) blocks until context cancelled or error. Router.Close() for graceful shutdown.

**Gaz EventBus:** Simpler - no long-running process needed for in-memory pub/sub. Just thread-safe maps. Could add async worker mode later.

## Existing Architecture Leverage

### No Changes Needed

- **Container** - Works as-is for DI
- **Lifecycle engine** - `ComputeStartupOrder` handles new components
- **serviceWrapper** - Existing types sufficient
- **Starter/Stopper** - Perfect fit for all new components
- **App.Run/Stop** - Already calls lifecycle hooks correctly

### Minor Enhancements Possible

- **Health integration** - New components can register health checks
- **Logging** - Use existing logger from container
- **Config** - New components can implement ConfigProvider

## Confidence Assessment

| Component | Confidence | Basis |
|-----------|------------|-------|
| Worker integration | HIGH | Matches existing Starter/Stopper pattern, verified with fx docs |
| Cron integration | HIGH | robfig/cron has explicit Start/Stop, direct mapping |
| EventBus pattern | HIGH | Watermill patterns verified, simpler for in-memory |
| WorkerPool | MEDIUM | Standard pattern, but need to decide on queue behavior |
| Health integration | HIGH | Follows existing health/module.go pattern |

## Sources

- [uber-go/fx lifecycle docs](https://context7.com/uber-go/fx) - Verified via Context7
- [robfig/cron API](https://context7.com/robfig/cron) - Verified via Context7  
- [Watermill event patterns](https://context7.com/threedotslabs/watermill) - Verified via Context7
- gaz source: container.go, lifecycle.go, service.go, app.go, lifecycle_engine.go
- gaz patterns: health/module.go for module registration pattern
