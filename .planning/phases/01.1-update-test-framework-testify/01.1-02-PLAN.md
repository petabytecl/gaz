---
phase: 01.1-update-test-framework-testify
plan: 02
type: execute
wave: 2
depends_on: ["01.1-01"]
files_modified:
  - inject_test.go
  - resolution_test.go
autonomous: true

must_haves:
  truths:
    - "go test -run 'TestInjectionSuite|TestResolutionSuite' passes"
    - "inject_test.go uses InjectionSuite with suite.Suite"
    - "resolution_test.go uses ResolutionSuite with suite.Suite"
  artifacts:
    - path: "inject_test.go"
      contains: "suite.Suite"
      pattern: "func TestInjectionSuite.*suite.Run"
    - path: "resolution_test.go"
      contains: "suite.Suite"
      pattern: "func TestResolutionSuite.*suite.Run"
  key_links:
    - from: "inject_test.go"
      to: "github.com/stretchr/testify"
      via: "import statement"
    - from: "resolution_test.go"
      to: "github.com/stretchr/testify"
      via: "import statement"
---

<objective>
Migrate inject_test.go and resolution_test.go to testify suite pattern.

Purpose: Complete migration of the large test files that test injection and resolution functionality.
Output: inject_test.go with InjectionSuite, resolution_test.go with ResolutionSuite, all tests passing.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01.1-update-test-framework-testify/01.1-CONTEXT.md
@.planning/phases/01.1-update-test-framework-testify/01.1-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate inject_test.go to InjectionSuite</name>
  <files>inject_test.go</files>
  <action>
1. Create `type InjectionSuite struct { suite.Suite }`
2. Add `func TestInjectionSuite(t *testing.T) { suite.Run(t, new(InjectionSuite)) }`
3. Convert all TestInject_Xxx functions to suite methods `(s *InjectionSuite) TestXxx()`
4. Keep helper types (Database, Logger, Cache, Handler, DB, ServiceWithNamedDeps, etc.) at package level

**Assertion conversions:**
- `t.Fatal(err)` → `require.NoError(s.T(), err)`
- `t.Error("message")` → `assert.Fail(s.T(), "message")` or use specific assertion
- `if h.DB == nil { t.Error(...) }` → `require.NotNil(s.T(), h.DB)` (critical path) or `assert.NotNil(s.T(), h.DB)`
- `if h.DB != db { t.Error(...) }` → `assert.Same(s.T(), db, h.DB)` for pointer equality
- `if x.name != "expected" { t.Errorf(...) }` → `assert.Equal(s.T(), "expected", x.name)`
- `if !errors.Is(err, gaz.ErrXxx)` → `assert.ErrorIs(s.T(), err, gaz.ErrXxx)`

**Pattern for tests that set up and then verify:**
```go
func (s *InjectionSuite) TestBasicInjection() {
    c := New()
    
    db := &Database{connStr: "postgres://localhost"}
    require.NoError(s.T(), For[*Database](c).Instance(db))
    // ... more setup with require for critical path
    
    h, err := Resolve[*Handler](c)
    require.NoError(s.T(), err)
    
    assert.NotNil(s.T(), h.DB)
    assert.Same(s.T(), db, h.DB)
}
```

Use `require` for setup steps that must succeed for test to be valid.
Use `assert` for the actual verification assertions.
  </action>
  <verify>
Run `go test -v -run TestInjectionSuite ./...` — all tests pass
  </verify>
  <done>
inject_test.go uses InjectionSuite, all injection tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate resolution_test.go to ResolutionSuite</name>
  <files>resolution_test.go</files>
  <action>
1. Create `type ResolutionSuite struct { suite.Suite }`
2. Add `func TestResolutionSuite(t *testing.T) { suite.Run(t, new(ResolutionSuite)) }`
3. Convert all test functions to suite methods

**Assertion conversions (same patterns as inject_test.go):**
- `t.Fatal(err)` / `t.Fatalf(...)` → `require.NoError(s.T(), err)` / `require.Xxx(...)`
- `t.Error(...)` / `t.Errorf(...)` → `assert.Xxx(s.T(), ...)`
- Pointer equality: `assert.Same(s.T(), expected, actual)`
- Error type checks: `assert.ErrorIs(s.T(), err, expectedErr)`
- String contains: `assert.Contains(s.T(), str, substring)`
- For concurrent tests: keep sync.WaitGroup patterns, just update assertions

**Note:** If resolution_test.go is package `gaz_test` (external test package), maintain that — suite pattern works the same way, just references `gaz.Xxx` instead of `Xxx`.

Keep any table-driven test structures, convert assertions within the loop.
  </action>
  <verify>
Run `go test -v -run TestResolutionSuite ./...` — all tests pass
  </verify>
  <done>
resolution_test.go uses ResolutionSuite, all resolution tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Both suites pass
go test -v -run "TestInjectionSuite|TestResolutionSuite" ./...

# No stdlib assertion patterns remain
grep -E "t\.Error|t\.Fatal|if .+ != .+ \{" inject_test.go resolution_test.go || echo "Clean"
```
</verification>

<success_criteria>
- inject_test.go uses InjectionSuite with all tests passing
- resolution_test.go uses ResolutionSuite with all tests passing
- No stdlib t.Error/t.Fatal patterns remain in migrated files
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-update-test-framework-testify/01.1-02-SUMMARY.md`
</output>
