---
phase: 01.1-update-test-framework-testify
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - types_test.go
  - registration_test.go
  - service_test.go
autonomous: true

must_haves:
  truths:
    - "go test ./... passes after migration"
    - "types_test.go uses TypesSuite with suite.Suite"
    - "registration_test.go uses RegistrationSuite with suite.Suite"
    - "service_test.go uses ServiceSuite with suite.Suite"
  artifacts:
    - path: "go.mod"
      contains: "github.com/stretchr/testify"
    - path: "types_test.go"
      contains: "suite.Suite"
      pattern: "func TestTypesSuite.*suite.Run"
    - path: "registration_test.go"
      contains: "suite.Suite"
      pattern: "func TestRegistrationSuite.*suite.Run"
    - path: "service_test.go"
      contains: "suite.Suite"
      pattern: "func TestServiceSuite.*suite.Run"
  key_links:
    - from: "*_test.go"
      to: "github.com/stretchr/testify"
      via: "import statement"
---

<objective>
Install testify and migrate the 3 smaller test files to use testify suite pattern.

Purpose: Establish testify as the test framework and validate the migration pattern works on smaller files before tackling larger ones.
Output: testify dependency added, types_test.go, registration_test.go, and service_test.go migrated to suite pattern.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01.1-update-test-framework-testify/01.1-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add testify dependency and migrate types_test.go</name>
  <files>go.mod, go.sum, types_test.go</files>
  <action>
1. Run `go get github.com/stretchr/testify` to add the dependency

2. Migrate types_test.go to use testify suite pattern:
   - Create `type TypesSuite struct { suite.Suite }`
   - Add `func TestTypesSuite(t *testing.T) { suite.Run(t, new(TypesSuite)) }`
   - Convert each TestXxx function to suite method `(s *TypesSuite) TestXxx()`
   - Replace `t` with `s.T()` where needed
   - Replace `t.Run(name, func(t *testing.T) {...})` with `s.Run(name, func() {...})`
   - Replace `if got != expected { t.Errorf(...) }` with `assert.Equal(s.T(), expected, got)`
   - Import both "github.com/stretchr/testify/assert" and "github.com/stretchr/testify/suite"
   - Standard import grouping: stdlib, external, local

Pattern for table-driven tests:
```go
for _, tt := range tests {
    s.Run(tt.name, func() {
        assert.Equal(s.T(), tt.expected, tt.got)
    })
}
```
  </action>
  <verify>
Run `go test -v -run TestTypesSuite ./...` — all tests pass
  </verify>
  <done>
testify in go.mod, types_test.go has TypesSuite with all tests passing
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate registration_test.go and service_test.go</name>
  <files>registration_test.go, service_test.go</files>
  <action>
**registration_test.go:**
1. Create `type RegistrationSuite struct { suite.Suite }`
2. Add SetupTest() to create fresh Container if tests need it (check if tests create their own Container — if they each create their own `c := gaz.New()`, SetupTest may not be needed)
3. Add `func TestRegistrationSuite(t *testing.T) { suite.Run(t, new(RegistrationSuite)) }`
4. Convert all TestFor_Xxx functions to suite methods
5. Replace assertions:
   - `if err != nil { t.Errorf(...) }` → `assert.NoError(s.T(), err)` or `require.NoError(s.T(), err)` for critical path
   - `t.Fatalf(...)` (fatal/critical) → `require.NoError(s.T(), err)` or `require.NotNil(...)`
   - `if !errors.Is(err, gaz.ErrDuplicate)` → `assert.ErrorIs(s.T(), err, gaz.ErrDuplicate)`
6. Import: "github.com/stretchr/testify/assert", "github.com/stretchr/testify/require", "github.com/stretchr/testify/suite"

**service_test.go:**
1. Create `type ServiceSuite struct { suite.Suite }`
2. Add `func TestServiceSuite(t *testing.T) { suite.Run(t, new(ServiceSuite)) }`
3. Convert all test functions to suite methods
4. Replace assertions same pattern as above:
   - `t.Fatalf(...)` → `require.NoError(s.T(), err)` or `require.Xxx(...)`
   - `t.Errorf(...)` → `assert.Xxx(s.T(), ...)`
   - `t.Error("message")` → `assert.Fail(s.T(), "message")` or `assert.True(s.T(), condition, "message")`
   - For pointer equality checks: `assert.Same(s.T(), expected, actual)`
   - For table-driven tests: keep table structure, use s.Run() for subtests
5. Keep helper types (testService) at package level

Use require for assertions that would make further testing meaningless (e.g., error checks before using the result).
Use assert for value comparisons that don't block other checks.
  </action>
  <verify>
Run `go test -v -run "TestRegistrationSuite|TestServiceSuite" ./...` — all tests pass
  </verify>
  <done>
Both files migrated to suite pattern, all tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# All migrated tests pass
go test -v -run "TestTypesSuite|TestRegistrationSuite|TestServiceSuite" ./...

# No stdlib assertion patterns remain in migrated files
grep -E "t\.Error|t\.Fatal|if .+ != .+ \{" types_test.go registration_test.go service_test.go || echo "Clean"

# testify imported correctly
grep "testify" go.mod
```
</verification>

<success_criteria>
- testify dependency in go.mod
- types_test.go, registration_test.go, service_test.go all use suite.Suite pattern
- All tests pass (`go test ./...`)
- No stdlib t.Error/t.Fatal patterns in migrated files
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-update-test-framework-testify/01.1-01-SUMMARY.md`
</output>
