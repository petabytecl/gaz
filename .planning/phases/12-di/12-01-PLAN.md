---
phase: 12-di
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - di/container.go
  - di/registration.go
  - di/resolution.go
  - di/service.go
  - di/errors.go
  - di/options.go
  - di/lifecycle.go
  - di/lifecycle_engine.go
  - di/inject.go
  - di/types.go
  - di/doc.go
autonomous: true

must_haves:
  truths:
    - "di package exists as standalone subpackage"
    - "di.New() creates a container without requiring gaz.App"
    - "di.For[T]() registers services in the container"
    - "di.Resolve[T]() resolves services from the container"
    - "All DI types compile without import cycles"
  artifacts:
    - path: "di/service.go"
      provides: "Service wrapper types and ServiceWrapper interface"
      exports: ["ServiceWrapper", "newLazySingleton", "newTransient", "newEagerSingleton", "newInstanceService", "newInstanceServiceAny"]
    - path: "di/container.go"
      provides: "Container with accessor methods"
      exports: ["Container", "New", "ForEachService", "GetService"]
    - path: "di/registration.go"
      provides: "For[T]() fluent registration builder"
      exports: ["For", "RegistrationBuilder"]
    - path: "di/resolution.go"
      provides: "Resolve[T]() function"
      exports: ["Resolve"]
    - path: "di/errors.go"
      provides: "DI-specific errors with di: prefix"
      exports: ["ErrNotFound", "ErrCycle", "ErrDuplicate", "ErrNotSettable", "ErrTypeMismatch", "ErrAlreadyBuilt", "ErrInvalidProvider"]
    - path: "di/lifecycle.go"
      provides: "Starter and Stopper interfaces"
      exports: ["Starter", "Stopper", "HookFunc", "HookConfig", "HookOption", "WithHookTimeout"]
  key_links:
    - from: "di/registration.go"
      to: "di/container.go"
      via: "For[T]() takes *Container"
      pattern: "For\\[T any\\]\\(c \\*Container\\)"
    - from: "di/resolution.go"
      to: "di/container.go"
      via: "Resolve[T]() takes *Container"
      pattern: "Resolve\\[T any\\]\\(c \\*Container"
    - from: "di/service.go"
      to: "di/container.go"
      via: "serviceWrapper.getInstance takes *Container"
      pattern: "getInstance\\(c \\*Container"
---

<objective>
Create the `gaz/di` subpackage with all core DI functionality extracted from the root gaz package.

Purpose: Enable standalone DI usage without requiring the full gaz framework, fulfilling DI-08 requirement.
Output: Complete `di/` package with Container, For[T](), Resolve[T](), errors, lifecycle interfaces, and all supporting code.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-di/12-CONTEXT.md
@.planning/phases/12-di/12-RESEARCH.md

# Source files to move
@container.go
@registration.go
@resolution.go
@service.go
@errors.go
@options.go
@lifecycle.go
@lifecycle_engine.go
@inject.go
@types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create di package core files</name>
  <files>
    di/container.go
    di/registration.go
    di/resolution.go
    di/service.go
    di/types.go
    di/inject.go
  </files>
  <action>
Create the `di/` directory and move core DI files:

1. **di/container.go** - Copy from `container.go`:
   - Change package to `di`
   - Rename `NewContainer()` to `New()` (idiomatic Go constructor)
   - Keep all Container methods (register, hasService, getChain, pushChain, popChain, Build, resolveByName, recordDependency, getGraph)
   - Keep getGoroutineID helper

2. **di/container.go** - Also add accessor methods for App lifecycle management:
   - `ForEachService(fn func(name string, svc any))` - Iterates over all registered services
   - `GetService(name string) (any, bool)` - Returns a service wrapper by name
   These are required because `services` field is private; App needs controlled access.

3. **di/registration.go** - Copy from `registration.go`:
   - Change package to `di`
   - Update all references from `gaz.Container` to `Container` (local package)
   - Keep For[T](), RegistrationBuilder, all methods (Named, Transient, Eager, Replace, OnStart, OnStop, Provider, ProviderFunc, Instance)
   - Keep serviceScope type (internal)

3. **di/resolution.go** - Copy from `resolution.go`:
   - Change package to `di`
   - Keep Resolve[T]() function

4. **di/service.go** - Copy from `service.go`:
   - Change package to `di`
   - Keep all service wrapper types: baseService, lazySingleton, transientService, eagerSingleton, instanceService, instanceServiceAny
   - Keep all constructor functions (newLazySingleton, newTransient, etc.)
   - **Export ServiceWrapper interface** (capitalize methods for App access):
     ```go
     // ServiceWrapper is the interface for service lifecycle management.
     // Exported for use by gaz.App.
     type ServiceWrapper interface {
         Name() string
         TypeName() string
         IsEager() bool
         IsTransient() bool
         GetInstance(c *Container, chain []string) (any, error)
         Start(context.Context) error
         Stop(context.Context) error
         HasLifecycle() bool
     }
     ```
   - Update all wrapper types to use capitalized method names

5. **di/types.go** - Copy from `types.go`:
   - Change package to `di`
   - Keep TypeName[T]() and typeName() helper

6. **di/inject.go** - Copy from `inject.go`:
   - Change package to `di`
   - Keep tagOptions, parseTag, injectStruct
   - Update error references to use local package errors

Ensure no import cycles: di package must NOT import parent gaz package.
  </action>
  <verify>
    - `ls di/*.go` shows 6 files created
    - `grep "func (c \*Container) ForEachService" di/container.go` finds accessor
    - `grep "func (c \*Container) GetService" di/container.go` finds accessor
    - `grep "type ServiceWrapper interface" di/service.go` finds exported interface
    - `go build ./di` compiles without errors
  </verify>
  <done>
Core DI files exist in di/ package and compile successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create di package support files</name>
  <files>
    di/errors.go
    di/options.go
    di/lifecycle.go
    di/lifecycle_engine.go
    di/doc.go
  </files>
  <action>
Create remaining di package files:

1. **di/errors.go** - Copy from `errors.go` but ONLY DI-related errors:
   - Change package to `di`
   - Update error prefix from "gaz:" to "di:"
   - Include: ErrNotFound, ErrCycle, ErrDuplicate, ErrNotSettable, ErrTypeMismatch, ErrAlreadyBuilt, ErrInvalidProvider
   - EXCLUDE config/module errors: ErrDuplicateModule, ErrConfigKeyCollision, ErrConfigValidation (these stay in root gaz)

2. **di/options.go** - Copy ONLY resolve options from `options.go`:
   - Change package to `di`
   - Include: ResolveOption, resolveOptions, Named(), applyOptions()
   - EXCLUDE config options (WithName, WithType, WithEnvPrefix, etc.) - these stay in root gaz

3. **di/lifecycle.go** - Copy from `lifecycle.go`:
   - Change package to `di`
   - Include: HookFunc, HookConfig, HookOption, WithHookTimeout, Starter, Stopper interfaces

4. **di/lifecycle_engine.go** - Copy from `lifecycle_engine.go`:
   - Change package to `di`
   - Keep ComputeStartupOrder, ComputeShutdownOrder
   - Update serviceWrapper reference (it's now local to di package)

5. **di/doc.go** - Create new package documentation:
```go
// Package di provides a lightweight, type-safe dependency injection container.
//
// The di package can be used standalone without the gaz framework,
// or as part of gaz.App for full application lifecycle management.
//
// # Quick Start
//
// Create a container, register services, and resolve them:
//
//	c := di.New()
//
//	di.For[*Database](c).Provider(func(c *di.Container) (*Database, error) {
//	    return NewDatabase("postgres://...")
//	})
//
//	if err := c.Build(); err != nil {
//	    log.Fatal(err)
//	}
//
//	db, err := di.Resolve[*Database](c)
//
// # Registration Patterns
//
// Services can be registered as singletons (default), transient, or eager:
//
//	di.For[*Config](c).Instance(cfg)                // Pre-built instance
//	di.For[*Service](c).Provider(NewService)        // Lazy singleton (default)
//	di.For[*Pool](c).Eager().Provider(NewPool)      // Eager singleton
//	di.For[*Request](c).Transient().Provider(fn)    // New instance each time
//
// # Named Services
//
// Multiple services of the same type can be registered with different names:
//
//	di.For[*sql.DB](c).Named("primary").Provider(NewPrimaryDB)
//	di.For[*sql.DB](c).Named("replica").Provider(NewReplicaDB)
//	primary, _ := di.Resolve[*sql.DB](c, di.Named("primary"))
//
// # Lifecycle Hooks
//
// Services can implement Starter/Stopper interfaces or use OnStart/OnStop:
//
//	di.For[*Server](c).OnStart(func(ctx context.Context, s *Server) error {
//	    return s.ListenAndServe()
//	}).Provider(NewServer)
package di
```
  </action>
  <verify>
    - `ls di/*.go` shows 11 total files
    - `go build ./di` compiles without errors
    - No import cycles detected
  </verify>
  <done>
Complete di package created with all DI functionality extracted and proper documentation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add MustResolve and test helpers</name>
  <files>
    di/resolution.go
    di/testing.go
  </files>
  <action>
Add new APIs requested in CONTEXT.md:

1. **di/resolution.go** - Add MustResolve[T]() after Resolve[T]():
```go
// MustResolve resolves a service or panics if resolution fails.
// Use only in test setup or main() initialization where failure is fatal.
//
// Example:
//
//	func TestSomething(t *testing.T) {
//	    c := di.NewTestContainer()
//	    di.For[*MockDB](c).Instance(&MockDB{})
//	    db := di.MustResolve[*MockDB](c) // panics if not found
//	}
func MustResolve[T any](c *Container, opts ...ResolveOption) T {
    result, err := Resolve[T](c, opts...)
    if err != nil {
        panic(fmt.Sprintf("di.MustResolve[%s]: %v", TypeName[T](), err))
    }
    return result
}
```

2. **di/testing.go** - Create test helper file:
```go
package di

// NewTestContainer creates a container suitable for testing.
// It's functionally identical to New() but named for clarity in test code.
//
// Example:
//
//	func TestUserService(t *testing.T) {
//	    c := di.NewTestContainer()
//	    di.For[Database](c).Instance(&MockDatabase{})
//	    di.For[*UserService](c).Provider(NewUserService)
//	    svc := di.MustResolve[*UserService](c)
//	    // ... test assertions
//	}
func NewTestContainer() *Container {
    return New()
}
```
  </action>
  <verify>
    - `grep -l "MustResolve" di/resolution.go` finds the function
    - `go build ./di` compiles without errors
  </verify>
  <done>
MustResolve[T]() and NewTestContainer() added to di package.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification: `go build ./di` succeeds
2. Package structure: `ls di/` shows all 12 files:
   - container.go, registration.go, resolution.go, service.go
   - errors.go, options.go, lifecycle.go, lifecycle_engine.go
   - inject.go, types.go, doc.go, testing.go
3. No import cycles: `go list -f '{{.Imports}}' ./di` shows no gaz imports
4. New APIs present:
   - `grep "func New()" di/container.go`
   - `grep "func MustResolve" di/resolution.go`
   - `grep "func NewTestContainer" di/testing.go`
</verification>

<success_criteria>
- di package compiles as standalone package
- di.New() returns *Container
- di.For[T]() returns *RegistrationBuilder[T]
- di.Resolve[T]() returns (T, error)
- di.MustResolve[T]() returns T (panics on error)
- di.NewTestContainer() returns *Container
- No imports from parent gaz package
</success_criteria>

<output>
After completion, create `.planning/phases/12-di/12-01-SUMMARY.md`
</output>
