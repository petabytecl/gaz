---
phase: 12-di
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - di/container.go
  - compat.go
  - errors.go
  - options.go
  - lifecycle.go
  - lifecycle_engine.go
  - inject.go
  - types.go
autonomous: true

must_haves:
  truths:
    - "Root gaz package re-exports DI types for backward compatibility"
    - "Existing gaz.For[T]() calls continue to work unchanged"
    - "Existing gaz.Resolve[T]() calls continue to work unchanged"
    - "gaz.Container is usable interchangeably with di.Container"
    - "Container introspection methods available"
  artifacts:
    - path: "compat.go"
      provides: "Backward compatibility re-exports and wrappers"
      exports: ["Container", "For", "Resolve", "MustResolve"]
    - path: "di/container.go"
      provides: "Container introspection methods"
      exports: ["List", "Has"]
  key_links:
    - from: "compat.go"
      to: "di/container.go"
      via: "import and type alias"
      pattern: "import.*github.com/petabytecl/gaz/di"
    - from: "gaz.For[T]"
      to: "di.For[T]"
      via: "function wrapper"
      pattern: "return di\\.For\\[T\\]"
---

<objective>
Add container introspection methods and create backward compatibility layer in root gaz package.

Purpose: Fulfill DI-09 requirement (backward compatibility) and add introspection APIs (List, Has) as specified in CONTEXT.md.
Output: Root gaz package maintains full backward compatibility; existing code works unchanged.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-di/12-CONTEXT.md
@.planning/phases/12-di/12-RESEARCH.md

# Reference Plan 1 output
@di/container.go
@di/registration.go
@di/resolution.go

# Root package files that need updating
@errors.go
@options.go
@lifecycle.go
@lifecycle_engine.go
@inject.go
@types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add introspection methods to di.Container</name>
  <files>di/container.go</files>
  <action>
Add introspection methods to Container in di/container.go:

After the `getGraph()` method, add:

```go
// List returns the names of all registered services.
// Names are returned in sorted order for deterministic output.
//
// Example:
//
//	for _, name := range c.List() {
//	    fmt.Println("Registered:", name)
//	}
func (c *Container) List() []string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    names := make([]string, 0, len(c.services))
    for name := range c.services {
        names = append(names, name)
    }
    sort.Strings(names)
    return names
}

// Has returns true if a service of type T is registered in the container.
//
// Example:
//
//	if di.Has[*Database](c) {
//	    db, _ := di.Resolve[*Database](c)
//	}
func Has[T any](c *Container) bool {
    return c.hasService(TypeName[T]())
}
```

Ensure `"sort"` is in the imports.
  </action>
  <verify>
    - `grep "func (c \*Container) List()" di/container.go` finds the method
    - `grep "func Has\[T any\]" di/container.go` finds the function
    - `go build ./di` compiles
  </verify>
  <done>
Container introspection methods List() and Has[T]() added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backward compatibility wrapper</name>
  <files>compat.go</files>
  <action>
Create `compat.go` in the root gaz package:

```go
package gaz

import (
    "github.com/petabytecl/gaz/di"
)

// =============================================================================
// Backward Compatibility Layer
// Re-exports DI types so existing gaz code continues to work unchanged.
// =============================================================================

// Container is a type alias for di.Container.
// Use di.Container directly for new code.
type Container = di.Container

// NewContainer creates a new empty Container.
// Deprecated: Use di.New() for standalone DI usage.
func NewContainer() *Container {
    return di.New()
}

// For returns a registration builder for type T.
// This wraps di.For[T] for backward compatibility with gaz.For[T].
//
// Example:
//
//	gaz.For[*MyService](c).Provider(NewMyService)
func For[T any](c *Container) *di.RegistrationBuilder[T] {
    return di.For[T](c)
}

// Resolve retrieves a service of type T from the container.
// This wraps di.Resolve[T] for backward compatibility.
func Resolve[T any](c *Container, opts ...di.ResolveOption) (T, error) {
    return di.Resolve[T](c, opts...)
}

// MustResolve resolves a service or panics if resolution fails.
// This wraps di.MustResolve[T] for backward compatibility.
func MustResolve[T any](c *Container, opts ...di.ResolveOption) T {
    return di.MustResolve[T](c, opts...)
}

// Has returns true if a service of type T is registered.
// This wraps di.Has[T] for backward compatibility.
func Has[T any](c *Container) bool {
    return di.Has[T](c)
}

// TypeName returns the fully-qualified type name for T.
// This wraps di.TypeName[T] for backward compatibility.
func TypeName[T any]() string {
    return di.TypeName[T]()
}

// Named resolves a service by its registered name instead of type.
// This wraps di.Named for backward compatibility.
func Named(name string) di.ResolveOption {
    return di.Named(name)
}

// =============================================================================
// Re-exported Types
// =============================================================================

// ResolveOption modifies resolution behavior.
type ResolveOption = di.ResolveOption

// RegistrationBuilder provides a fluent API for configuring services.
type RegistrationBuilder[T any] = di.RegistrationBuilder[T]
```
  </action>
  <verify>
    - `go build ./...` compiles (tests may fail, that's expected before Plan 3)
  </verify>
  <done>
Backward compatibility wrapper compat.go created with all DI re-exports.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update root package to use di imports</name>
  <files>
    errors.go
    options.go
    lifecycle.go
    lifecycle_engine.go
    inject.go
    types.go
  </files>
  <action>
Modify root gaz package files to import from di and re-export or delegate:

1. **errors.go** - Keep only non-DI errors, re-export DI errors:
```go
package gaz

import (
    "github.com/petabytecl/gaz/di"
)

// DI errors - re-exported from di package
var (
    ErrNotFound        = di.ErrNotFound
    ErrCycle           = di.ErrCycle
    ErrDuplicate       = di.ErrDuplicate
    ErrNotSettable     = di.ErrNotSettable
    ErrTypeMismatch    = di.ErrTypeMismatch
    ErrAlreadyBuilt    = di.ErrAlreadyBuilt
    ErrInvalidProvider = di.ErrInvalidProvider
)

// App-specific errors (not part of di package)
var (
    ErrDuplicateModule    = errors.New("gaz: duplicate module name")
    ErrConfigKeyCollision = errors.New("gaz: config key collision")
    ErrConfigValidation   = errors.New("gaz: config validation failed")
)
```

2. **options.go** - Keep only config options, remove DI options (now in compat.go):
   - Remove: ResolveOption, resolveOptions, Named, applyOptions (handled via di import in compat.go)
   - Keep: ConfigOption, WithName, WithType, WithEnvPrefix, WithSearchPaths, WithProfileEnv, WithDefaults

3. **lifecycle.go** - Re-export from di:
```go
package gaz

import (
    "github.com/petabytecl/gaz/di"
)

// Re-export lifecycle types from di package
type (
    HookFunc   = di.HookFunc
    HookConfig = di.HookConfig
    HookOption = di.HookOption
    Starter    = di.Starter
    Stopper    = di.Stopper
)

// WithHookTimeout sets a custom timeout for this specific hook.
var WithHookTimeout = di.WithHookTimeout
```

4. **lifecycle_engine.go** - Re-export from di:
```go
package gaz

import (
    "github.com/petabytecl/gaz/di"
)

// ComputeStartupOrder calculates service startup order.
// Re-exported from di package for backward compatibility.
var ComputeStartupOrder = di.ComputeStartupOrder

// ComputeShutdownOrder reverses startup order for shutdown.
// Re-exported from di package for backward compatibility.
var ComputeShutdownOrder = di.ComputeShutdownOrder
```

5. **inject.go** - This file can be deleted entirely (functionality moved to di/inject.go).
   The root package no longer needs direct inject functionality.

6. **types.go** - This file can be deleted entirely (functionality moved to di/types.go and re-exported via compat.go).

Note: container.go, registration.go, resolution.go, service.go will be handled in Plan 3 (they need to stay temporarily for tests).
  </action>
  <verify>
    - `go build .` compiles (root gaz package)
    - `go build ./di` compiles (di package)
  </verify>
  <done>
Root package updated to re-export DI types from di package.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Both packages compile: `go build ./... 2>&1 | head -20`
2. Backward compat exports present:
   - `grep "type Container = di.Container" compat.go`
   - `grep "func For\[T any\]" compat.go`
   - `grep "ErrNotFound = di.ErrNotFound" errors.go`
3. Introspection APIs present:
   - `grep "func (c \*Container) List()" di/container.go`
   - `grep "func Has\[T any\]" di/container.go`
</verification>

<success_criteria>
- di.Container has List() and Has[T]() methods
- gaz.Container is alias to di.Container
- gaz.For[T]() wraps di.For[T]()
- gaz.Resolve[T]() wraps di.Resolve[T]()
- gaz.MustResolve[T]() wraps di.MustResolve[T]()
- gaz.Named() wraps di.Named()
- gaz errors re-export di errors
- Both packages compile
</success_criteria>

<output>
After completion, create `.planning/phases/12-di/12-02-SUMMARY.md`
</output>
