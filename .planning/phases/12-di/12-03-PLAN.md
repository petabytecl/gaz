---
phase: 12-di
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - app.go
  - container.go
  - registration.go
  - resolution.go
  - service.go
  - container_test.go
  - container_graph_test.go
  - registration_test.go
  - resolution_test.go
  - inject_test.go
  - lifecycle_test.go
  - lifecycle_engine_test.go
  - service_test.go
  - types_test.go
  - di/container_test.go
  - di/registration_test.go
  - di/resolution_test.go
autonomous: true

must_haves:
  truths:
    - "All existing tests pass with updated imports"
    - "app.go uses di.Container internally"
    - "Original root package files removed (container.go, registration.go, etc.)"
    - "di package has its own test coverage"
    - "Full test suite passes: go test ./..."
  artifacts:
    - path: "di/container_test.go"
      provides: "Test coverage for di.Container"
      contains: "TestNew"
    - path: "app.go"
      provides: "App using di.Container"
      contains: "di.New()"
  key_links:
    - from: "app.go"
      to: "di/container.go"
      via: "container creation"
      pattern: "di\\.New\\(\\)"
    - from: "di/container_test.go"
      to: "di/container.go"
      via: "test imports"
      pattern: "package di"
---

<objective>
Update App to use di.Container internally, remove redundant root package files, update all tests to work with extracted di package.

Purpose: Complete the DI extraction by removing duplicated code and ensuring all tests pass.
Output: Clean codebase with di package as the source of truth, full test coverage passing.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-di/12-CONTEXT.md
@.planning/phases/12-di/12-RESEARCH.md

# Plan 1 & 2 outputs
@di/container.go
@di/registration.go
@di/resolution.go
@compat.go

# Files to update
@app.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update App to use di.Container</name>
  <files>app.go</files>
  <action>
Update app.go to use di package internally:

1. Add import: `"github.com/petabytecl/gaz/di"`

2. Update New() function:
   - Change `container: NewContainer()` to `container: di.New()`

3. Update Container() method return type annotation in comments to reference di.Container

4. Update any internal calls that reference Container methods:
   - The Container field is already `*Container` which is now aliased to `*di.Container` via compat.go
   - Internal methods like `a.container.hasService()`, `a.container.register()` work unchanged
   - `a.container.Build()` works unchanged
   - `a.container.getGraph()` works unchanged

5. Update registerInstance() to use di types:
   - Use `di.TypeName` for type name reflection (or keep using typeName since it's re-exported)
   - The newInstanceServiceAny call needs to reference di package

Key changes in New():
```go
func New(opts ...Option) *App {
    app := &App{
        container: di.New(),  // Changed from NewContainer()
        opts: AppOptions{
            ShutdownTimeout: defaultShutdownTimeout,
            PerHookTimeout:  defaultPerHookTimeout,
        },
        modules: make(map[string]bool),
    }
    // ... rest unchanged
}
```

Note: registerInstance() uses newInstanceServiceAny which is internal to di package.
Need to either:
a) Export it from di package as NewInstanceServiceAny, or
b) Use a different approach - register via For[T]() with reflection wrapper

Since CONTEXT.md says "registerInstance() and instanceServiceAny retained for internal use", we should:
- Keep instanceServiceAny in root gaz package for App's internal use, OR
- Add an internal/exported helper in di package

Recommendation: Keep service.go in root gaz with ONLY instanceServiceAny (the internal helper).
Remove all other service wrapper types (they're now in di/service.go).

Update service.go to:
```go
package gaz

import (
    "context"
    "github.com/petabytecl/gaz/di"
)

// instanceServiceAny is retained for internal use by App.registerInstance()
// and App.WithConfig() runtime type registration.
type instanceServiceAny struct {
    // ... keep existing implementation
}
```

This avoids export of internal types while keeping App functionality.
  </action>
  <verify>
    - `grep "di.New()" app.go` finds the updated constructor
    - `go build .` compiles
  </verify>
  <done>
App updated to use di.New() for container creation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove redundant root package files</name>
  <files>
    container.go
    registration.go
    resolution.go
  </files>
  <action>
Remove files that are now duplicated (functionality moved to di/):

1. **Delete container.go** - Functionality now in di/container.go
   - `rm container.go`

2. **Delete registration.go** - Functionality now in di/registration.go
   - `rm registration.go`

3. **Delete resolution.go** - Functionality now in di/resolution.go
   - `rm resolution.go`

4. **Update service.go** - Keep ONLY instanceServiceAny for internal use:
   - Remove: serviceWrapper interface, baseService, lazySingleton, transientService, eagerSingleton, instanceService
   - Keep: instanceServiceAny, newInstanceServiceAny
   - Add import for di package to use di.Starter, di.Stopper in lifecycle methods
   - Update any references to use di package types

The serviceWrapper interface needs special handling:
- di/service.go defines serviceWrapper as internal interface
- app.go needs to work with serviceWrapper for lifecycle management
- Solution: di package exports serviceWrapper methods via Container methods

Actually, looking at app.go more carefully:
- It accesses `a.container.services` directly for iteration
- It casts to `serviceWrapper` for lifecycle calls
- It uses `wrapper.start()`, `wrapper.stop()`, `wrapper.isTransient()`, `wrapper.hasLifecycle()`

This needs a cleaner interface. Options:
a) Export serviceWrapper from di (undesirable - internal detail)
b) Add Container methods for lifecycle management (better encapsulation)
c) Keep serviceWrapper interface in root gaz and have di embed it (import cycle risk)

Best approach: Add helper methods to di.Container for lifecycle operations that App needs:
- `c.StartServices(ctx, order)` 
- `c.StopServices(ctx, order)`
- `c.GetServiceWrappers() map[string]any` (returns map for App to iterate)

OR simpler: Keep the service wrapper interface definition in both packages (duplication but avoids cycles).

For now, simplest path forward:
- Keep a minimal serviceWrapper interface in root gaz package
- Have di.Container.services hold values that implement this interface
- Since di.Container is the same as gaz.Container (type alias), this works

Actually, the cleanest solution is:
1. Keep service.go in root package with serviceWrapper interface + instanceServiceAny only
2. di package service wrappers are internal but implement same interface
3. App can type-assert values from di.Container.services to gaz.serviceWrapper

Wait - but di.Container.services is internal (lowercase). App accesses it via:
```go
a.container.mu.RLock()
for k, v := range a.container.services {
```

This is direct field access. With type alias, this still works because Container = di.Container.
But di.Container's services field is lowercase, so it's only accessible within di package.

This is a problem. We need to either:
1. Export the services field (bad)
2. Add accessor methods to di.Container that App can use
3. Keep container.go in root package (defeats purpose)

Best solution: Add methods to di.Container:
```go
// ForEachService iterates over all registered services.
// The callback receives the service name and wrapper.
// This is used internally by gaz.App for lifecycle management.
func (c *Container) ForEachService(fn func(name string, svc any)) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    for name, svc := range c.services {
        fn(name, svc)
    }
}

// GetService returns a service wrapper by name for internal use.
func (c *Container) GetService(name string) (any, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    svc, ok := c.services[name]
    return svc, ok
}
```

Then App uses these methods instead of direct field access.

Also, serviceWrapper interface should be exported from di (as internal detail for App):
```go
// ServiceWrapper is the internal interface for service types.
// Exported for use by gaz.App lifecycle management.
type ServiceWrapper interface {
    Name() string          // was name()
    TypeName() string      // was typeName()
    IsEager() bool         // was isEager()
    IsTransient() bool     // was isTransient()
    GetInstance(c *Container, chain []string) (any, error)  // was getInstance
    Start(context.Context) error
    Stop(context.Context) error
    HasLifecycle() bool
}
```

Wait, that changes the interface. Let's be more careful.

Simplest approach for this plan:
1. Keep container.go, registration.go, resolution.go, service.go in root package
2. Have them import and delegate to di package where possible
3. This maintains backward compat without breaking App internals

Actually, re-reading CONTEXT.md: "Breaking changes acceptable if they result in cleaner API"

So we CAN restructure App internals. Let's do it properly:

1. Export ServiceWrapper interface from di package (capitalized methods)
2. Add ForEachService() and GetService() to di.Container
3. Update App to use these methods
4. Delete redundant root package files

This is the clean approach.
  </action>
  <verify>
    - `ls container.go registration.go resolution.go 2>&1` shows files don't exist
    - `go build .` compiles
  </verify>
  <done>
Redundant root package files removed; App uses di.Container methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create di package tests and update root tests</name>
  <files>
    di/container_test.go
    di/registration_test.go
    di/resolution_test.go
    container_test.go
    registration_test.go
    resolution_test.go
    inject_test.go
    types_test.go
    service_test.go
  </files>
  <action>
Create tests for di package and update root package tests:

1. **di/container_test.go** - Create new test file:
   - Copy core tests from root container_test.go
   - Update package to `di`
   - Update function names: TestNewContainer â†’ TestNew
   - Test New(), Build(), List(), Has[T]()

2. **di/registration_test.go** - Create new test file:
   - Copy core registration tests
   - Test For[T](), Named(), Transient(), Eager(), Provider(), Instance()

3. **di/resolution_test.go** - Create new test file:
   - Copy core resolution tests
   - Test Resolve[T](), MustResolve[T]()
   - Add test for MustResolve panic behavior

4. **Update root package tests**:
   - container_test.go - Update to use gaz.NewContainer() (which wraps di.New())
   - registration_test.go - Verify gaz.For[T]() still works
   - resolution_test.go - Verify gaz.Resolve[T]() still works
   - inject_test.go - Should work unchanged (uses gaz types which are aliases)
   - types_test.go - Update to test gaz.TypeName[T]() wrapper
   - service_test.go - Keep tests for instanceServiceAny only

5. **Delete redundant test files** if their functionality is fully covered by di tests:
   - Keep root package tests as integration tests (verify backward compat)
   - di package tests are the primary unit tests

Key test patterns for di package:
```go
package di

import (
    "testing"
    "github.com/stretchr/testify/suite"
)

type ContainerSuite struct {
    suite.Suite
}

func TestContainerSuite(t *testing.T) {
    suite.Run(t, new(ContainerSuite))
}

func (s *ContainerSuite) TestNew() {
    c := New()
    s.Require().NotNil(c)
}

func (s *ContainerSuite) TestList_Empty() {
    c := New()
    s.Empty(c.List())
}

func (s *ContainerSuite) TestList_WithServices() {
    c := New()
    For[*testService](c).Instance(&testService{})
    names := c.List()
    s.Len(names, 1)
}

func (s *ContainerSuite) TestHas_NotRegistered() {
    c := New()
    s.False(Has[*testService](c))
}

func (s *ContainerSuite) TestHas_Registered() {
    c := New()
    For[*testService](c).Instance(&testService{})
    s.True(Has[*testService](c))
}
```

MustResolve panic test:
```go
func (s *ResolutionSuite) TestMustResolve_Panics() {
    c := New()
    s.Panics(func() {
        MustResolve[*testService](c)
    })
}

func (s *ResolutionSuite) TestMustResolve_Success() {
    c := New()
    expected := &testService{name: "test"}
    For[*testService](c).Instance(expected)
    result := MustResolve[*testService](c)
    s.Same(expected, result)
}
```
  </action>
  <verify>
    - `go test ./di/...` passes
    - `go test ./...` passes (all tests including root package)
  </verify>
  <done>
All tests pass for both di package and root gaz package.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full test suite passes: `go test ./... -race`
2. Build succeeds: `go build ./...`
3. Redundant files removed: `ls container.go registration.go resolution.go 2>&1 | grep "No such file"`
4. di package has tests: `ls di/*_test.go`
5. App uses di.New(): `grep "di.New()" app.go`
</verification>

<success_criteria>
- `go test ./...` passes with 0 failures
- `go test ./... -race` passes with 0 race conditions
- container.go, registration.go, resolution.go removed from root
- di package has comprehensive test coverage
- App.container created via di.New()
- Backward compatibility maintained (existing gaz.* calls work)
</success_criteria>

<output>
After completion, create `.planning/phases/12-di/12-03-SUMMARY.md`
</output>
