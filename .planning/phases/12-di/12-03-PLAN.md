---
phase: 12-di
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - app.go
  - service.go
  - container.go
  - registration.go
  - resolution.go
autonomous: true

must_haves:
  truths:
    - "app.go uses di.Container internally via di.New()"
    - "app.go uses c.ForEachService() instead of direct c.services access"
    - "app.go uses c.GetService() for individual service lookups"
    - "app.go type-asserts to di.ServiceWrapper for lifecycle methods"
    - "Original root package files removed (container.go, registration.go, resolution.go)"
  artifacts:
    - path: "app.go"
      provides: "App using di.Container"
      contains: "di.New()"
    - path: "service.go"
      provides: "Minimal service.go with instanceServiceAny only"
      contains: "instanceServiceAny"
  key_links:
    - from: "app.go"
      to: "di/container.go"
      via: "container creation and accessor methods"
      pattern: "di\\.New\\(\\)|ForEachService|GetService"
    - from: "app.go"
      to: "di/service.go"
      via: "type assertion for lifecycle"
      pattern: "di\\.ServiceWrapper"
---

<objective>
Update App to use di.Container internally and remove redundant root package files.

Purpose: Complete the DI extraction by wiring App to use di package accessor methods.
Output: app.go uses di.New(), ForEachService(), GetService(), and di.ServiceWrapper; redundant files deleted.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-di/12-CONTEXT.md
@.planning/phases/12-di/12-RESEARCH.md

# Plan 1 & 2 outputs
@di/container.go
@di/service.go
@compat.go

# Files to update
@app.go
@service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update App to use di.Container</name>
  <files>app.go</files>
  <action>
Update app.go to use di package internally:

1. Add import: `"github.com/petabytecl/gaz/di"`

2. Update New() function:
   - Change `container: NewContainer()` to `container: di.New()`

3. Replace all direct `a.container.services` field access with accessor methods:
   - Replace iteration loops like `for k, v := range a.container.services` with:
     ```go
     a.container.ForEachService(func(name string, svc any) {
         wrapper := svc.(di.ServiceWrapper)
         // ... use wrapper
     })
     ```
   - Replace individual lookups with `a.container.GetService(name)`

4. Update lifecycle management to use di.ServiceWrapper interface:
   - Replace `wrapper.start()` → `wrapper.Start()`
   - Replace `wrapper.stop()` → `wrapper.Stop()`
   - Replace `wrapper.isTransient()` → `wrapper.IsTransient()`
   - Replace `wrapper.hasLifecycle()` → `wrapper.HasLifecycle()`
   - Replace `wrapper.name()` → `wrapper.Name()`
   - Replace `wrapper.typeName()` → `wrapper.TypeName()`
   - Replace `wrapper.isEager()` → `wrapper.IsEager()`
   - Replace `wrapper.getInstance()` → `wrapper.GetInstance()`

5. Update registerInstance() to use di types:
   - Keep using local instanceServiceAny (stays in service.go for internal use)
   - Update any type assertions to use di.ServiceWrapper
  </action>
  <verify>
    - `grep "di.New()" app.go` finds the updated constructor
    - `grep "ForEachService" app.go` finds accessor usage
    - `grep "di.ServiceWrapper" app.go` finds type assertion
    - `go build .` compiles
  </verify>
  <done>
App updated to use di.New(), ForEachService(), GetService(), and di.ServiceWrapper.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove redundant root package files and update service.go</name>
  <files>
    container.go
    registration.go
    resolution.go
    service.go
  </files>
  <action>
Delete redundant files and update service.go:

1. **Delete container.go** - Functionality now in di/container.go
   - `rm container.go`

2. **Delete registration.go** - Functionality now in di/registration.go
   - `rm registration.go`

3. **Delete resolution.go** - Functionality now in di/resolution.go
   - `rm resolution.go`

4. **Update service.go** - Keep ONLY instanceServiceAny for App internal use:
   - Remove: serviceWrapper interface (now di.ServiceWrapper)
   - Remove: baseService, lazySingleton, transientService, eagerSingleton, instanceService
   - Remove: newLazySingleton, newTransient, newEagerSingleton, newInstanceService
   - Keep: instanceServiceAny struct and newInstanceServiceAny function
   - Update instanceServiceAny to implement di.ServiceWrapper interface:
     - Capitalize method names: name() → Name(), typeName() → TypeName(), etc.
     - Add import for di package
     - Ensure it implements all di.ServiceWrapper methods

The resulting service.go should be ~50-80 lines containing only:
```go
package gaz

import (
    "context"
    "github.com/petabytecl/gaz/di"
)

// instanceServiceAny is retained for internal use by App.registerInstance()
// for runtime type registration where compile-time type is unknown.
type instanceServiceAny struct {
    svcName  string
    svcType  string
    instance any
    // ... lifecycle fields
}

func newInstanceServiceAny(name string, typeName string, instance any) *instanceServiceAny {
    // ...
}

// Implement di.ServiceWrapper interface
func (s *instanceServiceAny) Name() string { return s.svcName }
func (s *instanceServiceAny) TypeName() string { return s.svcType }
// ... etc
```
  </action>
  <verify>
    - `ls container.go registration.go resolution.go 2>&1 | grep -c "No such file"` equals 3
    - `grep "type instanceServiceAny struct" service.go` finds the retained type
    - `grep -c "lazySingleton\|transientService\|eagerSingleton" service.go` equals 0
    - `go build .` compiles
  </verify>
  <done>
Redundant root package files deleted; service.go contains only instanceServiceAny implementing di.ServiceWrapper.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds: `go build .`
2. Redundant files removed: `ls container.go registration.go resolution.go 2>&1` shows files don't exist
3. App uses di.New(): `grep "di.New()" app.go`
4. App uses accessor methods: `grep "ForEachService\|GetService" app.go`
5. service.go is minimal: `wc -l service.go` is under 100 lines
</verification>

<success_criteria>
- container.go, registration.go, resolution.go removed from root
- service.go contains only instanceServiceAny (~50-80 lines)
- App.container created via di.New()
- App uses ForEachService() and GetService() instead of direct field access
- App type-asserts to di.ServiceWrapper for lifecycle calls
- `go build .` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/12-di/12-03-SUMMARY.md`
</output>
