---
phase: 38-transport-foundations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - server/http/doc.go
  - server/http/config.go
  - server/http/server.go
  - server/http/module.go
autonomous: true

must_haves:
  truths:
    - "HTTP server starts on configured port (default 8080)"
    - "Server has configurable timeouts (Read, Write, Idle, Header)"
    - "Server shuts down gracefully on app stop"
    - "Handler can be customized via module options"
  artifacts:
    - path: "server/http/config.go"
      provides: "HTTPConfig struct with Port and timeout fields"
      contains: "type HTTPConfig struct"
    - path: "server/http/server.go"
      provides: "HTTPServer with Starter/Stopper lifecycle"
      exports: ["HTTPServer", "NewHTTPServer"]
    - path: "server/http/module.go"
      provides: "DI module registration"
      exports: ["Module", "NewModule"]
  key_links:
    - from: "server/http/server.go"
      to: "net/http"
      via: "http.Server with configured timeouts"
      pattern: "http\\.Server\\{"
    - from: "server/http/server.go"
      to: "context"
      via: "server.Shutdown for graceful stop"
      pattern: "Shutdown\\(ctx\\)"
---

<objective>
Implement a production-ready HTTP server with configurable timeouts and DI integration.

Purpose: Establish the HTTP server foundation that Gateway (Phase 39) will use for proxying HTTP to gRPC.
Output: Complete server/http package with config, server, and module.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/38-transport-foundations/38-CONTEXT.md
@.planning/phases/38-transport-foundations/38-RESEARCH.md

# Existing patterns to follow
@health/server.go
@health/module.go
@health/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTTP package structure and config</name>
  <files>server/http/doc.go, server/http/config.go</files>
  <action>
Create the server/http package:

1. `server/http/doc.go`:
   - Package documentation explaining HTTP server for Gateway/general use

2. `server/http/config.go`:
   - `HTTPConfig` struct with fields:
     - `Port int` (default 8080)
     - `ReadTimeout time.Duration` (default 10s)
     - `WriteTimeout time.Duration` (default 30s)
     - `IdleTimeout time.Duration` (default 120s)
     - `ReadHeaderTimeout time.Duration` (default 5s)
   - `DefaultHTTPConfig()` function returning sensible defaults
   - Implement `Defaulter` interface for config defaults
   - Implement `Validator` interface for validation (port > 0, timeouts > 0)

Follow health/config.go pattern for config struct conventions.
Timeouts follow 38-RESEARCH.md recommendations to prevent slow loris attacks.
  </action>
  <verify>Files compile: `go build ./server/http/...`</verify>
  <done>HTTPConfig struct exists with defaults for port and all timeouts</done>
</task>

<task type="auto">
  <name>Task 2: Implement HTTPServer with lifecycle</name>
  <files>server/http/server.go</files>
  <action>
Create the core HTTP server:

1. `HTTPServer` struct:
   - Fields: config, *http.Server, logger, handler (http.Handler)
   - Implements `di.Starter` and `di.Stopper`

2. `NewHTTPServer(cfg HTTPConfig, handler http.Handler, logger *slog.Logger) *HTTPServer`:
   - Create http.Server with all timeout fields configured:
     - Addr: fmt.Sprintf(":%d", cfg.Port)
     - Handler: handler
     - ReadTimeout, WriteTimeout, IdleTimeout, ReadHeaderTimeout from config
   - Store logger for startup/shutdown logging

3. `OnStart(ctx context.Context) error`:
   - Start ListenAndServe in goroutine (non-blocking, same as health/server.go)
   - Log startup message with port
   - Return nil immediately (server runs in background)

4. `OnStop(ctx context.Context) error`:
   - Call server.Shutdown(ctx) for graceful shutdown
   - Log shutdown message
   - Return wrapped error if shutdown fails

5. `SetHandler(h http.Handler)`:
   - Allow handler to be set after construction (for Gateway integration)
   - Panic if server already started

Follow health/server.go pattern exactly for lifecycle implementation.
  </action>
  <verify>`go build ./server/http/...` and `go vet ./server/http/...`</verify>
  <done>HTTPServer starts on port, respects timeouts, shuts down gracefully</done>
</task>

<task type="auto">
  <name>Task 3: Create DI module registration</name>
  <files>server/http/module.go</files>
  <action>
Create the DI module following health/module.go pattern:

1. `ModuleOption func(*moduleConfig)` for configuration options
2. `WithPort(port int) ModuleOption`
3. `WithReadTimeout(d time.Duration) ModuleOption`
4. `WithWriteTimeout(d time.Duration) ModuleOption`
5. `WithHandler(h http.Handler) ModuleOption` - for custom handler

4. `NewModule(opts ...ModuleOption) di.Module`:
   - Apply options to config
   - Return `di.NewModuleFunc("http", func(c *di.Container) error {...})`

5. `Module(c *di.Container) error`:
   - Register `HTTPConfig` (if not already registered)
   - Register `*HTTPServer` as Eager (starts on app start)
   - Provider resolves logger via `di.Resolve[*slog.Logger](c)`
   - Provider resolves config via `di.Resolve[HTTPConfig](c)`
   - If no handler provided, use http.NotFoundHandler() as default

Ensure HTTPServer is registered as Eager so it starts with the application.
Note: The handler will typically be set by Gateway module in Phase 39.
  </action>
  <verify>`go build ./server/http/...` and imports resolve</verify>
  <done>Module registers HTTPServer as eager service with configurable handler</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./server/http/...` - compiles without errors
2. `go vet ./server/http/...` - no issues
3. `make lint` - passes linting
</verification>

<success_criteria>
- server/http package exists with 4 files (doc, config, server, module)
- HTTPConfig has Port (default 8080) and all timeout fields with safe defaults
- HTTPServer implements OnStart/OnStop
- Timeouts prevent slow loris (ReadHeaderTimeout set)
- Module registers server as Eager with optional handler
- Package compiles and lints cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/38-transport-foundations/38-02-SUMMARY.md`
</output>
