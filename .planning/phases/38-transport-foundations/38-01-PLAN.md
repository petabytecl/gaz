---
phase: 38-transport-foundations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/grpc/doc.go
  - server/grpc/config.go
  - server/grpc/server.go
  - server/grpc/interceptors.go
  - server/grpc/module.go
autonomous: true

must_haves:
  truths:
    - "gRPC server starts on configured port (default 50051)"
    - "gRPC reflection is queryable via grpcurl"
    - "Panic in handler returns gRPC Internal error (not crash)"
    - "Request logs appear with method, duration, status"
  artifacts:
    - path: "server/grpc/config.go"
      provides: "GRPCConfig struct with Port, Reflection fields"
      contains: "type GRPCConfig struct"
    - path: "server/grpc/server.go"
      provides: "GRPCServer with Starter/Stopper lifecycle"
      exports: ["GRPCServer", "NewGRPCServer"]
    - path: "server/grpc/interceptors.go"
      provides: "Logging and recovery interceptors"
      exports: ["LoggingInterceptor", "RecoveryInterceptor"]
    - path: "server/grpc/module.go"
      provides: "DI module registration"
      exports: ["Module", "NewModule"]
  key_links:
    - from: "server/grpc/server.go"
      to: "google.golang.org/grpc"
      via: "grpc.NewServer with ChainedInterceptors"
      pattern: "grpc\\.NewServer"
    - from: "server/grpc/server.go"
      to: "google.golang.org/grpc/reflection"
      via: "reflection.Register"
      pattern: "reflection\\.Register"
    - from: "server/grpc/interceptors.go"
      to: "go-grpc-middleware/v2"
      via: "logging and recovery interceptors"
      pattern: "logging\\.UnaryServerInterceptor|recovery\\.UnaryServerInterceptor"
---

<objective>
Implement a production-ready gRPC server with interceptors, reflection, and DI integration.

Purpose: Establish the gRPC foundation that Gateway (Phase 39) will proxy to, with logging/recovery interceptors for production reliability.
Output: Complete server/grpc package with config, server, interceptors, and module.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/38-transport-foundations/38-CONTEXT.md
@.planning/phases/38-transport-foundations/38-RESEARCH.md

# Existing patterns to follow
@health/server.go
@health/module.go
@health/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gRPC package structure and config</name>
  <files>server/grpc/doc.go, server/grpc/config.go</files>
  <action>
Create the server/grpc package:

1. `server/grpc/doc.go`:
   - Package documentation explaining gRPC server with auto-discovery

2. `server/grpc/config.go`:
   - `GRPCConfig` struct with fields:
     - `Port int` (default 50051)
     - `Reflection bool` (default true)
     - `MaxRecvMsgSize int` (default 4MB)
     - `MaxSendMsgSize int` (default 4MB)
   - `DefaultGRPCConfig()` function returning sensible defaults
   - Implement `Defaulter` interface for config defaults
   - Implement `Validator` interface for validation (port > 0)

Follow health/config.go pattern for config struct conventions.
  </action>
  <verify>Files compile: `go build ./server/grpc/...`</verify>
  <done>GRPCConfig struct exists with defaults and validation</done>
</task>

<task type="auto">
  <name>Task 2: Implement gRPC interceptors</name>
  <files>server/grpc/interceptors.go</files>
  <action>
Create interceptors using go-grpc-middleware/v2:

1. Add dependencies:
   ```
   go get google.golang.org/grpc@v1.73.0
   go get github.com/grpc-ecosystem/go-grpc-middleware/v2@v2.3.3
   ```

2. `interceptors.go`:
   - `InterceptorLogger(logger *slog.Logger) logging.Logger` - adapter for slog
   - `NewLoggingInterceptor(logger *slog.Logger) (grpc.UnaryServerInterceptor, grpc.StreamServerInterceptor)`
   - `NewRecoveryInterceptor(logger *slog.Logger, devMode bool) (grpc.UnaryServerInterceptor, grpc.StreamServerInterceptor)`
     - Log full stack trace on panic
     - Return `status.Errorf(codes.Internal, "internal error")` in production
     - Return panic details in dev mode

Use patterns from 38-RESEARCH.md:
- `logging.UnaryServerInterceptor(loggerAdapter)`
- `recovery.WithRecoveryHandlerContext` for custom panic handling
  </action>
  <verify>`go build ./server/grpc/...` succeeds, no import errors</verify>
  <done>Logging and recovery interceptors implemented with slog integration</done>
</task>

<task type="auto">
  <name>Task 3: Implement GRPCServer with lifecycle</name>
  <files>server/grpc/server.go</files>
  <action>
Create the core gRPC server:

1. `ServiceRegistrar` interface:
   ```go
   type ServiceRegistrar interface {
       RegisterService(server grpc.ServiceRegistrar)
   }
   ```

2. `GRPCServer` struct:
   - Fields: config, grpc.Server, net.Listener, logger, container reference
   - Implements `di.Starter` and `di.Stopper`

3. `NewGRPCServer(cfg GRPCConfig, logger *slog.Logger, c *di.Container) *GRPCServer`:
   - Create grpc.Server with ChainUnaryInterceptor and ChainStreamInterceptor
   - Order interceptors: logging first, recovery last

4. `OnStart(ctx context.Context) error`:
   - Create listener on configured port (fail fast if port unavailable)
   - Auto-discover services via `gaz.ResolveAll[ServiceRegistrar](container)`
   - Register each discovered service
   - Enable reflection if config.Reflection is true
   - Start serving in goroutine (non-blocking)
   - Log startup message with port

5. `OnStop(ctx context.Context) error`:
   - Call GracefulStop() with context timeout
   - Fallback to Stop() if context deadline exceeded
   - Log shutdown message

Follow health/server.go pattern for lifecycle implementation.
  </action>
  <verify>`go build ./server/grpc/...` and `go vet ./server/grpc/...`</verify>
  <done>GRPCServer starts, discovers services, enables reflection, shuts down gracefully</done>
</task>

<task type="auto">
  <name>Task 4: Create DI module registration</name>
  <files>server/grpc/module.go</files>
  <action>
Create the DI module following health/module.go pattern:

1. `ModuleOption func(*moduleConfig)` for configuration options
2. `WithPort(port int) ModuleOption`
3. `WithReflection(enabled bool) ModuleOption`

4. `NewModule(opts ...ModuleOption) di.Module`:
   - Apply options to config
   - Return `di.NewModuleFunc("grpc", func(c *di.Container) error {...})`

5. `Module(c *di.Container) error`:
   - Register `GRPCConfig` (if not already registered)
   - Register `*GRPCServer` as Eager (starts on app start)
   - Provider resolves logger via `di.Resolve[*slog.Logger](c)`
   - Provider resolves config via `di.Resolve[GRPCConfig](c)`

Ensure GRPCServer is registered as Eager so it starts with the application.
  </action>
  <verify>`go build ./server/grpc/...` and imports resolve</verify>
  <done>Module registers GRPCServer as eager service with proper DI wiring</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./server/grpc/...` - compiles without errors
2. `go vet ./server/grpc/...` - no issues
3. `make lint` - passes linting
</verification>

<success_criteria>
- server/grpc package exists with 5 files (doc, config, server, interceptors, module)
- GRPCConfig has Port (default 50051) and Reflection (default true)
- GRPCServer implements OnStart/OnStop
- Interceptors use go-grpc-middleware/v2 for logging and recovery
- Module registers server as Eager
- Package compiles and lints cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/38-transport-foundations/38-01-SUMMARY.md`
</output>
