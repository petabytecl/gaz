---
phase: 09-provider-config-registration
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - app.go
  - config_manager.go
  - provider_config.go
  - provider_config_test.go
autonomous: true

must_haves:
  truths:
    - "Provider implementing ConfigProvider has its keys collected during registration"
    - "Namespace is auto-prefixed to all provider keys"
    - "Collision between two providers fails Build() with clear error"
    - "Required config missing fails Build() with clear error"
    - "Config values are accessible via ProviderValues from container"
    - "Env vars work with translated key names (redis.host -> REDIS_HOST)"
  artifacts:
    - path: "app.go"
      provides: "Provider config collection and validation in Build()"
      contains: "ConfigProvider"
    - path: "config_manager.go"
      provides: "Provider key registration and env binding"
      contains: "RegisterProviderConfig"
    - path: "provider_config.go"
      provides: "ProviderValues type for config retrieval"
      exports: ["ProviderValues"]
    - path: "provider_config_test.go"
      provides: "Comprehensive tests for provider config"
      min_lines: 100
  key_links:
    - from: "app.go"
      to: "config_manager.go"
      via: "RegisterProviderConfig call"
      pattern: "RegisterProviderConfig"
    - from: "provider_config.go"
      to: "viper"
      via: "value retrieval"
      pattern: "GetString|GetInt|GetBool"
    - from: "app.go"
      to: "container"
      via: "ProviderValues registration"
      pattern: "registerInstance.*ProviderValues"
---

<objective>
Implement the full provider config registration flow: collect config from ConfigProvider implementers during registration, detect key collisions, validate required fields, integrate with ConfigManager for env var binding, and provide ProviderValues for retrieving config at runtime.

Purpose: Complete the feature so providers can declare and receive configuration values. This enables self-contained modules like a Redis provider to specify `redis.host` and `redis.port` config.

Output: Working provider config system with collection, collision detection, validation, env binding, and value retrieval.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-provider-config-registration/09-CONTEXT.md
@.planning/phases/09-provider-config-registration/09-01-SUMMARY.md

@app.go
@config_manager.go
@provider_config.go
@errors.go
@config_manager_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ProviderValues type and config collection to App</name>
  <files>provider_config.go, app.go</files>
  <action>
**In provider_config.go, add ProviderValues type:**

```go
// ProviderValues provides access to provider-registered configuration values.
// Inject this via the DI container to retrieve config values by their full key.
type ProviderValues struct {
    v *viper.Viper
}

// GetString returns a string config value by its full key (e.g., "redis.host").
func (pv *ProviderValues) GetString(key string) string {
    return pv.v.GetString(key)
}

// GetInt returns an int config value by its full key.
func (pv *ProviderValues) GetInt(key string) int {
    return pv.v.GetInt(key)
}

// GetBool returns a bool config value by its full key.
func (pv *ProviderValues) GetBool(key string) bool {
    return pv.v.GetBool(key)
}

// GetDuration returns a duration config value by its full key.
func (pv *ProviderValues) GetDuration(key string) time.Duration {
    return pv.v.GetDuration(key)
}

// GetFloat64 returns a float64 config value by its full key.
func (pv *ProviderValues) GetFloat64(key string) float64 {
    return pv.v.GetFloat64(key)
}
```

**In app.go, add:**

1. New field on App struct:
   ```go
   providerConfigs []providerConfigEntry  // collected from ConfigProvider implementers
   ```

2. Helper struct:
   ```go
   type providerConfigEntry struct {
       providerName string     // type name of the provider
       namespace    string     // from ConfigNamespace()
       flags        []ConfigFlag
   }
   ```

3. In `registerProvider()` method, after creating the wrapped provider and before registering:
   - Create a temporary instance by calling the provider with a temp container (or use reflect to check interface)
   - Better approach: After calling `wrappedProvider(c)` successfully in Build(), check if instance implements ConfigProvider
   - Actually, since we need config BEFORE resolution, check if the *provider function's return type* would implement ConfigProvider
   - Cleanest: Add logic in Build() to iterate resolved services and collect from ConfigProvider implementers

4. In `Build()` method, after config loading but before eager instantiation:
   - Iterate all registered services
   - For each service, try to get instance (this resolves lazy singletons)
   - Check if instance implements ConfigProvider
   - If yes, call ConfigNamespace() and ConfigFlags()
   - Store in providerConfigs with fully-qualified keys (namespace + "." + key)
   - Check for collisions: build map of key -> providerName, fail if duplicate
   - If ConfigManager exists, call new method to register provider keys
   - Validate required flags

5. After validation passes, create ProviderValues and register as instance:
   ```go
   pv := &ProviderValues{v: a.configManager.viper()}
   a.registerInstance(pv)
   ```
  </action>
  <verify>`go build ./...` passes</verify>
  <done>App collects ConfigProvider implementers and detects collisions</done>
</task>

<task type="auto">
  <name>Task 2: Add ConfigManager integration for provider keys</name>
  <files>config_manager.go</files>
  <action>
**Add methods to ConfigManager:**

1. `Viper() *viper.Viper` - export viper instance for ProviderValues (or add getter method):
   ```go
   // Viper returns the underlying viper instance.
   // Used internally for ProviderValues.
   func (cm *ConfigManager) Viper() *viper.Viper {
       return cm.v
   }
   ```

2. `RegisterProviderFlags(namespace string, flags []ConfigFlag) error`:
   - For each flag:
     - Build full key: namespace + "." + flag.Key (e.g., "redis.host")
     - Set default if flag.Default != nil: `cm.v.SetDefault(fullKey, flag.Default)`
     - Bind env var: `cm.v.BindEnv(fullKey)` (viper handles translation with SetEnvKeyReplacer)

3. `ValidateProviderFlags(namespace string, flags []ConfigFlag) []error`:
   - For each flag where Required == true:
     - Build full key
     - Check if value is set: `cm.v.IsSet(fullKey)` or check if value is zero
     - If required but not set, add error: "provider {namespace}: required config key {fullKey} is not set"
   - Return slice of all errors (collect all, don't fail fast)

Note: The env key replacer is already set in Load() as `.` -> `__`. For env prefix, if APP is prefix and key is redis.host, env var would be APP_REDIS__HOST. 

Actually, per CONTEXT.md: "redis.host → REDIS_HOST" - this suggests UNDERSCORE not double underscore.

Check existing code: uses `strings.NewReplacer(".", "__")`. Per CONTEXT.md decision we should use single underscore. BUT the user may have existing config - let's match what's in CONTEXT.md.

**Update SetEnvKeyReplacer** for provider keys to use `_` for dots:
- Provider keys use: `redis.host` → `REDIS_HOST` (single underscore)
- This is different from nested structs which use `__`

Actually, simplest approach: when binding provider keys, use an explicit env var name:
```go
envKey := strings.ToUpper(strings.ReplaceAll(fullKey, ".", "_"))
cm.v.BindEnv(fullKey, envKey)
```

This way provider keys get the CONTEXT.md format while existing config structs keep their format.
  </action>
  <verify>`go build ./...` passes</verify>
  <done>ConfigManager can register and validate provider flags with env binding</done>
</task>

<task type="auto">
  <name>Task 3: Write comprehensive tests</name>
  <files>provider_config_test.go</files>
  <action>
Create `provider_config_test.go` using testify suite pattern (match config_manager_test.go style).

**Test Suite: ProviderConfigSuite**

1. **TestBasicConfigProvider**: Provider implements ConfigProvider, values accessible
   - Create mock provider struct implementing ConfigProvider
   - Register with App.ProvideSingleton
   - Set env var for the config key
   - Build and verify no error
   - Resolve ProviderValues, verify value is correct

2. **TestNamespacePrefixing**: Keys are prefixed with namespace
   - Provider declares namespace "redis" and key "host"
   - Set env var REDIS_HOST=localhost
   - Verify ProviderValues.GetString("redis.host") returns "localhost"

3. **TestKeyCollision**: Two providers with same full key fail Build()
   - Provider A: namespace "cache", key "host"
   - Provider B: namespace "cache", key "host"
   - Build() returns error containing ErrConfigKeyCollision
   - Error message lists both provider names

4. **TestRequiredMissing**: Required flag not set fails Build()
   - Provider with Required: true flag
   - Don't set the env var
   - Build() returns error mentioning required key

5. **TestRequiredSet**: Required flag set passes Build()
   - Provider with Required: true flag
   - Set the env var
   - Build() succeeds

6. **TestDefaultValue**: Default value used when not set
   - Provider with Default: "default-value"
   - Don't set env var
   - ProviderValues.GetString returns "default-value"

7. **TestAllTypes**: All ConfigFlagType values work
   - String, Int, Bool, Duration, Float
   - Set via env vars, verify GetString/GetInt/etc return correct values

8. **TestMultipleProviders**: Multiple providers with different namespaces
   - Redis provider with redis.host, redis.port
   - Cache provider with cache.ttl
   - All values accessible, no collision

9. **TestNoConfigManager**: App without WithConfig still works
   - Provider config registered but ConfigManager is nil
   - Should handle gracefully (skip provider config features or error clearly)

Use `s.T().Setenv()` for env vars (auto-cleanup).

Each test should:
- Create new App with gaz.New()
- Register test provider
- Set appropriate env vars
- Build and assert
  </action>
  <verify>
```bash
go test -v ./... -run ProviderConfig
```
All tests pass.
  </verify>
  <done>Comprehensive test coverage for provider config registration</done>
</task>

</tasks>

<verification>
```bash
# All code compiles
go build ./...

# All tests pass
go test -v ./...

# Specific provider config tests pass
go test -v ./... -run ProviderConfig

# Coverage check
go test -cover ./...
```
</verification>

<success_criteria>
1. Provider implementing ConfigProvider has config collected during Build()
2. Keys auto-prefixed with namespace (redis + host = redis.host)
3. Two providers with same key fails with ErrConfigKeyCollision and clear message
4. Required flag missing fails Build() with clear error
5. ProviderValues injectable and returns correct values
6. Env vars work with REDIS_HOST format for redis.host
7. Default values applied when config not set
8. All tests pass with good coverage
9. `go build ./...` and `go test ./...` pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-provider-config-registration/09-02-SUMMARY.md`
</output>
