---
phase: 03-app-builder-cobra
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - cobra.go
  - cobra_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Developer can integrate app with cobra.Command using WithCobra()"
    - "Subcommands can access App from context with FromContext()"
    - "App lifecycle (Build, Start, Stop) integrates with Cobra command execution"
    - "Existing Cobra hooks are preserved (chained, not replaced)"
  artifacts:
    - path: "cobra.go"
      provides: "WithCobra() method, FromContext() helper, context key"
      exports: ["WithCobra", "FromContext"]
    - path: "cobra_test.go"
      provides: "Tests for Cobra integration"
    - path: "go.mod"
      provides: "Cobra dependency"
      contains: "github.com/spf13/cobra"
  key_links:
    - from: "cobra.go"
      to: "app.go"
      via: "WithCobra() is method on App, calls Build()/Start()/Stop()"
      pattern: "func \\(a \\*App\\) WithCobra"
    - from: "cobra.go"
      to: "context"
      via: "App stored in context with contextKey{}"
      pattern: "context\\.WithValue.*contextKey"
---

<objective>
Add Cobra CLI integration to the App fluent API, allowing developers to attach app lifecycle to Cobra commands so DI is available in CLI subcommands.

Purpose: Enable CLI applications to use full DI with automatic lifecycle management when running Cobra commands.

Output: WithCobra() method that hooks PersistentPreRunE/PostRunE, FromContext() helper for subcommands.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-app-builder-cobra/03-CONTEXT.md
@.planning/phases/03-app-builder-cobra/03-RESEARCH.md
@.planning/phases/03-app-builder-cobra/03-01-SUMMARY.md

# Relevant source files
@app.go
@lifecycle.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Cobra dependency</name>
  <files>go.mod, go.sum</files>
  <action>
Add the Cobra dependency:

```bash
go get github.com/spf13/cobra@latest
```

Verify go.mod contains:
```
require (
    github.com/spf13/cobra v1.9.1 // or latest
    ...
)
```

Run `go mod tidy` to clean up dependencies.
  </action>
  <verify>`go mod tidy && go build ./...` succeeds</verify>
  <done>Cobra dependency added to go.mod</done>
</task>

<task type="auto">
  <name>Task 2: Create cobra.go with WithCobra() and FromContext()</name>
  <files>cobra.go</files>
  <action>
Create cobra.go with the Cobra integration:

```go
package gaz

import (
    "context"
    "errors"
    "fmt"
    
    "github.com/spf13/cobra"
)

// contextKey is used to store App in context.
type contextKey struct{}

// FromContext retrieves the App from a context.
// Returns nil if no App is found.
// Use this in Cobra command handlers to access the DI container.
//
// Example:
//
//  var serveCmd = &cobra.Command{
//      Use: "serve",
//      RunE: func(cmd *cobra.Command, args []string) error {
//          app := gaz.FromContext(cmd.Context())
//          server, err := gaz.Resolve[*HTTPServer](app.Container())
//          if err != nil {
//              return err
//          }
//          return server.ListenAndServe()
//      },
//  }
func FromContext(ctx context.Context) *App {
    if app, ok := ctx.Value(contextKey{}).(*App); ok {
        return app
    }
    return nil
}

// Container returns the underlying DI container.
// Use this to resolve services in Cobra command handlers.
func (a *App) Container() *Container {
    return a.container
}

// WithCobra attaches the App lifecycle to a Cobra command.
// This hooks into PersistentPreRunE to Build() and Start() the app,
// and into PersistentPostRunE to Stop() the app.
//
// The App is stored in the command's context, accessible via FromContext().
//
// Existing hooks on the command are preserved and chained (not replaced).
//
// Example:
//
//  rootCmd := &cobra.Command{Use: "myapp"}
//  app := gaz.New().
//      ProvideSingleton(NewDatabase).
//      WithCobra(rootCmd)
//
//  // In subcommand:
//  app := gaz.FromContext(cmd.Context())
//  db, _ := gaz.Resolve[*Database](app.Container())
func (a *App) WithCobra(cmd *cobra.Command) *App {
    // Preserve existing hooks
    originalPreRunE := cmd.PersistentPreRunE
    originalPostRunE := cmd.PersistentPostRunE
    
    cmd.PersistentPreRunE = func(c *cobra.Command, args []string) error {
        // Chain original hook first
        if originalPreRunE != nil {
            if err := originalPreRunE(c, args); err != nil {
                return err
            }
        }
        
        // Build the app (validates registrations)
        if err := a.Build(); err != nil {
            return fmt.Errorf("app build failed: %w", err)
        }
        
        // Get context from command (Cobra provides background if none)
        ctx := c.Context()
        if ctx == nil {
            ctx = context.Background()
        }
        
        // Start lifecycle hooks
        if err := a.Start(ctx); err != nil {
            return fmt.Errorf("app start failed: %w", err)
        }
        
        // Store app in context for subcommand access
        c.SetContext(context.WithValue(ctx, contextKey{}, a))
        
        return nil
    }
    
    cmd.PersistentPostRunE = func(c *cobra.Command, args []string) error {
        // Stop with configured timeout
        stopCtx, cancel := context.WithTimeout(context.Background(), a.opts.ShutdownTimeout)
        defer cancel()
        
        stopErr := a.Stop(stopCtx)
        
        // Chain original hook
        if originalPostRunE != nil {
            if err := originalPostRunE(c, args); err != nil {
                return errors.Join(stopErr, err)
            }
        }
        
        return stopErr
    }
    
    return a
}

// Start initiates the application lifecycle.
// This is called automatically by WithCobra() or can be called manually.
// It executes OnStart hooks for all services in dependency order.
func (a *App) Start(ctx context.Context) error {
    // Compute startup order
    graph := a.container.getGraph()
    services := make(map[string]serviceWrapper)
    a.container.mu.RLock()
    for k, v := range a.container.services {
        if w, ok := v.(serviceWrapper); ok {
            services[k] = w
        }
    }
    a.container.mu.RUnlock()

    startupOrder, err := ComputeStartupOrder(graph, services)
    if err != nil {
        return err
    }

    // Start services layer by layer
    for _, layer := range startupOrder {
        for _, name := range layer {
            svc := services[name]
            if startErr := svc.start(ctx); startErr != nil {
                return fmt.Errorf("starting service %s: %w", name, startErr)
            }
        }
    }
    
    return nil
}
```

**Note:** The `Start()` method extracts the startup logic from the existing `Run()` method. If `Run()` already uses this pattern, reuse that logic. The key is that `Start()` is callable independently for Cobra integration.

**Important:** Check if `Start()` already exists in app.go from Plan 01. If so, just implement `WithCobra()` and `FromContext()` here.
  </action>
  <verify>`go build ./...` compiles cleanly</verify>
  <done>cobra.go created with WithCobra(), FromContext(), Container() methods</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for Cobra integration</name>
  <files>cobra_test.go</files>
  <action>
Create cobra_test.go with tests for the integration:

```go
package gaz

import (
    "context"
    "testing"
    
    "github.com/spf13/cobra"
    "github.com/stretchr/testify/suite"
)

type CobraSuite struct {
    suite.Suite
}

func TestCobraSuite(t *testing.T) {
    suite.Run(t, new(CobraSuite))
}

func (s *CobraSuite) TestWithCobraBuildsApp() {
    app := New()
    
    var buildCalled bool
    err := For[*testService](app.container).ProviderFunc(func(c *Container) *testService {
        buildCalled = true
        return &testService{}
    })
    s.Require().NoError(err)
    
    rootCmd := &cobra.Command{
        Use: "test",
        RunE: func(cmd *cobra.Command, args []string) error {
            // Access app from context
            gotApp := FromContext(cmd.Context())
            s.NotNil(gotApp)
            s.Same(app, gotApp)
            
            // Resolve service
            svc, err := Resolve[*testService](gotApp.Container())
            s.Require().NoError(err)
            s.NotNil(svc)
            
            return nil
        },
    }
    
    app.WithCobra(rootCmd)
    
    // Execute command
    rootCmd.SetArgs([]string{})
    err = rootCmd.Execute()
    s.Require().NoError(err)
}

func (s *CobraSuite) TestWithCobraPreservesExistingHooks() {
    app := New()
    
    var preRunCalled, postRunCalled bool
    
    rootCmd := &cobra.Command{
        Use: "test",
        PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
            preRunCalled = true
            return nil
        },
        PersistentPostRunE: func(cmd *cobra.Command, args []string) error {
            postRunCalled = true
            return nil
        },
        RunE: func(cmd *cobra.Command, args []string) error {
            return nil
        },
    }
    
    app.WithCobra(rootCmd)
    
    rootCmd.SetArgs([]string{})
    err := rootCmd.Execute()
    s.Require().NoError(err)
    
    s.True(preRunCalled, "original PersistentPreRunE should be called")
    s.True(postRunCalled, "original PersistentPostRunE should be called")
}

func (s *CobraSuite) TestFromContextReturnsNilWhenNoApp() {
    ctx := context.Background()
    app := FromContext(ctx)
    s.Nil(app)
}

func (s *CobraSuite) TestWithCobraChaining() {
    app := New()
    rootCmd := &cobra.Command{Use: "test"}
    
    result := app.WithCobra(rootCmd)
    s.Same(app, result) // Returns same app for chaining
}

func (s *CobraSuite) TestWithCobraSubcommandAccess() {
    app := New()
    
    // Register a service
    _ = For[*testService](app.container).ProviderFunc(func(c *Container) *testService {
        return &testService{name: "from-app"}
    })
    
    var resolvedName string
    
    rootCmd := &cobra.Command{Use: "root"}
    subCmd := &cobra.Command{
        Use: "sub",
        RunE: func(cmd *cobra.Command, args []string) error {
            gotApp := FromContext(cmd.Context())
            svc, err := Resolve[*testService](gotApp.Container())
            if err != nil {
                return err
            }
            resolvedName = svc.name
            return nil
        },
    }
    rootCmd.AddCommand(subCmd)
    
    app.WithCobra(rootCmd)
    
    rootCmd.SetArgs([]string{"sub"})
    err := rootCmd.Execute()
    s.Require().NoError(err)
    s.Equal("from-app", resolvedName)
}

func (s *CobraSuite) TestWithCobraBuildError() {
    app := New()
    
    // Register duplicate to cause build error
    _ = For[*testService](app.container).Provider(func(c *Container) (*testService, error) {
        return &testService{}, nil
    })
    _ = For[*testService](app.container).Provider(func(c *Container) (*testService, error) {
        return &testService{}, nil
    })
    
    rootCmd := &cobra.Command{
        Use:  "test",
        RunE: func(cmd *cobra.Command, args []string) error { return nil },
    }
    
    app.WithCobra(rootCmd)
    
    rootCmd.SetArgs([]string{})
    err := rootCmd.Execute()
    s.Require().Error(err)
    s.Contains(err.Error(), "app build failed")
}

// Helper types for tests
type testService struct {
    name string
}
```

Run `make test` to verify all tests pass.
  </action>
  <verify>`make test` passes; `make lint` passes</verify>
  <done>Cobra tests cover WithCobra, FromContext, hook chaining, subcommand access</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `make test` - all tests pass
2. `make lint` - no new linter warnings  
3. Cobra integration works:
```go
app := gaz.New().
    ProvideSingleton(NewDB).
    WithCobra(rootCmd)

// In subcommand:
app := gaz.FromContext(cmd.Context())
db, _ := gaz.Resolve[*DB](app.Container())
```
4. Existing PersistentPreRunE/PostRunE hooks are chained, not replaced
</verification>

<success_criteria>
- Cobra dependency added to go.mod
- WithCobra() method hooks into command lifecycle
- FromContext() retrieves App from context
- Container() method exposes container for resolution
- Existing hooks are preserved (chained)
- Build errors surface through Cobra command execution
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-app-builder-cobra/03-03-SUMMARY.md`
</output>
