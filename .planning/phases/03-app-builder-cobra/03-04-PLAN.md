---
phase: 03-app-builder-cobra
plan: 04
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - app_integration_test.go
autonomous: true

must_haves:
  truths:
    - "Complete app lifecycle works end-to-end with gaz.New() -> providers -> Build() -> Run()"
    - "Module composition integrates with provider registration"
    - "Cobra integration works with full app lifecycle"
    - "Error handling covers all failure modes"
  artifacts:
    - path: "app_integration_test.go"
      provides: "End-to-end integration tests for Phase 3 features"
  key_links:
    - from: "app_integration_test.go"
      to: "app.go"
      via: "Tests exercise complete New() -> Build() -> Run() flow"
      pattern: "gaz\\.New\\(\\)"
    - from: "app_integration_test.go"
      to: "cobra.go"
      via: "Tests exercise WithCobra() integration"
      pattern: "WithCobra"
---

<objective>
Create comprehensive end-to-end integration tests that verify all Phase 3 features work together correctly.

Purpose: Ensure the fluent API, module system, and Cobra integration work together without regressions.

Output: Integration test file covering complete workflows and edge cases.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-app-builder-cobra/03-01-SUMMARY.md
@.planning/phases/03-app-builder-cobra/03-02-SUMMARY.md
@.planning/phases/03-app-builder-cobra/03-03-SUMMARY.md

# Source files
@app.go
@cobra.go
@app_module.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration test file with realistic scenarios</name>
  <files>app_integration_test.go</files>
  <action>
Create app_integration_test.go with end-to-end integration tests:

```go
package gaz_test

import (
    "context"
    "errors"
    "sync/atomic"
    "testing"
    "time"
    
    "github.com/petabytecl/gaz"
    "github.com/spf13/cobra"
    "github.com/stretchr/testify/suite"
)

// IntegrationSuite tests the complete Phase 3 feature set working together.
type IntegrationSuite struct {
    suite.Suite
}

func TestIntegrationSuite(t *testing.T) {
    suite.Run(t, new(IntegrationSuite))
}

// =============================================================================
// Complete Workflow Tests
// =============================================================================

func (s *IntegrationSuite) TestCompleteFluentWorkflow() {
    // Test: gaz.New() -> providers -> Build() -> Run()
    
    app := gaz.New(gaz.WithShutdownTimeout(5 * time.Second))
    
    // Register database service
    err := gaz.For[*testDatabase](app.Container()).
        Provider(func(c *gaz.Container) (*testDatabase, error) {
            return &testDatabase{dsn: "postgres://localhost"}, nil
        })
    s.Require().NoError(err)
    
    // Register service that depends on database
    err = gaz.For[*testUserService](app.Container()).
        Provider(func(c *gaz.Container) (*testUserService, error) {
            db, err := gaz.Resolve[*testDatabase](c)
            if err != nil {
                return nil, err
            }
            return &testUserService{db: db}, nil
        })
    s.Require().NoError(err)
    
    // Build validates and wires
    err = app.Build()
    s.Require().NoError(err)
    
    // Resolve services
    userSvc, err := gaz.Resolve[*testUserService](app.Container())
    s.Require().NoError(err)
    s.NotNil(userSvc.db)
    s.Equal("postgres://localhost", userSvc.db.dsn)
}

func (s *IntegrationSuite) TestModulesWithFluentAPI() {
    // Test: Modules integrate with provider registration
    
    app := gaz.New()
    
    // Database module
    app.Module("database",
        func(c *gaz.Container) error {
            return gaz.For[*testDatabase](c).ProviderFunc(func(c *gaz.Container) *testDatabase {
                return &testDatabase{dsn: "postgres://db"}
            })
        },
        func(c *gaz.Container) error {
            return gaz.For[*testCache](c).ProviderFunc(func(c *gaz.Container) *testCache {
                return &testCache{addr: "redis://cache"}
            })
        },
    )
    
    // Service module that depends on database module
    app.Module("services",
        func(c *gaz.Container) error {
            return gaz.For[*testUserService](c).Provider(func(c *gaz.Container) (*testUserService, error) {
                db, err := gaz.Resolve[*testDatabase](c)
                if err != nil {
                    return nil, err
                }
                return &testUserService{db: db}, nil
            })
        },
    )
    
    err := app.Build()
    s.Require().NoError(err)
    
    // Verify cross-module dependencies work
    userSvc, err := gaz.Resolve[*testUserService](app.Container())
    s.Require().NoError(err)
    s.Equal("postgres://db", userSvc.db.dsn)
}

func (s *IntegrationSuite) TestCobraWithFullLifecycle() {
    // Test: Cobra integration with complete app lifecycle
    
    var startCalled, stopCalled atomic.Bool
    
    app := gaz.New(gaz.WithShutdownTimeout(time.Second))
    
    // Register service with lifecycle hooks
    err := gaz.For[*testLifecycleService](app.Container()).
        OnStart(func(ctx context.Context, svc *testLifecycleService) error {
            startCalled.Store(true)
            return nil
        }).
        OnStop(func(ctx context.Context, svc *testLifecycleService) error {
            stopCalled.Store(true)
            return nil
        }).
        Eager(). // Must be eager to have hooks called
        ProviderFunc(func(c *gaz.Container) *testLifecycleService {
            return &testLifecycleService{}
        })
    s.Require().NoError(err)
    
    var cmdExecuted bool
    
    rootCmd := &cobra.Command{
        Use: "test",
        RunE: func(cmd *cobra.Command, args []string) error {
            cmdExecuted = true
            
            // Verify app is accessible
            gotApp := gaz.FromContext(cmd.Context())
            s.NotNil(gotApp)
            
            // Verify service was started
            s.True(startCalled.Load())
            
            return nil
        },
    }
    
    app.WithCobra(rootCmd)
    
    rootCmd.SetArgs([]string{})
    err = rootCmd.Execute()
    s.Require().NoError(err)
    
    s.True(cmdExecuted)
    s.True(startCalled.Load())
    s.True(stopCalled.Load()) // Stopped in PostRunE
}

// =============================================================================
// Error Handling Tests
// =============================================================================

func (s *IntegrationSuite) TestBuildAggregatesAllErrors() {
    app := gaz.New()
    
    // Register duplicate services (should collect both errors)
    _ = gaz.For[*testDatabase](app.Container()).Provider(func(c *gaz.Container) (*testDatabase, error) {
        return &testDatabase{}, nil
    })
    _ = gaz.For[*testDatabase](app.Container()).Provider(func(c *gaz.Container) (*testDatabase, error) {
        return &testDatabase{}, nil
    })
    
    // Duplicate module name
    app.Module("dup").Module("dup")
    
    err := app.Build()
    s.Require().Error(err)
    
    // Should contain both error types
    s.True(errors.Is(err, gaz.ErrDuplicate))
    s.True(errors.Is(err, gaz.ErrDuplicateModule))
}

func (s *IntegrationSuite) TestMissingDependencyDetected() {
    app := gaz.New()
    
    // Service that depends on unregistered type
    _ = gaz.For[*testUserService](app.Container()).Provider(func(c *gaz.Container) (*testUserService, error) {
        db, err := gaz.Resolve[*testDatabase](c) // Not registered!
        if err != nil {
            return nil, err
        }
        return &testUserService{db: db}, nil
    })
    
    // Make it eager so Build() tries to instantiate
    // Actually, we need to mark it eager for Build to catch the error
    _ = gaz.For[*testUserService](app.Container()).
        Eager().
        Replace().
        Provider(func(c *gaz.Container) (*testUserService, error) {
            db, err := gaz.Resolve[*testDatabase](c)
            if err != nil {
                return nil, err
            }
            return &testUserService{db: db}, nil
        })
    
    err := app.Build()
    s.Require().Error(err)
    s.True(errors.Is(err, gaz.ErrNotFound))
}

func (s *IntegrationSuite) TestCyclicDependencyDetected() {
    app := gaz.New()
    
    // A depends on B, B depends on A
    _ = gaz.For[*serviceA](app.Container()).Eager().Provider(func(c *gaz.Container) (*serviceA, error) {
        b, err := gaz.Resolve[*serviceB](c)
        if err != nil {
            return nil, err
        }
        return &serviceA{b: b}, nil
    })
    
    _ = gaz.For[*serviceB](app.Container()).Provider(func(c *gaz.Container) (*serviceB, error) {
        a, err := gaz.Resolve[*serviceA](c)
        if err != nil {
            return nil, err
        }
        return &serviceB{a: a}, nil
    })
    
    err := app.Build()
    s.Require().Error(err)
    s.True(errors.Is(err, gaz.ErrCycle))
}

// =============================================================================
// Edge Cases
// =============================================================================

func (s *IntegrationSuite) TestEmptyAppBuildsSuccessfully() {
    app := gaz.New()
    err := app.Build()
    s.Require().NoError(err)
}

func (s *IntegrationSuite) TestBuildIsIdempotent() {
    app := gaz.New()
    
    _ = gaz.For[*testDatabase](app.Container()).ProviderFunc(func(c *gaz.Container) *testDatabase {
        return &testDatabase{}
    })
    
    err1 := app.Build()
    s.Require().NoError(err1)
    
    err2 := app.Build() // Second call
    s.Require().NoError(err2)
}

func (s *IntegrationSuite) TestNestedModuleDependencies() {
    // Test: Services in module B can depend on services in module A
    
    app := gaz.New()
    
    app.Module("infrastructure",
        func(c *gaz.Container) error {
            return gaz.For[*testDatabase](c).ProviderFunc(func(c *gaz.Container) *testDatabase {
                return &testDatabase{dsn: "infra-db"}
            })
        },
    ).Module("domain",
        func(c *gaz.Container) error {
            return gaz.For[*testUserService](c).Provider(func(c *gaz.Container) (*testUserService, error) {
                // Depend on service from infrastructure module
                db, err := gaz.Resolve[*testDatabase](c)
                if err != nil {
                    return nil, err
                }
                return &testUserService{db: db}, nil
            })
        },
    )
    
    err := app.Build()
    s.Require().NoError(err)
    
    userSvc, err := gaz.Resolve[*testUserService](app.Container())
    s.Require().NoError(err)
    s.Equal("infra-db", userSvc.db.dsn)
}

func (s *IntegrationSuite) TestCobraSubcommandHierarchy() {
    // Test: Nested subcommands all have access to App
    
    app := gaz.New()
    _ = gaz.For[*testDatabase](app.Container()).ProviderFunc(func(c *gaz.Container) *testDatabase {
        return &testDatabase{dsn: "test-db"}
    })
    
    var level1App, level2App *gaz.App
    
    rootCmd := &cobra.Command{Use: "root"}
    level1Cmd := &cobra.Command{
        Use: "level1",
        RunE: func(cmd *cobra.Command, args []string) error {
            level1App = gaz.FromContext(cmd.Context())
            return nil
        },
    }
    level2Cmd := &cobra.Command{
        Use: "level2",
        RunE: func(cmd *cobra.Command, args []string) error {
            level2App = gaz.FromContext(cmd.Context())
            return nil
        },
    }
    
    level1Cmd.AddCommand(level2Cmd)
    rootCmd.AddCommand(level1Cmd)
    
    app.WithCobra(rootCmd)
    
    // Execute nested command
    rootCmd.SetArgs([]string{"level1", "level2"})
    err := rootCmd.Execute()
    s.Require().NoError(err)
    
    s.Same(app, level2App)
}

// =============================================================================
// Test Helper Types
// =============================================================================

type testDatabase struct {
    dsn string
}

type testCache struct {
    addr string
}

type testUserService struct {
    db *testDatabase
}

type testLifecycleService struct{}

type serviceA struct {
    b *serviceB
}

type serviceB struct {
    a *serviceA
}
```

Run `make test` to verify all integration tests pass.
  </action>
  <verify>`make test` passes; `make lint` passes</verify>
  <done>Integration tests cover complete workflows, error handling, and edge cases</done>
</task>

<task type="auto">
  <name>Task 2: Verify full test coverage and clean up</name>
  <files>app_integration_test.go</files>
  <action>
Run full test suite and verify coverage:

```bash
make test
make lint
make coverage
```

1. Ensure all 100+ tests pass
2. Ensure no linter warnings
3. Ensure coverage remains at 90%+

If any issues arise from the integration tests, fix them:
- Adjust test expectations to match actual API
- Fix any type mismatches between tests and implementation
- Ensure test helper types don't conflict with existing types

After verification, check that the example usage in the tests matches the documented API from RESEARCH.md:

```go
// Expected API per RESEARCH.md:
app := gaz.New(gaz.WithShutdownTimeout(10 * time.Second))
// Provider registration (exact method depends on Plan 01 implementation)
app.Module("db", ...).
    Module("http", ...).
    WithCobra(rootCmd)

if err := app.Build(); err != nil {
    // err contains all validation failures
}

// In Cobra handler:
app := gaz.FromContext(cmd.Context())
svc, _ := gaz.Resolve[*Service](app.Container())
```
  </action>
  <verify>`make test` passes with 90%+ coverage; `make lint` passes</verify>
  <done>All integration tests pass, coverage maintained, API matches documentation</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `make test` - all tests pass (100+ tests)
2. `make lint` - no linter warnings
3. `make coverage` - 90%+ coverage maintained
4. Integration tests cover:
   - Complete New() -> providers -> Build() -> Run() workflow
   - Module composition with cross-module dependencies
   - Cobra integration with lifecycle hooks
   - Error aggregation (duplicates, cycles, missing deps)
   - Edge cases (empty app, idempotent build, nested commands)
</verification>

<success_criteria>
- Integration test file exists with 10+ test cases
- Tests verify complete workflows end-to-end
- Tests verify error handling for all failure modes
- Tests verify Cobra integration with nested commands
- All tests pass
- Coverage maintained at 90%+
</success_criteria>

<output>
After completion, create `.planning/phases/03-app-builder-cobra/03-04-SUMMARY.md`
</output>
