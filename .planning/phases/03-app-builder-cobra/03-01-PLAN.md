---
phase: 03-app-builder-cobra
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - container.go
  - app.go
  - errors.go
  - container_test.go
  - resolution_test.go
  - inject_test.go
  - service_test.go
  - registration_test.go
  - lifecycle_engine_test.go
  - container_graph_test.go
autonomous: true

must_haves:
  truths:
    - "Developer can create app with gaz.New()"
    - "Developer can add providers with fluent ProvideSingleton/ProvideTransient/ProvideEager"
    - "Build() validates all registrations and collects all errors with errors.Join"
    - "Late registration after Build() panics"
  artifacts:
    - path: "app.go"
      provides: "New() returning *App, provider methods, Option type"
      exports: ["New", "Option", "WithShutdownTimeout", "ProvideSingleton", "ProvideTransient", "ProvideEager", "ProvideInstance"]
    - path: "container.go"
      provides: "NewContainer() for backward compatibility"
      exports: ["NewContainer"]
    - path: "errors.go"
      provides: "Sentinel error for late registration"
      contains: "ErrAlreadyBuilt"
  key_links:
    - from: "app.go"
      to: "container.go"
      via: "App embeds *Container"
      pattern: "container.*Container"
    - from: "app.go"
      to: "registration.go"
      via: "Provider methods use For[T]()"
      pattern: "For\\[.*\\]\\(a\\.container\\)"
---

<objective>
Refactor the gaz package entry point to create a unified fluent API centered on `App` instead of separate Container and App construction.

Purpose: Enable developers to use a clean `gaz.New()` -> provider registration -> `.Build()` -> `.Run()` flow without manually managing Container construction.

Output: Working fluent API with gaz.New(opts...) returning *App, scope-specific provider methods, and error aggregation on Build().
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-app-builder-cobra/03-CONTEXT.md
@.planning/phases/03-app-builder-cobra/03-RESEARCH.md

# Existing code to refactor
@app.go
@container.go
@registration.go
@errors.go
@service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rename New() to NewContainer() and update tests</name>
  <files>container.go, container_test.go, resolution_test.go, inject_test.go, service_test.go, registration_test.go, lifecycle_engine_test.go, container_graph_test.go, app_test.go</files>
  <action>
Rename `New()` in container.go to `NewContainer()` for backward compatibility:

1. In container.go:
   - Rename `func New() *Container` to `func NewContainer() *Container`
   - Update the doc comment: "NewContainer creates a new empty Container."

2. In ALL test files, update calls from `gaz.New()` or `New()` to `NewContainer()`:
   - container_test.go
   - resolution_test.go
   - inject_test.go
   - service_test.go
   - registration_test.go
   - lifecycle_engine_test.go
   - container_graph_test.go
   - app_test.go

Run `make test` to verify all tests still pass after the rename.
  </action>
  <verify>`make test` passes with all 100+ tests</verify>
  <done>New() renamed to NewContainer(), all tests updated and passing</done>
</task>

<task type="auto">
  <name>Task 2: Create gaz.New() and fluent provider methods</name>
  <files>app.go, errors.go</files>
  <action>
Refactor app.go to create the unified fluent API:

1. Add `ErrAlreadyBuilt` sentinel error to errors.go:
```go
// ErrAlreadyBuilt is returned when attempting to register after Build() was called.
ErrAlreadyBuilt = errors.New("gaz: cannot register after Build()")
```

2. Replace `AppOption` type with `Option` type (public) in app.go:
```go
type Option func(*App)

func WithShutdownTimeout(d time.Duration) Option {
    return func(a *App) {
        a.opts.ShutdownTimeout = d
    }
}
```

3. Add new App fields:
```go
type App struct {
    container *Container
    opts      AppOptions
    built     bool         // tracks if Build() was called
    modules   map[string]bool  // tracks module names for duplicate detection

    mu      sync.Mutex
    running bool
    stopCh  chan struct{}
}
```

4. Create new `New()` function returning `*App`:
```go
func New(opts ...Option) *App {
    app := &App{
        container: NewContainer(),
        opts: AppOptions{
            ShutdownTimeout: defaultShutdownTimeout,
        },
        modules: make(map[string]bool),
    }
    for _, opt := range opts {
        opt(app)
    }
    return app
}
```

5. Add fluent provider methods (use generic helper pattern):
```go
func ProvideSingleton[T any](a *App, provider func(*Container) (T, error)) *App {
    if a.built {
        panic("gaz: cannot add providers after Build()")
    }
    // Use existing For[T]() API internally
    if err := For[T](a.container).Provider(provider); err != nil {
        // Store error for Build() to report
        // Could use a providerErrors slice
    }
    return a
}
```

**Important design notes:**
- Provider methods use panic (not error return) for late registration per RESEARCH.md recommendation
- Methods are package-level functions with generic: `ProvideSingleton[T any](a *App, ...)` because Go doesn't support generic methods
- Alternative: Non-generic method that takes `any` and uses reflection - Claude's discretion on which approach
- The simpler approach for fluent API: methods on App that take `func(*Container) (any, error)` with type name inference

Actually, for best ergonomics, implement as methods on App that use reflection to infer type from provider return type:
```go
func (a *App) ProvideSingleton(provider any) *App {
    // Extract return type via reflection
    // Register using For[T]() internally
}
```

Or use the simpler explicit type approach that matches existing For[T]():
```go
func (a *App) Provide(registration func(*Container) error) *App {
    if a.built {
        panic("gaz: cannot add providers after Build()")
    }
    if err := registration(a.container); err != nil {
        // Collect error
    }
    return a
}
// Usage: app.Provide(func(c *Container) error { return For[*MyService](c).Provider(NewMyService) })
```

**Recommended approach (per RESEARCH.md):** Use scope-specific methods that accept the provider and infer type via reflection. This provides the cleanest API:
```go
app.ProvideSingleton(NewDatabase).
    ProvideTransient(NewRequest).
    ProvideEager(NewCache)
```

Implementation: Accept `any` provider, use reflect to get return type, wrap and register.

Keep `NewApp(c *Container, opts ...AppOption)` for backward compatibility but document as deprecated.
  </action>
  <verify>`make test` passes; new code compiles with `go build ./...`</verify>
  <done>gaz.New() returns *App, provider methods accept generic providers, panic on late registration</done>
</task>

<task type="auto">
  <name>Task 3: Update Build() with validation and error aggregation</name>
  <files>app.go, app_test.go</files>
  <action>
Update App.Build() to validate all registrations and aggregate errors:

1. Add a `buildErrors []error` field to App to collect registration errors.

2. Update provider methods to collect errors instead of failing immediately:
```go
func (a *App) ProvideSingleton(provider any) *App {
    if a.built {
        panic("gaz: cannot add providers after Build()")
    }
    if err := a.registerProvider(provider, scopeSingleton, false); err != nil {
        a.buildErrors = append(a.buildErrors, err)
    }
    return a
}
```

3. Update Build() to:
   - Check for collected errors first
   - Return aggregated errors using errors.Join()
   - Set built = true only on success
   - Be idempotent (return nil if already built successfully)

```go
func (a *App) Build() error {
    a.mu.Lock()
    if a.built {
        a.mu.Unlock()
        return nil // Already built, idempotent
    }
    
    // Collect any registration errors
    var errs []error
    errs = append(errs, a.buildErrors...)
    
    // Delegate to container.Build() for eager instantiation
    if err := a.container.Build(); err != nil {
        errs = append(errs, err)
    }
    
    if len(errs) > 0 {
        a.mu.Unlock()
        return errors.Join(errs...)
    }
    
    a.built = true
    a.mu.Unlock()
    return nil
}
```

4. Add tests in app_test.go for:
   - New() creates app with defaults
   - WithShutdownTimeout option works
   - ProvideSingleton registers service
   - ProvideTransient registers transient
   - ProvideEager registers eager
   - Late registration after Build() panics
   - Build() collects all errors (register same name twice, check errors.Join output)
   - Build() is idempotent

5. Ensure existing app_test.go tests still pass (they use NewApp which is still available).
  </action>
  <verify>`make test` passes; `make lint` passes</verify>
  <done>Build() aggregates errors with errors.Join, idempotent, tests cover new API</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `make test` - all tests pass
2. `make lint` - no new linter warnings
3. `go build ./...` - compiles cleanly
4. New API works:
```go
app := gaz.New(gaz.WithShutdownTimeout(10 * time.Second))
app.ProvideSingleton(NewDatabase)
app.ProvideTransient(NewRequest)
if err := app.Build(); err != nil {
    // err contains all validation failures
}
```
</verification>

<success_criteria>
- gaz.New() returns *App (not *Container)
- NewContainer() exists for backward compatibility
- ProvideSingleton(), ProvideTransient(), ProvideEager() fluent methods exist
- Late registration after Build() panics
- Build() collects all errors with errors.Join()
- All existing tests pass
- New tests cover the fluent API
</success_criteria>

<output>
After completion, create `.planning/phases/03-app-builder-cobra/03-01-SUMMARY.md`
</output>
