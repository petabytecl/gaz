---
phase: 03-app-builder-cobra
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app_module.go
  - app_module_test.go
  - errors.go
autonomous: true

must_haves:
  truths:
    - "Developer can compose related services into named modules with app.Module()"
    - "Duplicate module names are detected and reported as errors"
    - "Modules group providers for debugging/error messages"
  artifacts:
    - path: "app_module.go"
      provides: "Module() method on App"
      exports: ["Module"]
    - path: "errors.go"
      provides: "ErrDuplicateModule sentinel error"
      contains: "ErrDuplicateModule"
    - path: "app_module_test.go"
      provides: "Tests for module functionality"
  key_links:
    - from: "app_module.go"
      to: "app.go"
      via: "Module() is method on App type"
      pattern: "func \\(a \\*App\\) Module"
    - from: "app_module.go"
      to: "registration.go"
      via: "Module registers providers via For[T]()"
      pattern: "For\\[.*\\]\\(a\\.container\\)"
---

<objective>
Add module composition to the App fluent API, allowing developers to group related providers with a name for better debugging and organization.

Purpose: Enable cleaner organization of large applications by grouping related services (e.g., "database", "http", "auth") with named modules that appear in error messages.

Output: Working Module() method that registers named groups of providers with duplicate detection.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-app-builder-cobra/03-CONTEXT.md
@.planning/phases/03-app-builder-cobra/03-RESEARCH.md
@.planning/phases/03-app-builder-cobra/03-01-SUMMARY.md

# Relevant source files
@app.go
@registration.go
@errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ErrDuplicateModule and create app_module.go</name>
  <files>errors.go, app_module.go</files>
  <action>
1. Add sentinel error to errors.go:
```go
// ErrDuplicateModule is returned when a module with the same name is registered twice.
ErrDuplicateModule = errors.New("gaz: duplicate module name")
```

2. Create app_module.go with the Module() method:

```go
package gaz

import (
    "fmt"
)

// Module registers a named group of providers.
// The name is used for debugging and error messages.
// Duplicate module names result in ErrDuplicateModule error during Build().
//
// Each provider should be a function that accepts *Container and returns
// (T, error) for some type T.
//
// Example:
//
//  app.Module("database",
//      NewConnectionPool,
//      NewUserRepository,
//      NewPostRepository,
//  ).Module("http",
//      NewRouter,
//      NewMiddleware,
//  )
func (a *App) Module(name string, providers ...any) *App {
    if a.built {
        panic("gaz: cannot add modules after Build()")
    }
    
    // Check for duplicate module name
    if a.modules[name] {
        a.buildErrors = append(a.buildErrors,
            fmt.Errorf("%w: %s", ErrDuplicateModule, name))
        return a
    }
    a.modules[name] = true
    
    // Register each provider with module context
    for _, provider := range providers {
        if err := a.registerProviderWithModule(provider, name, scopeSingleton, false); err != nil {
            a.buildErrors = append(a.buildErrors,
                fmt.Errorf("module %s: %w", name, err))
        }
    }
    
    return a
}

// registerProviderWithModule registers a provider and tags it with module name for errors.
// This is called by Module() and potentially by scope-specific module methods in the future.
func (a *App) registerProviderWithModule(provider any, moduleName string, scope serviceScope, eager bool) error {
    // Reuse the existing registerProvider logic
    // The module name is used to wrap any errors with context
    if err := a.registerProvider(provider, scope, eager); err != nil {
        return fmt.Errorf("in module %q: %w", moduleName, err)
    }
    return nil
}
```

**Note:** The `modules` map and `buildErrors` slice were added to App struct in Plan 01. If they weren't added there, add them here.

**Alternative simpler design (if reflection-based provider registration isn't in Plan 01):**
Module can accept explicit registration functions:

```go
func (a *App) Module(name string, registrations ...func(*Container) error) *App {
    if a.built {
        panic("gaz: cannot add modules after Build()")
    }
    
    if a.modules[name] {
        a.buildErrors = append(a.buildErrors,
            fmt.Errorf("%w: %s", ErrDuplicateModule, name))
        return a
    }
    a.modules[name] = true
    
    for _, reg := range registrations {
        if err := reg(a.container); err != nil {
            a.buildErrors = append(a.buildErrors,
                fmt.Errorf("module %s: %w", name, err))
        }
    }
    
    return a
}

// Usage:
// app.Module("database",
//     func(c *gaz.Container) error { return gaz.For[*DB](c).Provider(NewDB) },
//     func(c *gaz.Container) error { return gaz.For[*UserRepo](c).Provider(NewUserRepo) },
// )
```

Choose the approach that aligns with how Plan 01 implemented provider registration.
  </action>
  <verify>`go build ./...` compiles cleanly</verify>
  <done>app_module.go created with Module() method, ErrDuplicateModule added to errors.go</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for Module functionality</name>
  <files>app_module_test.go</files>
  <action>
Create app_module_test.go with comprehensive tests:

```go
package gaz

import (
    "context"
    "errors"
    "testing"
    
    "github.com/stretchr/testify/suite"
)

type ModuleSuite struct {
    suite.Suite
}

func TestModuleSuite(t *testing.T) {
    suite.Run(t, new(ModuleSuite))
}

func (s *ModuleSuite) TestModuleRegistersProviders() {
    app := New()
    
    app.Module("database",
        func(c *Container) error {
            return For[*testDB](c).ProviderFunc(func(c *Container) *testDB {
                return &testDB{name: "test"}
            })
        },
    )
    
    err := app.Build()
    s.Require().NoError(err)
    
    db, err := Resolve[*testDB](app.container)
    s.Require().NoError(err)
    s.Equal("test", db.name)
}

func (s *ModuleSuite) TestModuleDuplicateNameError() {
    app := New()
    
    app.Module("database",
        func(c *Container) error { return nil },
    ).Module("database", // Duplicate!
        func(c *Container) error { return nil },
    )
    
    err := app.Build()
    s.Require().Error(err)
    s.True(errors.Is(err, ErrDuplicateModule))
    s.Contains(err.Error(), "database")
}

func (s *ModuleSuite) TestModuleAfterBuildPanics() {
    app := New()
    s.Require().NoError(app.Build())
    
    s.Panics(func() {
        app.Module("late", func(c *Container) error { return nil })
    })
}

func (s *ModuleSuite) TestModuleErrorsAggregated() {
    app := New()
    
    // Module with a registration that will fail (duplicate type)
    app.Module("first",
        func(c *Container) error {
            return For[*testDB](c).Provider(func(c *Container) (*testDB, error) {
                return &testDB{name: "first"}, nil
            })
        },
    ).Module("second",
        func(c *Container) error {
            // This will fail - duplicate registration
            return For[*testDB](c).Provider(func(c *Container) (*testDB, error) {
                return &testDB{name: "second"}, nil
            })
        },
    )
    
    err := app.Build()
    s.Require().Error(err)
    s.Contains(err.Error(), "second") // Module name in error
}

func (s *ModuleSuite) TestModuleChaining() {
    app := New()
    
    result := app.Module("a", func(c *Container) error { return nil }).
        Module("b", func(c *Container) error { return nil }).
        Module("c", func(c *Container) error { return nil })
    
    s.Same(app, result) // Chaining returns same app
    s.Require().NoError(app.Build())
}

func (s *ModuleSuite) TestEmptyModule() {
    app := New()
    
    // Empty module is valid
    app.Module("empty")
    
    s.Require().NoError(app.Build())
    s.True(app.modules["empty"])
}

// Test helper types
type testDB struct {
    name string
}
```

Run `make test` to verify all tests pass.
  </action>
  <verify>`make test` passes; `make lint` passes</verify>
  <done>Module tests cover registration, duplicates, chaining, error aggregation</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `make test` - all tests pass
2. `make lint` - no new linter warnings
3. Module API works:
```go
app := gaz.New()
app.Module("database",
    func(c *gaz.Container) error { return gaz.For[*DB](c).Provider(NewDB) },
    func(c *gaz.Container) error { return gaz.For[*Repo](c).Provider(NewRepo) },
).Module("http",
    func(c *gaz.Container) error { return gaz.For[*Server](c).Provider(NewServer) },
)
```
4. Duplicate module names produce ErrDuplicateModule
</verification>

<success_criteria>
- Module() method exists on *App
- Module() accepts name and variadic providers
- Duplicate module names detected and collected as errors
- Module name appears in error messages for provider failures
- Late module registration after Build() panics
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-app-builder-cobra/03-02-SUMMARY.md`
</output>
