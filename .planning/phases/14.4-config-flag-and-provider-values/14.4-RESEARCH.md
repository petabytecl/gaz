# Phase 14.4: Config Flag and ProviderValues - Research

**Researched:** 2026-01-28
**Domain:** Go DI configuration lifecycle, spf13/viper, spf13/cobra
**Confidence:** HIGH

## Summary

This research addresses two related features for the gaz framework:

1. **`--config` flag** - Allow users to specify an explicit config file path via CLI flag, overriding the default search behavior
2. **ProviderValues in provider functions** - Make `ProviderValues` available inside provider functions during `Build()`, solving the current limitation where providers run before `ProviderValues` is registered

The standard approach uses viper's `SetConfigFile()` method for explicit paths and a two-phase config initialization where config is loaded early, making `ProviderValues` available before provider instantiation. The key insight is that configuration MUST be fully loaded BEFORE providers are instantiated, not after.

**Primary recommendation:** Restructure `Build()` to load config and register `ProviderValues` BEFORE collecting `ConfigProvider` metadata, enabling providers to inject `*ProviderValues` as a dependency.

## Standard Stack

This phase uses existing gaz dependencies - no new libraries needed.

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| spf13/viper | v1.19+ | Config loading backend | Already in use, provides `SetConfigFile()` |
| spf13/cobra | v1.8+ | CLI integration | Already in use for flag handling |
| spf13/pflag | v1.0+ | Flag parsing | Already in use via cobra |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| gaz/config | internal | Config manager abstraction | All config operations |
| gaz/config/viper | internal | Viper backend wrapper | Backend implementation |

**No new dependencies required.**

## Architecture Patterns

### Current Build() Flow (Problem)

```
app.Build()
├── loadConfig()                          # Config file loaded here
├── collectProviderConfigs()              # Instantiates providers (too early!)
│   ├── ResolveByName() for each service  # Providers created here
│   ├── Call ConfigNamespace()            # Gets namespace
│   ├── Call ConfigFlags()                # Gets flag definitions
│   └── registerProviderFlags()           # Sets defaults, binds env
│       └── Register ProviderValues       # ← TOO LATE! Providers already ran
├── discoverWorkers()
└── container.Build()                     # Eager services instantiated
```

**Problem:** Providers are instantiated in `collectProviderConfigs()` BEFORE `ProviderValues` is registered. When a provider function tries to resolve `*ProviderValues`, it fails with "not found".

### Recommended Build() Flow (Solution)

```
app.Build()
├── loadConfig()                          # Config file loaded (with --config flag support)
├── registerProviderValues()              # ← MOVE HERE (early registration)
│   └── pv := &ProviderValues{backend: configMgr.Backend()}
│   └── For[*ProviderValues](c).Instance(pv)
├── collectProviderConfigs()              # Now providers CAN resolve ProviderValues
│   ├── ResolveByName() for each service
│   ├── Provider can inject *ProviderValues ← NOW WORKS!
│   ├── Call ConfigNamespace()
│   └── Call ConfigFlags()
├── registerProviderFlags()               # Sets defaults, validates required
├── reloadConfigWithFlags()               # Re-read config with new flags (optional)
├── discoverWorkers()
└── container.Build()
```

### Pattern 1: Early ProviderValues Registration
**What:** Register `ProviderValues` as a singleton BEFORE any providers are instantiated
**When to use:** Always - this is the fix for the current limitation
**Example:**
```go
// In app.Build(), BEFORE collectProviderConfigs():
func (a *App) registerProviderValuesEarly() error {
    pv := &ProviderValues{backend: a.configMgr.Backend()}
    return For[*ProviderValues](a.container).Instance(pv)
}
```

### Pattern 2: SetConfigFile for Explicit Path
**What:** Use viper's `SetConfigFile()` instead of search paths when an explicit path is provided
**When to use:** When user provides `--config` flag
**Example:**
```go
// Source: spf13/viper README
v := viper.New()
v.SetConfigFile("./config.yaml")  // Explicit path with extension
if err := v.ReadInConfig(); err != nil {
    // Handle error
}
```

### Pattern 3: Cobra PersistentPreRunE for Config Flag
**What:** Define `--config` as persistent flag on root command, process in PersistentPreRunE before Build()
**When to use:** Standard pattern for cobra+viper integration
**Example:**
```go
// Source: spf13/cobra user_guide.md
var cfgFile string

func init() {
    cobra.OnInitialize(initConfig)
    rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is ./config.yaml)")
}

func initConfig() {
    if cfgFile != "" {
        viper.SetConfigFile(cfgFile)  // Use explicit path
    } else {
        viper.AddConfigPath(".")      // Use search paths
        viper.SetConfigName("config")
    }
    viper.AutomaticEnv()
    viper.ReadInConfig()
}
```

### Recommended Project Structure
```
config/
├── manager.go         # Add WithConfigFile() option
├── options.go         # Add configFile field to Manager
└── viper/
    └── backend.go     # Add SetConfigFile() method
```

### Anti-Patterns to Avoid
- **Two-phase provider instantiation:** Don't run providers twice (once for metadata, once for real). This adds complexity and potential for bugs.
- **Lazy ProviderValues:** Don't make ProviderValues lazy-initialize on first access. It breaks the explicit dependency injection model.
- **Global config state:** Don't access config via global viper instance. Always inject `*ProviderValues`.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Config file path parsing | Custom path validation | `filepath.Abs()` + viper | Viper handles file type inference from extension |
| Config flag binding | Manual flag handling | cobra PersistentFlags + viper.BindPFlag | Standard pattern, handles precedence correctly |
| Config precedence | Custom merge logic | Viper's built-in precedence | Flags > Env > File > Defaults |

**Key insight:** Viper's `SetConfigFile()` method handles explicit paths cleanly - no need to parse extensions or validate paths manually.

## Common Pitfalls

### Pitfall 1: Config Flag Processed Too Late
**What goes wrong:** `--config` flag is defined but not processed before `Build()` attempts to load config
**Why it happens:** Cobra flags are only parsed when `Execute()` is called, but gaz often does setup before that
**How to avoid:** Use `cobra.OnInitialize()` callback which runs after flag parsing but before command execution
**Warning signs:** Config file values from `--config` not being applied, or "file not found" for explicit paths

### Pitfall 2: ProviderValues Instance Replaced After Early Registration
**What goes wrong:** If `ProviderValues` is registered early, then config is reloaded, the early instance becomes stale
**Why it happens:** The backend reference doesn't change even if config values change
**How to avoid:** The viper backend already handles this - `GetString()` etc. read current values from viper, not cached values
**Warning signs:** None expected (viper reads live values)

### Pitfall 3: Circular Dependency with ConfigProvider
**What goes wrong:** A `ConfigProvider` that injects `*ProviderValues` in its constructor creates apparent cycle
**Why it happens:** `collectProviderConfigs()` resolves providers to call `ConfigFlags()`, but those providers now depend on `ProviderValues`
**How to avoid:** This is NOT a cycle because `ProviderValues` is registered as an instance (no provider function), so resolution is immediate
**Warning signs:** Cycle detection errors during build - but shouldn't occur with correct implementation

### Pitfall 4: Required Config Validation Before Values Available
**What goes wrong:** Required config flag validation runs before `ProviderValues` is registered, but needs values to validate
**Why it happens:** The two-step process: collect flags first, validate after
**How to avoid:** Register `ProviderValues` early (after `loadConfig()`), then collect flags, then validate. The backend already has all values loaded.
**Warning signs:** Validation errors for keys that ARE set in config file

## Code Examples

### Add SetConfigFile to Viper Backend
```go
// Source: based on spf13/viper API
// File: config/viper/backend.go

// SetConfigFile sets an explicit config file path.
// Unlike SetConfigName + AddConfigPath, this uses the exact file path.
// The file type is inferred from the extension.
func (b *Backend) SetConfigFile(path string) {
    b.v.SetConfigFile(path)
}
```

### Add WithConfigFile Option
```go
// Source: gaz pattern
// File: config/options.go

// WithConfigFile sets an explicit config file path.
// If set, this path is used instead of searching for config.yaml in search paths.
// The file type is inferred from the extension.
func WithConfigFile(path string) Option {
    return func(m *Manager) {
        m.configFile = path
    }
}
```

### Update Manager.Load() for Explicit Path
```go
// Source: gaz pattern  
// File: config/manager.go

func (m *Manager) Load() error {
    if m.configFile != "" {
        // Explicit config file path provided
        if vc, ok := m.backend.(interface{ SetConfigFile(string) }); ok {
            vc.SetConfigFile(m.configFile)
        }
    } else {
        // Use search paths (existing behavior)
        if vc, ok := m.backend.(viperConfigurable); ok {
            vc.SetConfigName(m.fileName)
            vc.SetConfigType(m.fileType)
            for _, path := range m.searchPaths {
                vc.AddConfigPath(path)
            }
        }
    }
    // ... rest of Load()
}
```

### Early ProviderValues Registration in App.Build()
```go
// Source: gaz pattern
// File: app.go

func (a *App) Build() error {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if a.built {
        return nil
    }
    
    var errs []error
    errs = append(errs, a.buildErrors...)
    
    // 1. Load configuration first
    if err := a.loadConfig(); err != nil {
        return err
    }
    
    // 2. Register ProviderValues EARLY (NEW!)
    pv := &ProviderValues{backend: a.configMgr.Backend()}
    if err := a.registerInstance(pv); err != nil {
        errs = append(errs, err)
    }
    
    // 3. NOW collect provider configs (providers can inject ProviderValues)
    if err := a.collectProviderConfigs(); err != nil {
        errs = append(errs, err)
    }
    
    // ... rest unchanged
}
```

### Update collectProviderConfigs to Not Register ProviderValues
```go
// Source: gaz pattern
// File: app.go

// registerProviderFlags registers collected provider flags with ConfigManager and validates.
// NOTE: ProviderValues is registered earlier in Build(), not here.
func (a *App) registerProviderFlags() error {
    if a.configMgr == nil {
        return nil
    }

    var validationErrors []error
    for _, entry := range a.providerConfigs {
        // Convert and register flags...
        if err := a.configMgr.RegisterProviderFlags(entry.namespace, cfgFlags); err != nil {
            return err
        }
        errs := a.configMgr.ValidateProviderFlags(entry.namespace, cfgFlags)
        validationErrors = append(validationErrors, errs...)
    }
    
    if len(validationErrors) > 0 {
        return errors.Join(validationErrors...)
    }
    
    // ProviderValues already registered - don't register again
    return nil
}
```

### Example Provider Using ProviderValues
```go
// Source: new pattern for Phase 14.4
// File: examples/config-loading/main.go

type ServerConfig struct {
    pv *gaz.ProviderValues
}

func (s *ServerConfig) ConfigNamespace() string { return "server" }
func (s *ServerConfig) ConfigFlags() []gaz.ConfigFlag {
    return []gaz.ConfigFlag{
        {Key: "host", Type: gaz.ConfigFlagTypeString, Default: "localhost"},
        {Key: "port", Type: gaz.ConfigFlagTypeInt, Default: 8080},
    }
}

// Provider can now inject ProviderValues!
func NewServerConfig(c *gaz.Container) (*ServerConfig, error) {
    // ProviderValues is available because it's registered before providers run
    pv, err := gaz.Resolve[*gaz.ProviderValues](c)
    if err != nil {
        return nil, err
    }
    return &ServerConfig{pv: pv}, nil
}

// Access config values via the injected ProviderValues
func (s *ServerConfig) Host() string { return s.pv.GetString("server.host") }
func (s *ServerConfig) Port() int    { return s.pv.GetInt("server.port") }
```

## State of the Art

| Old Approach (14.3) | New Approach (14.4) | Impact |
|---------------------|---------------------|--------|
| Resolve ProviderValues in main() after Build() | Inject ProviderValues in provider function | Cleaner DI, self-contained providers |
| Search paths only for config file | Support explicit `--config` flag | CLI usability, follows 12-factor |
| ProviderValues registered last in Build() | ProviderValues registered first in Build() | Enables injection into providers |

**Why this matters:**
- Phase 14.3 required users to resolve `ProviderValues` in `main()` after `Build()`, then pass values to their services
- Phase 14.4 enables the standard DI pattern: providers declare their dependencies (including `*ProviderValues`), container resolves everything
- This aligns with Uber Fx pattern where config is just another provided dependency

## Open Questions

1. **Should config be reloaded after flag registration?**
   - What we know: ConfigProvider flags may introduce new defaults. Viper's `SetDefault()` doesn't require reload.
   - What's unclear: Are there edge cases where registered flags need a config re-read?
   - Recommendation: Don't reload. Viper defaults are set via `SetDefault()` which doesn't require re-reading the file.

2. **Should WithCobra handle --config flag automatically?**
   - What we know: The cobra example doesn't currently use gaz's config at all
   - What's unclear: Whether gaz should add --config to cobra commands automatically
   - Recommendation: Let planner decide - could be opt-in via `WithConfigFlag()` on the app

## Sources

### Primary (HIGH confidence)
- spf13/viper Context7 - SetConfigFile, ReadInConfig, precedence
- spf13/cobra Context7 - PersistentFlags, OnInitialize pattern
- gaz codebase - app.go, provider_config.go, config/manager.go

### Secondary (MEDIUM confidence)
- Google Search - Uber Fx config injection pattern (verified with fx docs)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - uses existing dependencies
- Architecture: HIGH - based on codebase analysis and proven patterns
- Pitfalls: HIGH - derived from understanding current limitation

**Research date:** 2026-01-28
**Valid until:** 60 days (stable patterns, internal changes only)
