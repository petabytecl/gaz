---
phase: 14.4-config-flag-and-provider-values
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config/manager.go
  - config/options.go
  - config/viper/backend.go
  - app.go
  - examples/config-loading/main.go
autonomous: true

must_haves:
  truths:
    - "WithConfigFile option sets explicit config file path"
    - "ProviderValues can be injected inside provider functions"
    - "Example demonstrates ProviderValues injection in provider"
  artifacts:
    - path: "config/options.go"
      provides: "WithConfigFile option"
      contains: "WithConfigFile"
    - path: "config/viper/backend.go"
      provides: "SetConfigFile method"
      contains: "SetConfigFile"
    - path: "config/manager.go"
      provides: "configFile field and Load() handling"
      contains: "configFile"
    - path: "app.go"
      provides: "Early ProviderValues registration in Build()"
      contains: "registerProviderValuesEarly"
    - path: "examples/config-loading/main.go"
      provides: "Example with ProviderValues in provider"
      contains: "Resolve.*ProviderValues"
  key_links:
    - from: "config/manager.go"
      to: "config/viper/backend.go"
      via: "SetConfigFile interface check"
      pattern: "SetConfigFile\\(m\\.configFile\\)"
    - from: "app.go"
      to: "collectProviderConfigs"
      via: "ProviderValues registered BEFORE collectProviderConfigs"
      pattern: "registerProviderValuesEarly.*collectProviderConfigs"
---

<objective>
Add `--config` flag support and enable ProviderValues injection inside provider functions.

Purpose: This unlocks the standard DI pattern where providers can inject `*ProviderValues` as a dependency, rather than resolving it in main() after Build(). Also adds CLI flexibility via explicit config file path.

Output: Updated config package with `WithConfigFile()` option, refactored Build() flow with early ProviderValues registration, and updated example demonstrating the new pattern.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14.4-config-flag-and-provider-values/14.4-RESEARCH.md
@.planning/phases/14.3-flag-based-config-registration/14.3-01-SUMMARY.md

# Key source files
@config/manager.go
@config/options.go
@config/viper/backend.go
@app.go
@examples/config-loading/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add config file path support to config package</name>
  <files>
    config/manager.go
    config/options.go
    config/viper/backend.go
  </files>
  <action>
1. **config/options.go** - Add `WithConfigFile()` option:
```go
// WithConfigFile sets an explicit config file path.
// If set, this path is used instead of searching for config files in search paths.
// The file type is inferred from the extension.
func WithConfigFile(path string) Option {
    return func(m *Manager) {
        m.configFile = path
    }
}
```

2. **config/manager.go** - Add `configFile` field to Manager struct:
```go
type Manager struct {
    backend     Backend
    fileName    string
    fileType    string
    searchPaths []string
    envPrefix   string
    profileEnv  string
    defaults    map[string]any
    configFile  string  // NEW: explicit config file path
}
```

3. **config/manager.go** - Update `Load()` to handle explicit path:
- If `m.configFile != ""`, use `SetConfigFile()` interface method
- Otherwise use existing search path logic
- Add internal interface `configFileSetter` for `SetConfigFile(string)` method

```go
// configFileSetter is implemented by backends that support explicit config file paths.
type configFileSetter interface {
    SetConfigFile(path string)
}

func (m *Manager) Load() error {
    // NEW: Handle explicit config file path
    if m.configFile != "" {
        if cfs, ok := m.backend.(configFileSetter); ok {
            cfs.SetConfigFile(m.configFile)
        }
    } else {
        // Existing search path logic
        if vc, ok := m.backend.(viperConfigurable); ok {
            vc.SetConfigName(m.fileName)
            vc.SetConfigType(m.fileType)
            for _, path := range m.searchPaths {
                vc.AddConfigPath(path)
            }
        }
    }
    // ... rest unchanged
}
```

4. **config/viper/backend.go** - Add `SetConfigFile()` method:
```go
// SetConfigFile sets an explicit config file path.
// Unlike SetConfigName + AddConfigPath, this uses the exact file path.
// The file type is inferred from the extension.
func (b *Backend) SetConfigFile(path string) {
    b.v.SetConfigFile(path)
}
```
  </action>
  <verify>
Run tests:
```bash
go test ./config/... -v
```
All existing tests should pass. The new functionality is configuration-only (no behavior change for existing code).
  </verify>
  <done>
- `WithConfigFile(path string)` option exists in config/options.go
- Manager struct has `configFile` field
- `Load()` checks for explicit path before using search paths
- ViperBackend has `SetConfigFile()` method
- All config tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Move ProviderValues registration earlier in Build() and update example</name>
  <files>
    app.go
    examples/config-loading/main.go
  </files>
  <action>
1. **app.go** - Create `registerProviderValuesEarly()` method:
```go
// registerProviderValuesEarly registers ProviderValues as an instance
// immediately after config loading, BEFORE providers are instantiated.
// This allows providers to inject *ProviderValues as a dependency.
func (a *App) registerProviderValuesEarly() error {
    if a.configMgr == nil {
        return nil
    }
    pv := &ProviderValues{backend: a.configMgr.Backend()}
    return a.registerInstance(pv)
}
```

2. **app.go** - Update `Build()` to call `registerProviderValuesEarly()` AFTER `loadConfig()` but BEFORE `collectProviderConfigs()`:
```go
func (a *App) Build() error {
    // ...existing mutex and idempotent check...

    // 1. Load configuration first
    if err := a.loadConfig(); err != nil {
        return err
    }

    // 2. Register ProviderValues EARLY (NEW!)
    if err := a.registerProviderValuesEarly(); err != nil {
        errs = append(errs, err)
    }

    // 3. NOW collect provider configs (providers can inject ProviderValues)
    if err := a.collectProviderConfigs(); err != nil {
        errs = append(errs, err)
    }
    // ... rest unchanged
}
```

3. **app.go** - Update `registerProviderFlags()` to NOT register ProviderValues (it's already registered):
- Remove the last two lines that create and register ProviderValues
- Method should now only register flags and validate

4. **examples/config-loading/main.go** - Update to demonstrate ProviderValues injection in provider:
- Modify `ServerConfig` struct to hold `*gaz.ProviderValues`
- Update `NewServerConfig` to inject ProviderValues and store it
- Add accessor methods `Host()`, `Port()`, `Debug()` on ServerConfig
- Update main() to use the accessor methods instead of resolving ProviderValues separately
- Add comments explaining the new pattern

```go
// ServerConfig implements ConfigProvider and stores injected ProviderValues.
type ServerConfig struct {
    pv *gaz.ProviderValues
}

// NewServerConfig injects ProviderValues during Build().
// This is now possible because ProviderValues is registered BEFORE providers run.
func NewServerConfig(c *gaz.Container) (*ServerConfig, error) {
    pv, err := gaz.Resolve[*gaz.ProviderValues](c)
    if err != nil {
        return nil, err
    }
    return &ServerConfig{pv: pv}, nil
}

// Accessor methods using the injected ProviderValues
func (s *ServerConfig) Host() string { return s.pv.GetString("server.host") }
func (s *ServerConfig) Port() int    { return s.pv.GetInt("server.port") }
func (s *ServerConfig) Debug() bool  { return s.pv.GetBool("server.debug") }
```

Update main() to use these accessors instead of resolving ProviderValues directly.
  </action>
  <verify>
1. Run all tests:
```bash
go test ./... -v
```

2. Run the example to verify it works:
```bash
cd examples/config-loading && go run main.go
```
Should show config values loaded correctly.

3. Test with explicit config file (verifies Task 1 wiring works end-to-end):
```bash
cd examples/config-loading && go run main.go
# Should work with default config.yaml
```
  </verify>
  <done>
- `registerProviderValuesEarly()` method exists in app.go
- `Build()` calls `registerProviderValuesEarly()` after `loadConfig()` and before `collectProviderConfigs()`
- `registerProviderFlags()` no longer registers ProviderValues
- Example demonstrates ProviderValues injection inside the provider function
- All tests pass
- Example runs successfully
  </done>
</task>

</tasks>

<verification>
Run full test suite to ensure no regressions:
```bash
go test ./... -v -count=1
```

Verify example works:
```bash
cd examples/config-loading && go run main.go
```

Expected output:
```
Configuration loaded via ConfigProvider pattern:
  Server: localhost:8080
  Debug:  false
...
```
</verification>

<success_criteria>
1. `WithConfigFile(path string)` option available in config package
2. ViperBackend has `SetConfigFile()` method
3. Manager.Load() uses explicit path when configFile is set
4. ProviderValues is registered BEFORE providers are instantiated in Build()
5. Example demonstrates injecting ProviderValues in provider function
6. All existing tests pass
7. Example runs successfully with the new pattern
</success_criteria>

<output>
After completion, create `.planning/phases/14.4-config-flag-and-provider-values/14.4-01-SUMMARY.md`
</output>
