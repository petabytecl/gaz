---
phase: 14.3-flag-based-config-registration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/config-loading/main.go
  - examples/config-loading/config.yaml
autonomous: true

must_haves:
  truths:
    - "Example demonstrates ConfigProvider interface pattern"
    - "Service declares config requirements via ConfigFlags()"
    - "Service fetches config via ProviderValues in constructor"
    - "Example runs successfully showing configured values"
  artifacts:
    - path: "examples/config-loading/main.go"
      provides: "ConfigProvider pattern demonstration"
      contains: "ConfigNamespace"
      min_lines: 50
    - path: "examples/config-loading/config.yaml"
      provides: "Config file matching flag-based pattern"
      contains: "server:"
  key_links:
    - from: "examples/config-loading/main.go"
      to: "gaz.ConfigProvider"
      via: "interface implementation"
      pattern: "ConfigFlags.*\\[\\]gaz\\.ConfigFlag"
    - from: "examples/config-loading/main.go"
      to: "gaz.ProviderValues"
      via: "MustResolve in constructor"
      pattern: "MustResolve\\[\\*gaz\\.ProviderValues\\]"
---

<objective>
Rewrite the config-loading example to demonstrate the ConfigProvider flag-based pattern instead of generic struct loading.

Purpose: Remove the deprecated struct-loading pattern from examples and show the recommended ConfigProvider approach where services declare their config requirements via ConfigFlags() and fetch values via ProviderValues in their constructor.

Output: Updated example that demonstrates the modern flag-based configuration pattern.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14.3-flag-based-config-registration/14.3-RESEARCH.md

# Key source files
@provider_config.go
@examples/config-loading/main.go
@examples/config-loading/config.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite main.go to use ConfigProvider pattern</name>
  <files>examples/config-loading/main.go</files>
  <action>
Rewrite the config-loading example to demonstrate the ConfigProvider pattern:

1. Create a `ServerConfig` struct that holds config values (host, port, debug):
   ```go
   type ServerConfig struct {
       host  string
       port  int
       debug bool
   }
   ```

2. Implement `ConfigProvider` interface on `ServerConfig`:
   - `ConfigNamespace() string` returns "server"
   - `ConfigFlags() []gaz.ConfigFlag` returns flags for host (string, default "localhost"), port (int, default 8080), and debug (bool, default false)

3. Create `NewServerConfig(c *gaz.Container) (*ServerConfig, error)` constructor:
   - Resolve `*gaz.ProviderValues` via `gaz.MustResolve`
   - Fetch values via `pv.GetString("server.host")`, `pv.GetInt("server.port")`, `pv.GetBool("server.debug")`
   - Return populated `ServerConfig`

4. Update `main()` function:
   - Create app with `gaz.New()`
   - Call `app.WithConfig(&struct{}{}, config.WithName("config"), config.WithSearchPaths("."))` - empty struct just enables ConfigManager
   - Register service via `gaz.For[*ServerConfig](app.Container()).Provider(NewServerConfig)`
   - Call `app.Build()` with error handling
   - Resolve `*ServerConfig` and print values

5. Update package comment to reflect ConfigProvider pattern.

Key points:
- NO generic struct loading (`&Config{}` receiving values)
- Empty struct passed to WithConfig() just enables ConfigManager
- ConfigFlags declare requirements, ProviderValues fetches values
- Full config key is "namespace.key" format (e.g., "server.host")
  </action>
  <verify>
Run the example and verify it compiles and outputs config values:
```bash
cd examples/config-loading && go run main.go
```
Expected output should show server host, port, and debug values.
  </verify>
  <done>
main.go demonstrates ConfigProvider pattern with:
- ServerConfig implementing ConfigProvider interface
- Constructor fetching via ProviderValues
- No generic struct loading pattern
- Example compiles and runs successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Update config.yaml and verify example</name>
  <files>examples/config-loading/config.yaml</files>
  <action>
Update config.yaml to match the flag-based pattern:

1. Keep same structure but ensure keys match ConfigFlags:
   ```yaml
   server:
     host: localhost
     port: 8080
   debug: true
   ```

2. Note: The "debug" key is at root level, but our ServerConfig has namespace "server".
   
   For consistency, move debug under server namespace:
   ```yaml
   server:
     host: localhost
     port: 8080
     debug: true
   ```

3. Update main.go ConfigFlags to include debug under server namespace:
   - Key: "debug", Type: ConfigFlagTypeBool, Default: false
   - Access via: pv.GetBool("server.debug")

4. Run example with config file and verify values are read:
   ```bash
   cd examples/config-loading && go run main.go
   ```

5. Test with environment variables override:
   ```bash
   SERVER_HOST=0.0.0.0 SERVER_PORT=9000 go run main.go
   ```
   Verify env vars override config file values.
  </action>
  <verify>
```bash
cd examples/config-loading && go run main.go
# Should output: Server: localhost:8080, Debug: true

# Test env var override
cd examples/config-loading && SERVER_HOST=0.0.0.0 SERVER_PORT=9000 go run main.go
# Should output: Server: 0.0.0.0:9000, Debug: true
```
  </verify>
  <done>
config.yaml matches flag-based pattern with all keys under server namespace.
Example runs successfully with both file and env var config sources.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Example compiles without errors:
   ```bash
   cd examples/config-loading && go build .
   ```

2. Example runs and shows config values:
   ```bash
   cd examples/config-loading && go run main.go
   ```

3. Environment variables override config file:
   ```bash
   cd examples/config-loading && SERVER_HOST=0.0.0.0 go run main.go
   ```

4. All project tests still pass:
   ```bash
   make test
   ```

5. No generic struct loading pattern remains in examples:
   ```bash
   grep -r "cfg := &Config{}" examples/
   # Should return no results
   ```
</verification>

<success_criteria>
- [ ] main.go uses ConfigProvider interface pattern
- [ ] ServerConfig implements ConfigNamespace() and ConfigFlags()
- [ ] Constructor uses ProviderValues.GetString/GetInt/GetBool
- [ ] No generic struct loading pattern in example
- [ ] config.yaml keys match ConfigFlags declarations
- [ ] Example runs successfully with config file
- [ ] Example works with env var overrides
- [ ] All project tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14.3-flag-based-config-registration/14.3-01-SUMMARY.md`
</output>
