---
phase: 14.3-flag-based-config-registration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/config-loading/main.go
  - examples/config-loading/config.yaml
autonomous: true

must_haves:
  truths:
    - "Example demonstrates ConfigProvider interface pattern"
    - "Service declares config requirements via ConfigFlags()"
    - "ProviderValues is resolved in main() AFTER Build() completes"
    - "Example runs successfully showing configured values"
  artifacts:
    - path: "examples/config-loading/main.go"
      provides: "ConfigProvider pattern demonstration"
      contains: "ConfigNamespace"
      min_lines: 50
    - path: "examples/config-loading/config.yaml"
      provides: "Config file matching flag-based pattern"
      contains: "server:"
  key_links:
    - from: "examples/config-loading/main.go"
      to: "gaz.ConfigProvider"
      via: "interface implementation"
      pattern: "ConfigFlags.*\\[\\]gaz\\.ConfigFlag"
    - from: "examples/config-loading/main.go"
      to: "gaz.ProviderValues"
      via: "MustResolve after Build()"
      pattern: "app\\.Build.*MustResolve\\[\\*gaz\\.ProviderValues\\]"
---

<objective>
Rewrite the config-loading example to demonstrate the ConfigProvider flag-based pattern instead of generic struct loading.

Purpose: Remove the deprecated struct-loading pattern from examples and show the recommended ConfigProvider approach where services declare their config requirements via ConfigFlags() and values are accessed via ProviderValues AFTER Build() completes.

Output: Updated example that demonstrates the modern flag-based configuration pattern.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14.3-flag-based-config-registration/14.3-RESEARCH.md

# Key source files
@provider_config.go
@examples/config-loading/main.go
@examples/config-loading/config.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite main.go to use ConfigProvider pattern</name>
  <files>examples/config-loading/main.go</files>
  <action>
Rewrite the config-loading example to demonstrate the ConfigProvider pattern.

**CRITICAL: Framework execution order constraint:**
- `collectProviderConfigs()` instantiates ConfigProviders BEFORE ProviderValues is registered
- Therefore ConfigProvider constructors CANNOT resolve ProviderValues
- Solution: Simple ConfigProvider constructor + resolve ProviderValues in main() AFTER Build()

1. Create `ServerConfig` struct that implements ConfigProvider with SIMPLE constructor:
   ```go
   // ServerConfig declares config flags but does NOT hold values
   type ServerConfig struct{}
   
   func (s *ServerConfig) ConfigNamespace() string { return "server" }
   
   func (s *ServerConfig) ConfigFlags() []gaz.ConfigFlag {
       return []gaz.ConfigFlag{
           {Key: "host", Type: gaz.ConfigFlagTypeString, Default: "localhost", Description: "Server host"},
           {Key: "port", Type: gaz.ConfigFlagTypeInt, Default: 8080, Description: "Server port"},
           {Key: "debug", Type: gaz.ConfigFlagTypeBool, Default: false, Description: "Debug mode"},
       }
   }
   
   // Simple constructor - NO ProviderValues resolution here
   func NewServerConfig(c *gaz.Container) (*ServerConfig, error) {
       return &ServerConfig{}, nil
   }
   ```

2. Update `main()` function to resolve ProviderValues AFTER Build():
   ```go
   func main() {
       app := gaz.New()
       
       // Enable config manager
       app.WithConfig(&struct{}{}, config.WithName("config"), config.WithSearchPaths("."))
       
       // Register ConfigProvider
       gaz.For[*ServerConfig](app.Container()).Provider(NewServerConfig)
       
       // Build - this collects ConfigFlags, loads config, registers ProviderValues
       if err := app.Build(); err != nil {
           log.Fatal(err)
       }
       
       // NOW we can resolve ProviderValues (after Build completed)
       pv := gaz.MustResolve[*gaz.ProviderValues](app.Container())
       
       // Access config values using namespace.key format
       host := pv.GetString("server.host")
       port := pv.GetInt("server.port")
       debug := pv.GetBool("server.debug")
       
       fmt.Printf("Server: %s:%d\n", host, port)
       fmt.Printf("Debug: %v\n", debug)
   }
   ```

3. Update package comment to reflect ConfigProvider pattern.

Key points:
- ConfigProvider declares requirements via ConfigFlags()
- ConfigProvider constructor is SIMPLE - no ProviderValues resolution
- ProviderValues is resolved in main() AFTER app.Build() completes
- Full config key is "namespace.key" format (e.g., "server.host")
  </action>
  <verify>
Run the example and verify it compiles and outputs config values:
```bash
cd examples/config-loading && go run main.go
```
Expected output should show server host, port, and debug values.
  </verify>
  <done>
main.go demonstrates ConfigProvider pattern with:
- ServerConfig implementing ConfigProvider interface with simple constructor
- ProviderValues resolved in main() AFTER Build() completes
- No generic struct loading pattern
- Example compiles and runs successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Update config.yaml and verify example</name>
  <files>examples/config-loading/config.yaml</files>
  <action>
Update config.yaml to match the flag-based pattern:

1. Keep same structure but ensure keys match ConfigFlags:
   ```yaml
   server:
     host: localhost
     port: 8080
   debug: true
   ```

2. Note: The "debug" key is at root level, but our ServerConfig has namespace "server".
   
   For consistency, move debug under server namespace:
   ```yaml
   server:
     host: localhost
     port: 8080
     debug: true
   ```

3. Update main.go ConfigFlags to include debug under server namespace:
   - Key: "debug", Type: ConfigFlagTypeBool, Default: false
   - Access via: pv.GetBool("server.debug")

4. Run example with config file and verify values are read:
   ```bash
   cd examples/config-loading && go run main.go
   ```

5. Test with environment variables override:
   ```bash
   SERVER_HOST=0.0.0.0 SERVER_PORT=9000 go run main.go
   ```
   Verify env vars override config file values.
  </action>
  <verify>
```bash
cd examples/config-loading && go run main.go
# Should output: Server: localhost:8080, Debug: true

# Test env var override
cd examples/config-loading && SERVER_HOST=0.0.0.0 SERVER_PORT=9000 go run main.go
# Should output: Server: 0.0.0.0:9000, Debug: true
```
  </verify>
  <done>
config.yaml matches flag-based pattern with all keys under server namespace.
Example runs successfully with both file and env var config sources.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Example compiles without errors:
   ```bash
   cd examples/config-loading && go build .
   ```

2. Example runs and shows config values:
   ```bash
   cd examples/config-loading && go run main.go
   ```

3. Environment variables override config file:
   ```bash
   cd examples/config-loading && SERVER_HOST=0.0.0.0 go run main.go
   ```

4. All project tests still pass:
   ```bash
   make test
   ```

5. No generic struct loading pattern remains in examples:
   ```bash
   grep -r "cfg := &Config{}" examples/
   # Should return no results
   ```
</verification>

<success_criteria>
- [ ] main.go uses ConfigProvider interface pattern
- [ ] ServerConfig implements ConfigNamespace() and ConfigFlags()
- [ ] ServerConfig constructor is simple (no ProviderValues resolution)
- [ ] ProviderValues is resolved in main() AFTER Build() completes
- [ ] No generic struct loading pattern in example
- [ ] config.yaml keys match ConfigFlags declarations
- [ ] Example runs successfully with config file
- [ ] Example works with env var overrides
- [ ] All project tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14.3-flag-based-config-registration/14.3-01-SUMMARY.md`
</output>
