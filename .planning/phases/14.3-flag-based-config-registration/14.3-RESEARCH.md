# Phase 14.3: Flag-Based Config Registration - Research

**Researched:** 2026-01-28
**Domain:** Internal refactoring - Go config patterns, viper-based configuration, provider config registration
**Confidence:** HIGH

## Summary

This phase refactors the gaz configuration pattern from generic struct-based loading (`app.WithConfig(cfg)`) to a flag-based pattern where providers/services declare their config requirements via `ConfigFlags()` and fetch values in their constructor via `ProviderValues`.

The research is straightforward as the codebase **already implements** the flag-based config infrastructure. The key files are:
- `provider_config.go` - Defines `ConfigProvider` interface, `ConfigFlag`, `ProviderValues`
- `app.go` - `collectProviderConfigs()` collects flags, `registerProviderFlags()` sets defaults and validates
- `config/manager.go` - `RegisterProviderFlags()` and `ValidateProviderFlags()` methods

The refactoring removes the `app.WithConfig(cfg, ...)` pattern from examples and instead demonstrates the `ConfigProvider` interface pattern. This is a **cleanup/documentation phase**, not new feature development.

**Primary recommendation:** Update `examples/config-loading/main.go` to use `ConfigProvider` interface instead of struct loading. Remove or deprecate the generic struct loading pattern from documentation. No new code required - just example/doc updates.

## Current Pattern (to be removed)

The current pattern in `examples/config-loading/main.go`:

```go
// Create config struct that will receive loaded values
cfg := &Config{}

// Create app with configuration
app := gaz.New()

// WithConfig sets up configuration loading
app.WithConfig(cfg,
    config.WithName("config"),
    config.WithSearchPaths("."),
    config.WithEnvPrefix("APP"),
)

// Build triggers config loading and validation
if err := app.Build(); err != nil {
    log.Fatalf("Failed to load config: %v", err)
}

// Config is now populated
fmt.Printf("Server: %s:%d\n", cfg.Server.Host, cfg.Server.Port)
```

**Problems with this pattern:**
1. Requires a pre-declared struct that mirrors the config file structure
2. Couples application code to config file schema
3. Does not leverage `ProviderValues` pattern already in codebase
4. Inconsistent with `ConfigProvider` interface designed for providers

## New Pattern (flag-based)

The new pattern uses the existing `ConfigProvider` interface:

```go
// Service declares its config requirements via ConfigProvider interface
type DatabaseService struct {
    host     string
    port     int
    password string
}

func (s *DatabaseService) ConfigNamespace() string {
    return "database"
}

func (s *DatabaseService) ConfigFlags() []gaz.ConfigFlag {
    return []gaz.ConfigFlag{
        {Key: "host", Type: gaz.ConfigFlagTypeString, Default: "localhost"},
        {Key: "port", Type: gaz.ConfigFlagTypeInt, Default: 5432},
        {Key: "password", Type: gaz.ConfigFlagTypeString, Required: true},
    }
}

// Provider fetches config values in constructor
func NewDatabaseService(c *gaz.Container) (*DatabaseService, error) {
    pv := gaz.MustResolve[*gaz.ProviderValues](c)
    
    return &DatabaseService{
        host:     pv.GetString("database.host"),
        port:     pv.GetInt("database.port"),
        password: pv.GetString("database.password"),
    }, nil
}
```

**App setup is minimal:**

```go
app := gaz.New().
    WithConfig(&struct{}{}, config.WithEnvPrefix("APP")) // Empty struct just to enable config manager

gaz.For[*DatabaseService](app.Container()).Provider(NewDatabaseService)

if err := app.Build(); err != nil {
    log.Fatal(err)
}
```

## Standard Stack

This is internal refactoring - no new libraries needed.

### Already in Codebase
| Component | Location | Purpose |
|-----------|----------|---------|
| `ConfigProvider` interface | `provider_config.go:96` | Providers declare config requirements |
| `ConfigFlag` struct | `provider_config.go:44` | Describes a config key with type, default, required |
| `ProviderValues` | `provider_config.go:118` | Provides typed access to config values |
| `RegisterProviderFlags()` | `config/manager.go:292` | Registers defaults and binds env vars |
| `ValidateProviderFlags()` | `config/manager.go:314` | Validates required flags are set |

### Config Flag Types
| Type | Constant | Use |
|------|----------|-----|
| String | `ConfigFlagTypeString` | Text values |
| Int | `ConfigFlagTypeInt` | Numeric values |
| Bool | `ConfigFlagTypeBool` | Feature flags |
| Duration | `ConfigFlagTypeDuration` | Timeouts, intervals |
| Float | `ConfigFlagTypeFloat` | Rates, ratios |

## Architecture Patterns

### Pattern 1: ConfigProvider Interface
**What:** Services implement `ConfigProvider` to declare config requirements
**When to use:** Any service that needs configuration
**Example:**
```go
// Source: provider_config.go existing implementation
type ConfigProvider interface {
    ConfigNamespace() string       // e.g., "redis"
    ConfigFlags() []gaz.ConfigFlag // config requirements
}
```

### Pattern 2: Constructor-Based Config Fetching
**What:** Provider functions resolve `ProviderValues` and fetch config in constructor
**When to use:** All services needing config values
**Example:**
```go
// Source: provider_config.go ProviderValues documentation
func NewRedisClient(c *gaz.Container) (*RedisClient, error) {
    pv := gaz.MustResolve[*gaz.ProviderValues](c)
    host := pv.GetString("redis.host")
    port := pv.GetInt("redis.port")
    return &RedisClient{Host: host, Port: port}, nil
}
```

### Pattern 3: Empty Struct for Config Manager
**What:** Pass empty struct to `WithConfig()` to enable `ConfigManager` without generic loading
**When to use:** When only using flag-based config (not file-to-struct loading)
**Example:**
```go
// Enable config manager without loading into a struct
app := gaz.New().
    WithConfig(&struct{}{}, config.WithEnvPrefix("APP"))
```

### Pattern 4: Scoped Namespaces
**What:** Each service uses a unique namespace prefix for its config keys
**When to use:** To avoid key collisions between services
**Example:**
```go
// redis.host, redis.port
func (r *RedisService) ConfigNamespace() string { return "redis" }

// cache.ttl, cache.enabled  
func (c *CacheService) ConfigNamespace() string { return "cache" }
```

### Anti-Patterns to Avoid
- **Global config struct:** Don't define one giant struct for all app config
- **Direct viper access:** Use `ProviderValues` abstraction, not raw viper calls
- **Hardcoded env var names:** Let the framework handle PREFIX_KEY translation

## Don't Hand-Roll

This phase doesn't add new functionality - it removes code. The infrastructure is already built.

| Problem | Already Exists | Location |
|---------|---------------|----------|
| Config flag declaration | `ConfigFlag` struct | `provider_config.go:44` |
| Typed value access | `ProviderValues` | `provider_config.go:118` |
| Env var binding | `RegisterProviderFlags()` | `config/manager.go:292` |
| Required validation | `ValidateProviderFlags()` | `config/manager.go:314` |
| Key collision detection | `collectProviderConfigs()` | `app.go:240` |

**Key insight:** The codebase already has the flag-based config system. This phase just removes the alternative struct-loading pattern from examples and promotes the flag-based pattern.

## Common Pitfalls

### Pitfall 1: Forgetting to Enable ConfigManager
**What goes wrong:** `ProviderValues` not registered, resolve fails
**Why it happens:** App created without `WithConfig()` call
**How to avoid:** Always call `WithConfig(&struct{}{})` even with empty struct
**Warning signs:** `ErrNotFound` when resolving `*ProviderValues`

### Pitfall 2: Missing Namespace Prefix
**What goes wrong:** Config keys collide between services
**Why it happens:** Two services return same namespace or forget to namespace
**How to avoid:** Use service-specific namespace (e.g., "database", "redis", "auth")
**Warning signs:** `ErrConfigKeyCollision` at Build() time

### Pitfall 3: Required Fields Without Env Vars
**What goes wrong:** Build fails with "required config key not set"
**Why it happens:** Required flag declared but no default and no env var set
**How to avoid:** Set env vars or provide defaults; document required vars
**Warning signs:** Validation errors during `app.Build()`

### Pitfall 4: Resolving ProviderValues Before Build
**What goes wrong:** ProviderValues not yet registered
**Why it happens:** Calling resolve in registration instead of in provider
**How to avoid:** Always fetch in provider function, not during For[T]() call
**Warning signs:** Panic or nil pointer during registration

### Pitfall 5: Wrong Key Path in GetString
**What goes wrong:** Returns empty string instead of configured value
**Why it happens:** Key path doesn't match namespace.key format
**How to avoid:** Use full key: `pv.GetString("namespace.key")` not `pv.GetString("key")`
**Warning signs:** Default values always returned despite env vars being set

## Code Examples

### Complete Example: Minimal Config-Aware Service
```go
// Source: Synthesis from provider_config_test.go patterns

package main

import (
    "fmt"
    "log"

    "github.com/petabytecl/gaz"
    "github.com/petabytecl/gaz/config"
)

// ServerConfig is a config-aware service
type ServerConfig struct {
    host string
    port int
}

// ConfigNamespace prefixes all keys with "server"
func (s *ServerConfig) ConfigNamespace() string {
    return "server"
}

// ConfigFlags declares what config this service needs
func (s *ServerConfig) ConfigFlags() []gaz.ConfigFlag {
    return []gaz.ConfigFlag{
        {Key: "host", Type: gaz.ConfigFlagTypeString, Default: "localhost"},
        {Key: "port", Type: gaz.ConfigFlagTypeInt, Default: 8080},
    }
}

// NewServerConfig fetches config values in constructor
func NewServerConfig(c *gaz.Container) (*ServerConfig, error) {
    pv := gaz.MustResolve[*gaz.ProviderValues](c)
    return &ServerConfig{
        host: pv.GetString("server.host"),
        port: pv.GetInt("server.port"),
    }, nil
}

func main() {
    // Enable config manager (empty struct just enables the system)
    app := gaz.New().
        WithConfig(&struct{}{}, config.WithEnvPrefix("APP"))

    // Register config-aware service
    if err := gaz.For[*ServerConfig](app.Container()).Provider(NewServerConfig); err != nil {
        log.Fatal(err)
    }

    // Build validates required configs and populates defaults
    if err := app.Build(); err != nil {
        log.Fatal(err)
    }

    // Resolve and use
    srv := gaz.MustResolve[*ServerConfig](app.Container())
    fmt.Printf("Server: %s:%d\n", srv.host, srv.port)
}
```

### Environment Variable Mapping
```go
// Source: config/manager.go:303 - env key translation

// ConfigFlag with key "host" in namespace "database" becomes:
// - Config key: "database.host"
// - Env var:    DATABASE_HOST (uppercase, dots become underscores)

// With APP prefix via WithEnvPrefix("APP"):
// - Still reads: DATABASE_HOST (prefix affects struct binding, not provider flags)
```

### Required Config Validation
```go
// Source: provider_config_test.go:209

type SecureService struct{}

func (s *SecureService) ConfigNamespace() string { return "auth" }

func (s *SecureService) ConfigFlags() []gaz.ConfigFlag {
    return []gaz.ConfigFlag{
        {Key: "api_key", Type: gaz.ConfigFlagTypeString, Required: true},
    }
}

// If AUTH_API_KEY is not set, app.Build() returns:
// "provider \"auth\": required config key \"auth.api_key\" is not set"
```

## Files to Modify

### Must Change
| File | Change |
|------|--------|
| `examples/config-loading/main.go` | Rewrite to use `ConfigProvider` pattern |
| `examples/config-loading/config.yaml` | Update to match new key structure |

### May Change (depending on scope)
| File | Possible Change |
|------|-----------------|
| Other examples using `WithConfig(cfg, ...)` | Update if they exist |
| `doc.go` or root documentation | Update config pattern examples |

### Do Not Change
| File | Reason |
|------|--------|
| `app.go` | `WithConfig()` is still needed to enable ConfigManager |
| `config/manager.go` | No changes needed - infrastructure is complete |
| `provider_config.go` | No changes needed - interface is complete |

## State of the Art

This is internal refactoring based on decisions already made for gaz v2.0.

| Old Pattern | New Pattern | Reason |
|-------------|-------------|--------|
| Generic struct loading | Flag-based ConfigProvider | More explicit, better for modular services |
| Direct config struct access | ProviderValues accessor | Decouples services from config file schema |
| Centralized config struct | Per-service ConfigFlags | Better separation of concerns |

## Open Questions

Things that need decisions during planning:

1. **Keep or Remove `WithConfig(cfg)` for struct loading?**
   - What we know: The struct loading still works
   - What's unclear: Should we deprecate it or keep both patterns?
   - Recommendation: Keep `WithConfig()` but use empty struct in examples to show flag pattern

2. **Example Scope**
   - What we know: `examples/config-loading/main.go` needs update
   - What's unclear: Are there other examples using struct pattern?
   - Recommendation: Check all examples during planning

3. **Config File Support**
   - What we know: Config files still work with flag pattern (viper backend reads them)
   - What's unclear: Should example include config file or just env vars?
   - Recommendation: Show both file and env var sources in example

## Sources

### Primary (HIGH confidence)
- Existing codebase: `provider_config.go`, `app.go`, `config/manager.go`
- Existing tests: `provider_config_test.go` - comprehensive coverage of flag pattern
- Existing documentation: `provider_config.go` comments

### Secondary (MEDIUM confidence)
- Prior phase research: `14-RESEARCH.md` - worker patterns use similar DI patterns

### Tertiary (LOW confidence)
- None - this is entirely internal refactoring based on existing code

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all code already exists in codebase
- Architecture: HIGH - patterns documented in existing code
- Pitfalls: HIGH - based on actual test cases in `provider_config_test.go`

**Research date:** 2026-01-28
**Valid until:** 2026-03-28 (60 days - stable internal refactoring)
