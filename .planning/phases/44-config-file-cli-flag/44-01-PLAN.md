---
phase: 44-config-file-cli-flag
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config/module/module.go
  - config/module/doc.go
  - config/module/module_test.go
  - app.go
autonomous: true

must_haves:
  truths:
    - "User can pass --config /path/to/config.yaml to specify config file"
    - "If --config is not provided, auto-search for config.* in cwd and XDG dirs"
    - "If --config is provided but file doesn't exist, app exits with error"
    - "If config file has invalid syntax, app exits with parse error"
    - "CLI flags > env vars > config file > defaults precedence is maintained"
  artifacts:
    - path: "config/module/module.go"
      provides: "Config module with --config flag"
      exports: ["New"]
    - path: "config/module/module_test.go"
      provides: "Tests for config module"
  key_links:
    - from: "config/module/module.go"
      to: "app.go:loadConfig()"
      via: "loadConfig() called during Build()"
      pattern: "applyConfigFlags"
---

<objective>
Add `--config` CLI flag to specify config file path, with auto-search when not provided.

Purpose: Allow users to specify a custom config file path via CLI, or use auto-discovery when no path is given.
Output: `config/module` package with CLI flag, integration with App.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/44-config-file-cli-flag/44-CONTEXT.md

Reference files:
- config/options.go — has WithConfigFile(path string) Option already (read-only reference)
- config/manager.go — handles configFile field in Load()
- logger/module/module.go — pattern to follow for module with flags
- app.go — where config is initialized, applyConfigFlags() to be added
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config/module package with --config flag</name>
  <files>config/module/module.go, config/module/doc.go</files>
  <action>
Create `config/module/` package following `logger/module` pattern:

1. Create `config/module/doc.go`:
```go
// Package module provides the gaz.Module for configuration CLI flags.
package module
```

2. Create `config/module/module.go` with:
- `Config` struct with fields:
  - `ConfigFile string` — explicit config file path (from --config flag)
  - `EnvPrefix string` — environment variable prefix (from --env-prefix flag, default "GAZ")
  - `Strict bool` — enable strict validation of unknown keys (from --config-strict flag)
- `DefaultConfig()` returning sensible defaults (empty ConfigFile, "GAZ" prefix, strict=true per CONTEXT.md)
- `Flags(fs *pflag.FlagSet)` method registering:
  - `--config` — Config file path (optional)
  - `--env-prefix` — Environment variable prefix (default: GAZ)
  - `--config-strict` — Exit on unknown config keys (default: true)
- `New() gaz.Module` function that:
  - Creates module with Flags() registration
  - Provides `config.Config` (rename to ConfigOptions to avoid stutter) for App to consume
  - Registers config file path, env prefix, and strict mode with App

Note: Do NOT use logger/module as a 1:1 template - config needs different integration:
- Config affects App.configMgr initialization, not just provider resolution
- Need PersistentPreRunE timing (before Build()) to apply config file path

Alternative simpler approach (PREFERRED):
- Just register the flag and store the value
- In the provider, read the flag value and apply it to the config manager
- App already supports `WithConfig(target, ...config.Option)` which takes `config.WithConfigFile(path)`

Implementation:
```go
package module

import (
    "os"
    "path/filepath"

    "github.com/spf13/pflag"

    "github.com/petabytecl/gaz"
    "github.com/petabytecl/gaz/config"
)

// Options holds configuration for the config module.
type Options struct {
    ConfigFile string
    EnvPrefix  string
    Strict     bool
}

// DefaultOptions returns options with sensible defaults.
func DefaultOptions() Options {
    return Options{
        ConfigFile: "",       // Auto-search if empty
        EnvPrefix:  "GAZ",    // Default prefix
        Strict:     true,     // Exit on unknown keys per CONTEXT.md
    }
}

// Flags registers CLI flags for configuration.
func (o *Options) Flags(fs *pflag.FlagSet) {
    fs.StringVar(&o.ConfigFile, "config", o.ConfigFile,
        "Config file path (auto-searches if not set)")
    fs.StringVar(&o.EnvPrefix, "env-prefix", o.EnvPrefix,
        "Environment variable prefix")
    fs.BoolVar(&o.Strict, "config-strict", o.Strict,
        "Exit on unknown config keys")
}

// New creates a config module that provides configuration CLI flags.
func New() gaz.Module {
    opts := DefaultOptions()
    
    return gaz.NewModule("config").
        Flags(opts.Flags).
        Provide(func(c *gaz.Container) error {
            return gaz.For[Options](c).Provider(func(_ *gaz.Container) (Options, error) {
                return opts, nil
            })
        }).
        Build()
}
```

Key decisions from CONTEXT.md to implement:
- Flag is optional — app runs without config file
- Flag name: `--config` (no short flag)
- When not provided: auto-search cwd, then XDG config dir
- Default filename: `config.*` (any supported extension)
- If --config provided but missing: exit with error
- If no --config and nothing found: silent continue
- Strict mode by default (exit on unknown keys)
  </action>
  <verify>
`go build ./config/module/...` succeeds.
`go test ./config/module/...` runs (tests in Task 2).
  </verify>
  <done>
`config/module` package exists with Options struct, Flags method, and New() function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate config module with App initialization</name>
  <files>app.go</files>
  <action>
Modify `App.loadConfig()` to consume config module flags if registered:

Add new function `applyConfigFlags()` called at the start of `loadConfig()`:

1. Check if config module flags are registered (flags.Lookup("config") != nil)
2. If --config flag is provided with a path:
   - Validate file exists (return error if not found)
   - Recreate config manager with config.WithConfigFile(path)
3. If --config flag is NOT provided (auto-search mode):
   - Build search paths: current directory first
   - Add XDG config directory: $XDG_CONFIG_HOME/{appname} or ~/.config/{appname}
   - Derive appname from cobra.Command.Root().Name()
   - Recreate config manager with config.WithSearchPaths(paths...)
4. Apply --env-prefix flag via config.WithEnvPrefix()
5. Apply --config-strict flag to a.strictConfig field

Key implementation: Read flag values from a.cobraCmd.Flags() since cobra parses flags before PersistentPreRunE calls Build().

1. In `loadConfig()`, after the existing config loading logic, check if `config/module.Options` is registered:
```go
// Check for config module options
if opts, err := Resolve[module.Options](a.container); err == nil {
    // Apply config file path if specified
    if opts.ConfigFile != "" {
        // Recreate config manager with explicit file path
        a.configMgr = config.New(
            config.WithBackend(cfgviper.New()),
            config.WithConfigFile(opts.ConfigFile),
            config.WithEnvPrefix(opts.EnvPrefix),
        )
    }
    // Apply strict mode
    a.strictConfig = opts.Strict
}
```

WAIT - this approach has a problem: `loadConfig()` is called before providers are resolved.
The module flags are bound to cobra flags, which are parsed by the time `bootstrap()` runs.
But `loadConfig()` is called in `Build()`, and module providers aren't resolved until then.

Better approach - check for config module Options BEFORE loadConfig():

Actually, the simplest approach is:
1. Config module registers Options as an instance (not provider) so it's available immediately
2. In `Build()`, check for Options and recreate configMgr if needed BEFORE loadConfig()

Wait, that won't work either because instances are registered during module Apply, not during flags parsing.

The correct flow needs to be:
1. Flag values are parsed by cobra BEFORE PersistentPreRunE
2. PersistentPreRunE calls bootstrap() which calls Build()
3. Build() calls loadConfig()

So flag values ARE available when loadConfig() is called. The issue is the module provides Options via a Provider, which means we need to resolve it.

But we can't resolve providers before Build() completes...

SIMPLER SOLUTION:
Don't use a module pattern. Instead:
1. Add `configFileFlag` field to App
2. Add `WithConfigFlag()` option that registers --config flag
3. In loadConfig(), check if flag was provided and apply it

Actually, even simpler following CONTEXT.md exactly:
- Create a module that just registers the flag and stores the value
- App checks for the flag value in loadConfig() via command flags

Let me trace the actual flow:
1. `gaz.New(WithCobra(cmd))` - stores cobra command, applies flag functions
2. Module.Apply() registers flags via `app.AddFlagsFn()`
3. `cmd.Execute()` parses flags
4. `PersistentPreRunE` → `bootstrap()` → `Build()` → `loadConfig()`

At step 4, flags ARE parsed. We can read flag values directly from cobra command.

IMPLEMENTATION:
In `loadConfig()`, check if --config flag exists and has a value:
```go
func (a *App) loadConfig() error {
    if a.configLoaded {
        return nil
    }
    
    // Check for --config flag value if cobra command is attached
    if a.cobraCmd != nil {
        if configPath, _ := a.cobraCmd.Flags().GetString("config"); configPath != "" {
            // Validate file exists
            if _, err := os.Stat(configPath); err != nil {
                return fmt.Errorf("config file not found: %s", configPath)
            }
            // Recreate config manager with explicit file
            a.configMgr = config.New(
                config.WithBackend(cfgviper.New()),
                config.WithConfigFile(configPath),
            )
        }
    }
    // ... rest of existing loadConfig
}
```

But wait - this requires the flag to be registered somewhere. The config module registers it.

Final approach:
1. `config/module.New()` registers `--config`, `--env-prefix`, `--config-strict` flags
2. In `App.loadConfig()`, read these flags from `a.cobraCmd.Flags()` if cobra is attached
3. Apply values to config manager

Actually, re-reading CONTEXT.md more carefully:
- When `--config` NOT provided: auto-search cwd, then `~/.config/appname/`
- Search locations should use XDG dirs

For auto-search, we need to add search paths. Modify the implementation:

```go
// In loadConfig(), after checking for explicit --config:
if a.cobraCmd != nil {
    flags := a.cobraCmd.Flags()
    
    // Get --config value
    configPath, _ := flags.GetString("config")
    if configPath != "" {
        // Explicit path provided - validate and use
        if _, err := os.Stat(configPath); err != nil {
            return fmt.Errorf("config: file not found: %s", configPath)
        }
        a.configMgr = config.New(
            config.WithBackend(cfgviper.New()),
            config.WithConfigFile(configPath),
        )
    } else if flags.Changed("config") == false {
        // --config not provided: add XDG paths to search
        xdgConfig := os.Getenv("XDG_CONFIG_HOME")
        if xdgConfig == "" {
            home, _ := os.UserHomeDir()
            xdgConfig = filepath.Join(home, ".config")
        }
        appName := a.cobraCmd.Root().Name()
        a.configMgr = config.New(
            config.WithBackend(cfgviper.New()),
            config.WithSearchPaths(".", filepath.Join(xdgConfig, appName)),
        )
    }
    
    // Get --env-prefix value
    if envPrefix, _ := flags.GetString("env-prefix"); envPrefix != "" {
        // Need to apply this... but WithEnvPrefix is an Option, not a method
        // This requires recreating the manager again or having a setter
    }
    
    // Get --config-strict value
    if strict, _ := flags.GetBool("config-strict"); strict {
        a.strictConfig = true
    }
}
```

This is getting complex. The issue is config manager options are set at construction time.

CLEANER APPROACH:
Instead of trying to apply options after construction, have the config module provide configuration options that App uses when constructing the manager.

1. Config module stores flag values in a struct
2. App.loadConfig() resolves this struct and uses it to construct config manager

But again, resolution requires Build() which calls loadConfig()...

ACTUALLY CLEANEST:
Add a hook mechanism. Config module registers a "pre-config" hook that runs before loadConfig().

Wait, I'm overcomplicating this. Let me look at how logger module works:

Logger module registers flags directly on the Config struct. When Build() runs, it resolves `logger.Config` which has the flag values already bound.

We can do the same for config:
1. Create `config.Options` struct with fields for config file, env prefix, strict mode
2. Register flags on this struct
3. App.Build() resolves `config.Options` and applies to config manager

But the problem is App.Build() already created the config manager in `New()`.

SOLUTION: Delay config manager creation until Build()

Current flow:
- `New()` creates configMgr with defaults
- `Build()` calls loadConfig() which uses configMgr

New flow:
- `New()` stores config options but doesn't create manager
- `Build()` creates configMgr using resolved options, then calls loadConfig()

This is a bigger refactor but cleaner.

Actually, looking at app.go again:
- `WithConfig(target, ...config.Option)` already allows passing options
- These options are applied by recreating the manager

So the pattern exists. The issue is we want CLI flags to influence these options.

FINAL IMPLEMENTATION PLAN:
1. Config module registers flags on an Options struct
2. App gains `configOpts []config.Option` field
3. Config module's provider appends options based on flag values
4. Before loadConfig(), resolve config module options and apply them

Let me simplify even further:

Since config manager has `WithConfigFile(path)` option already, we just need:
1. Register --config flag that stores path in App
2. In loadConfig(), if path is set, use WithConfigFile

Add field to App:
```go
configFilePath string  // from --config flag
```

Add method:
```go
func (a *App) SetConfigFile(path string) {
    a.configFilePath = path
}
```

Config module calls this via a hook.

Actually, let's just do the simplest thing that works:

1. Add `App.configFilePath` field
2. Add `App.envPrefix` field  
3. In config module, use `Provide()` to set these fields via container access
4. In loadConfig(), use these fields when creating the manager

Wait, we can't access App from within a provider...

OK, let me step back. The logger module pattern works because:
- Logger is created AFTER modules are applied
- Logger config is resolved from container

Config manager is created BEFORE modules are applied (in `New()`).

The fix is to delay config manager creation:
1. In `New()`, just store options (don't create manager yet)
2. In `Build()`, create config manager using stored options + resolved module options

Let me implement this properly:

**Changes to app.go:**

1. Add field `pendingConfigOpts []config.Option`
2. In `New()`, don't create configMgr, just store default options
3. Add `func (a *App) AddConfigOption(opt config.Option)` method
4. In `Build()`, create configMgr before loadConfig() using all stored options

**Changes to config/module:**

1. Create module with flags
2. In `Provide()`, add config options based on flag values:
```go
return gaz.NewModule("config").
    Flags(opts.Flags).
    Provide(func(c *gaz.Container) error {
        app := // how to get app?
    }).
    Build()
```

Problem: We can't get App from container easily.

ALTERNATIVE: Use a callback pattern
```go
type ConfigCallback func(opts Options)

func New(callback ConfigCallback) gaz.Module {
    opts := DefaultOptions()
    return gaz.NewModule("config").
        Flags(opts.Flags).
        OnApply(func(app *gaz.App) error {
            callback(opts)
            return nil
        }).
        Build()
}
```

But Module interface doesn't have OnApply with App access...

Let me check module.go:

Module interface has `Apply(app *App) error`. 

So we CAN access App in Apply! The pattern is:
1. Module.Apply() is called with *App
2. We can store values directly on App

So config module can do:
```go
func (m *configModule) Apply(app *gaz.App) error {
    // Apply flags
    app.AddFlagsFn(m.opts.Flags)
    
    // Register a provider that runs after flags are parsed
    // to apply config options to the app
    // ...
}
```

But flags are parsed by Cobra AFTER Apply() runs. So in Apply() we don't have flag values yet.

Correct timing:
1. `gaz.New(WithCobra(cmd))` - stores cmd
2. `app.Use(config/module.New())` - module.Apply() called, flags registered
3. User runs `cmd.Execute()`
4. Cobra parses flags
5. `PersistentPreRunE` → `bootstrap()`
6. `bootstrap()` calls `Build()`
7. `Build()` calls `loadConfig()`

At step 7, flag values ARE available. We can read them from `a.cobraCmd`.

So the simplest implementation:
1. Config module just registers the flags
2. App.loadConfig() reads the flags and applies them

No need for complex hooks or providers.

**Final Implementation:**

config/module/module.go:
```go
package module

import (
    "github.com/spf13/pflag"
    "github.com/petabytecl/gaz"
)

// New creates a config module that registers CLI flags for configuration.
// 
// Flags registered:
//   --config         Config file path (if not set, auto-searches)
//   --env-prefix     Environment variable prefix (default: GAZ)
//   --config-strict  Exit on unknown config keys (default: true)
func New() gaz.Module {
    return gaz.NewModule("config").
        Flags(func(fs *pflag.FlagSet) {
            fs.String("config", "", "Config file path (auto-searches cwd and XDG dirs if not set)")
            fs.String("env-prefix", "GAZ", "Environment variable prefix for config binding")
            fs.Bool("config-strict", true, "Exit on unknown configuration keys (catches typos)")
        }).
        Build()
}
```

app.go changes in loadConfig():
```go
func (a *App) loadConfig() error {
    if a.configLoaded {
        return nil
    }
    if a.configMgr == nil {
        return nil
    }
    
    // Apply config module flags if cobra is attached
    if a.cobraCmd != nil {
        if err := a.applyConfigFlags(); err != nil {
            return err
        }
    }
    
    // Rest of existing loadConfig()...
}

func (a *App) applyConfigFlags() error {
    flags := a.cobraCmd.Flags()
    
    // Check for --config flag
    configPath, err := flags.GetString("config")
    if err == nil && configPath != "" {
        // Explicit config file - validate exists
        if _, statErr := os.Stat(configPath); statErr != nil {
            return fmt.Errorf("config: file not found: %s", configPath)
        }
        // Recreate manager with explicit file
        a.configMgr = config.New(
            config.WithBackend(cfgviper.New()),
            config.WithConfigFile(configPath),
        )
    } else if err == nil && !flags.Changed("config") {
        // --config not provided: set up auto-search with XDG
        xdgConfig := os.Getenv("XDG_CONFIG_HOME")
        if xdgConfig == "" {
            if home, homeErr := os.UserHomeDir(); homeErr == nil {
                xdgConfig = filepath.Join(home, ".config")
            }
        }
        if xdgConfig != "" {
            appName := a.cobraCmd.Root().Name()
            searchPaths := []string{".", filepath.Join(xdgConfig, appName)}
            a.configMgr = config.New(
                config.WithBackend(cfgviper.New()),
                config.WithSearchPaths(searchPaths...),
            )
        }
    }
    
    // Check for --env-prefix flag
    if envPrefix, err := flags.GetString("env-prefix"); err == nil && envPrefix != "" {
        // Need to recreate with env prefix...
        // This is getting unwieldy - we're recreating the manager multiple times
    }
    
    // Check for --config-strict flag
    if strict, err := flags.GetBool("config-strict"); err == nil {
        a.strictConfig = strict
    }
    
    return nil
}
```

This is still messy because we might recreate the manager multiple times.

CLEANER: Collect all flags first, then create manager once:

```go
func (a *App) applyConfigFlags() error {
    if a.cobraCmd == nil {
        return nil
    }
    
    flags := a.cobraCmd.Flags()
    
    var opts []config.Option
    opts = append(opts, config.WithBackend(cfgviper.New()))
    
    // --config flag
    configPath, err := flags.GetString("config")
    if err != nil {
        // Flag not registered, skip
        return nil
    }
    
    if configPath != "" {
        // Explicit config file - validate exists
        if _, statErr := os.Stat(configPath); statErr != nil {
            return fmt.Errorf("config: file not found: %s", configPath)
        }
        opts = append(opts, config.WithConfigFile(configPath))
    } else {
        // Auto-search: cwd first, then XDG
        xdgConfig := os.Getenv("XDG_CONFIG_HOME")
        if xdgConfig == "" {
            if home, homeErr := os.UserHomeDir(); homeErr == nil {
                xdgConfig = filepath.Join(home, ".config")
            }
        }
        searchPaths := []string{"."}
        if xdgConfig != "" {
            appName := a.cobraCmd.Root().Name()
            searchPaths = append(searchPaths, filepath.Join(xdgConfig, appName))
        }
        opts = append(opts, config.WithSearchPaths(searchPaths...))
    }
    
    // --env-prefix flag
    if envPrefix, envErr := flags.GetString("env-prefix"); envErr == nil && envPrefix != "" {
        opts = append(opts, config.WithEnvPrefix(envPrefix))
    }
    
    // --config-strict flag
    if strict, strictErr := flags.GetBool("config-strict"); strictErr == nil {
        a.strictConfig = strict
    }
    
    // Recreate config manager with collected options
    a.configMgr = config.New(opts...)
    
    return nil
}
```

This is cleaner. Call this at the START of loadConfig() before any config loading.

Actually, I realize we should only do this if the config module is being used. Otherwise we'd overwrite user's WithConfig() settings.

Detection: Check if --config flag exists on cobra command.

Updated:
```go
func (a *App) applyConfigFlags() error {
    if a.cobraCmd == nil {
        return nil
    }
    
    flags := a.cobraCmd.Flags()
    
    // Only apply if config module registered flags
    if flags.Lookup("config") == nil {
        return nil
    }
    
    // ... rest of implementation
}
```

This is the implementation to put in app.go.
  </action>
  <verify>
`go test ./...` passes.
Test manually:
1. `go run ./examples/grpc-gateway --config nonexistent.yaml` should error
2. `go run ./examples/grpc-gateway` (no --config) should run (auto-search)
  </verify>
  <done>
App.loadConfig() reads --config, --env-prefix, --config-strict flags and applies them.
Config manager is recreated with appropriate options.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for config module</name>
  <files>config/module/module_test.go</files>
  <action>
Create comprehensive tests for the config module:

1. Test flag registration:
   - Verify --config, --env-prefix, --config-strict flags are registered
   - Verify default values

2. Test integration with App:
   - Test explicit --config path that exists
   - Test explicit --config path that doesn't exist (should error)
   - Test auto-search behavior
   - Test --env-prefix applies to config manager
   - Test --config-strict=true causes error on unknown keys
   - Test --config-strict=false allows unknown keys

Use testify suite pattern per AGENTS.md.

Test structure:
```go
package module_test

import (
    "os"
    "path/filepath"
    "testing"
    
    "github.com/spf13/cobra"
    "github.com/stretchr/testify/suite"
    
    "github.com/petabytecl/gaz"
    configmod "github.com/petabytecl/gaz/config/module"
)

type ConfigModuleSuite struct {
    suite.Suite
    tempDir string
}

func TestConfigModuleSuite(t *testing.T) {
    suite.Run(t, new(ConfigModuleSuite))
}

func (s *ConfigModuleSuite) SetupTest() {
    var err error
    s.tempDir, err = os.MkdirTemp("", "config-module-test-*")
    s.Require().NoError(err)
}

func (s *ConfigModuleSuite) TearDownTest() {
    os.RemoveAll(s.tempDir)
}

func (s *ConfigModuleSuite) TestFlagsRegistered() {
    cmd := &cobra.Command{Use: "test"}
    app := gaz.New(gaz.WithCobra(cmd))
    app.Use(configmod.New())
    
    s.NotNil(cmd.Flags().Lookup("config"))
    s.NotNil(cmd.Flags().Lookup("env-prefix"))
    s.NotNil(cmd.Flags().Lookup("config-strict"))
}

func (s *ConfigModuleSuite) TestExplicitConfigFileExists() {
    // Create temp config file
    configPath := filepath.Join(s.tempDir, "app.yaml")
    s.Require().NoError(os.WriteFile(configPath, []byte("key: value"), 0644))
    
    cmd := &cobra.Command{Use: "test", RunE: func(cmd *cobra.Command, args []string) error {
        return nil
    }}
    app := gaz.New(gaz.WithCobra(cmd))
    app.Use(configmod.New())
    
    cmd.SetArgs([]string{"--config", configPath})
    err := cmd.Execute()
    s.NoError(err)
}

func (s *ConfigModuleSuite) TestExplicitConfigFileNotExists() {
    cmd := &cobra.Command{Use: "test", RunE: func(cmd *cobra.Command, args []string) error {
        return nil
    }}
    app := gaz.New(gaz.WithCobra(cmd))
    app.Use(configmod.New())
    
    cmd.SetArgs([]string{"--config", "/nonexistent/config.yaml"})
    err := cmd.Execute()
    s.Error(err)
    s.Contains(err.Error(), "not found")
}

// ... more tests
```
  </action>
  <verify>
`go test -race -v ./config/module/...` passes.
`make cover` shows >90% coverage for config/module.
  </verify>
  <done>
Tests cover flag registration, explicit config path, missing config error, and strict mode.
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
make test
make lint
```

Manual verification:
1. Build example app with config module
2. Test --config with valid file
3. Test --config with invalid file (should error)
4. Test without --config (should auto-search)
5. Test --config-strict=false with unknown keys in config
</verification>

<success_criteria>
- [ ] `config/module` package created with flags
- [ ] App.loadConfig() applies config module flags
- [ ] --config /path/to/file.yaml uses explicit file
- [ ] --config with non-existent file returns error
- [ ] No --config triggers auto-search (cwd, XDG)
- [ ] --env-prefix sets environment variable prefix
- [ ] --config-strict controls unknown key behavior
- [ ] Tests pass with >90% coverage
- [ ] Lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/44-config-file-cli-flag/44-01-SUMMARY.md`
</output>
