---
phase: 32-backoff-package
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backoff/doc.go
  - backoff/backoff.go
  - backoff/exponential.go
  - backoff/backoff_test.go
  - backoff/exponential_test.go
autonomous: true

must_haves:
  truths:
    - "BackOff interface exists with NextBackOff() and Reset() methods"
    - "Stop constant (-1) signals no more retries"
    - "ExponentialBackOff increases delays exponentially with configurable parameters"
    - "Overflow protection clamps to MaxInterval (no negative durations)"
    - "Jitter is thread-safe using math/rand/v2"
  artifacts:
    - path: "backoff/backoff.go"
      provides: "BackOff interface, Stop constant, simple backoffs (Zero, Stop, Constant)"
      exports: ["BackOff", "Stop", "ZeroBackOff", "StopBackOff", "ConstantBackOff", "NewConstantBackOff"]
    - path: "backoff/exponential.go"
      provides: "ExponentialBackOff with functional options and overflow protection"
      exports: ["ExponentialBackOff", "NewExponentialBackOff", "Clock", "WithInitialInterval", "WithMaxInterval", "WithMultiplier", "WithRandomizationFactor", "WithMaxElapsedTime", "WithClock"]
  key_links:
    - from: "backoff/exponential.go"
      to: "backoff/backoff.go"
      via: "implements BackOff interface"
      pattern: "func.*NextBackOff.*time\\.Duration"
---

<objective>
Create the core backoff package with BackOff interface, Stop sentinel, simple backoff types, and ExponentialBackOff with functional options.

Purpose: Establish the foundation for internal backoff functionality that will replace jpillora/backoff dependency.
Output: `backoff/` package with interface, simple types, and ExponentialBackOff implementation.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/32-backoff-package/32-RESEARCH.md

Reference implementation:
@_tmp_trust/srex/backoff/backoff.go
@_tmp_trust/srex/backoff/exponential.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backoff package with interface and simple types</name>
  <files>backoff/doc.go, backoff/backoff.go, backoff/backoff_test.go</files>
  <action>
Create the `backoff/` package with core types adapted from the reference implementation:

1. Create `backoff/doc.go` with package documentation explaining the backoff package purpose (exponential backoff for retry logic).

2. Create `backoff/backoff.go` with:
   - `Stop` constant: `const Stop time.Duration = -1` (signals no more retries)
   - `BackOff` interface with `NextBackOff() time.Duration` and `Reset()` methods
   - `ZeroBackOff` struct (returns 0, no delay)
   - `StopBackOff` struct (returns Stop immediately)
   - `ConstantBackOff` struct with `Delay` field
   - `NewConstantBackOff(delay time.Duration) *ConstantBackOff` constructor
   - Interface compliance assertions: `var _ BackOff = (*ZeroBackOff)(nil)` etc.

3. Create `backoff/backoff_test.go` with tests:
   - Test Stop constant equals -1
   - Test ZeroBackOff.NextBackOff() returns 0
   - Test StopBackOff.NextBackOff() returns Stop
   - Test ConstantBackOff.NextBackOff() returns configured delay
   - Test Reset() methods don't panic

Adapt from reference `_tmp_trust/srex/backoff/backoff.go` with gaz conventions.
  </action>
  <verify>`go test ./backoff/... -run "TestZero|TestStop|TestConstant" -v` passes</verify>
  <done>BackOff interface, Stop constant, and simple backoff types exist with passing tests</done>
</task>

<task type="auto">
  <name>Task 2: Create ExponentialBackOff with functional options</name>
  <files>backoff/exponential.go, backoff/exponential_test.go</files>
  <action>
Create ExponentialBackOff adapted from reference, with gaz-style functional options:

1. Create `backoff/exponential.go` with:
   - Default constants (use worker-appropriate defaults):
     - `DefaultInitialInterval = 1 * time.Second` (not 100ms - matches worker use case)
     - `DefaultRandomizationFactor = 0.5`
     - `DefaultMultiplier = 2.0` (not 1.5 - matches worker use case)
     - `DefaultMaxInterval = 5 * time.Minute`
     - `DefaultMaxElapsedTime = 0` (disabled by default - worker controls via circuit breaker)
   
   - `Clock` interface: `Now() time.Time`
   - `systemClock` struct implementing Clock
   - `SystemClock` variable of type `systemClock`
   
   - `ExponentialBackOff` struct with fields:
     - `InitialInterval`, `MaxInterval`, `Multiplier`, `RandomizationFactor`, `MaxElapsedTime`
     - `Clock Clock`
     - `Stop time.Duration` (copy of Stop constant)
     - `startTime time.Time`, `currentInterval time.Duration`
   
   - `Option func(*ExponentialBackOff)` type for functional options
   
   - `NewExponentialBackOff(opts ...Option) *ExponentialBackOff` constructor:
     - Apply defaults, apply options, call Reset()
   
   - Functional option functions (validate inputs):
     - `WithInitialInterval(d time.Duration) Option`
     - `WithMaxInterval(d time.Duration) Option`
     - `WithMultiplier(m float64) Option`
     - `WithRandomizationFactor(f float64) Option`
     - `WithMaxElapsedTime(d time.Duration) Option`
     - `WithClock(c Clock) Option`
   
   - `Reset()` method: sets currentInterval = InitialInterval, startTime = Clock.Now()
   
   - `NextBackOff()` method:
     - Calculate randomized interval using `math/rand/v2.Float64()` (thread-safe)
     - Increment currentInterval with overflow protection:
       ```go
       if float64(b.currentInterval) >= float64(b.MaxInterval)/b.Multiplier {
           b.currentInterval = b.MaxInterval
       } else {
           b.currentInterval = time.Duration(float64(b.currentInterval) * b.Multiplier)
       }
       ```
     - Check MaxElapsedTime (if > 0 and elapsed + next > MaxElapsedTime, return Stop)
     - Return randomized interval
   
   - `GetElapsedTime() time.Duration` method
   
   - `getRandomValueFromInterval(randomizationFactor, random float64, currentInterval time.Duration) time.Duration` helper

CRITICAL: Use `math/rand/v2` not `math/rand` - top-level functions in v2 are thread-safe without explicit seeding.

2. Create `backoff/exponential_test.go` with tests:
   - Test NewExponentialBackOff() returns correct defaults
   - Test functional options apply correctly
   - Test NextBackOff() increases with each call (within expected range)
   - Test Reset() resets to initial interval
   - Test overflow protection (large multiplier doesn't exceed MaxInterval)
   - Test MaxElapsedTime stops after elapsed time
   - Test zero RandomizationFactor returns exact currentInterval
  </action>
  <verify>`go test ./backoff/... -v` passes with no race conditions (`go test -race ./backoff/...`)</verify>
  <done>ExponentialBackOff with functional options, overflow protection, and thread-safe jitter exists with comprehensive tests</done>
</task>

</tasks>

<verification>
```bash
# All backoff tests pass
go test ./backoff/... -v

# No race conditions
go test -race ./backoff/...

# Verify interface compliance
go build ./backoff/...
```
</verification>

<success_criteria>
- [ ] `backoff/` package compiles without errors
- [ ] BackOff interface defined with NextBackOff() and Reset()
- [ ] Stop constant equals -1
- [ ] ZeroBackOff, StopBackOff, ConstantBackOff implement BackOff
- [ ] ExponentialBackOff uses functional options (NewExponentialBackOff(opts...))
- [ ] ExponentialBackOff uses math/rand/v2 for thread-safe jitter
- [ ] Overflow protection clamps to MaxInterval
- [ ] All tests pass including race detector
</success_criteria>

<output>
After completion, create `.planning/phases/32-backoff-package/32-01-SUMMARY.md`
</output>
