---
phase: 32-backoff-package
plan: 02
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - backoff/timer.go
  - backoff/context.go
  - backoff/tries.go
  - backoff/retry.go
  - backoff/ticker.go
  - backoff/context_test.go
  - backoff/tries_test.go
  - backoff/retry_test.go
  - backoff/ticker_test.go
autonomous: true

must_haves:
  truths:
    - "WithContext() wrapper stops backoff when context is cancelled"
    - "WithMaxRetries() wrapper returns Stop after N attempts"
    - "Retry() executes operation until success or backoff stops"
    - "PermanentError stops retry immediately without retrying"
    - "Ticker delivers ticks at backoff intervals"
  artifacts:
    - path: "backoff/timer.go"
      provides: "Timer interface for testing abstractions"
      exports: ["Timer"]
    - path: "backoff/context.go"
      provides: "Context-aware backoff wrapper"
      exports: ["Context", "WithContext"]
    - path: "backoff/tries.go"
      provides: "Max retries wrapper"
      exports: ["WithMaxRetries"]
    - path: "backoff/retry.go"
      provides: "Retry helpers and PermanentError"
      exports: ["Operation", "OperationWithData", "Notify", "PermanentError", "Permanent", "Retry", "RetryWithData", "RetryNotify", "RetryNotifyWithData"]
    - path: "backoff/ticker.go"
      provides: "Periodic backoff-based ticker"
      exports: ["Ticker", "NewTicker", "NewTickerWithTimer"]
  key_links:
    - from: "backoff/context.go"
      to: "backoff/backoff.go"
      via: "embeds BackOff interface"
      pattern: "BackOff"
    - from: "backoff/retry.go"
      to: "backoff/timer.go"
      via: "uses Timer for testable sleeps"
      pattern: "Timer"
---

<objective>
Add wrappers (Context, MaxRetries), retry helpers (Retry, RetryNotify, PermanentError), and Ticker for complete backoff toolkit.

Purpose: Provide the full backoff toolkit matching the reference implementation capabilities.
Output: Context-aware wrappers, retry functions, and ticker for periodic operations.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-backoff-package/32-RESEARCH.md
@.planning/phases/32-backoff-package/32-01-SUMMARY.md

Reference implementation:
@_tmp_trust/srex/backoff/timer.go
@_tmp_trust/srex/backoff/context.go
@_tmp_trust/srex/backoff/tries.go
@_tmp_trust/srex/backoff/retry.go
@_tmp_trust/srex/backoff/ticker.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Timer, Context wrapper, and MaxRetries wrapper</name>
  <files>backoff/timer.go, backoff/context.go, backoff/tries.go, backoff/context_test.go, backoff/tries_test.go</files>
  <action>
Create timer abstraction and wrapper types adapted from reference:

1. Create `backoff/timer.go`:
   - `Timer` interface with `Start(duration time.Duration)`, `Stop()`, `C() <-chan time.Time`
   - `defaultTimer` struct wrapping `*time.Timer`
   - Implement Start (create or reset timer), Stop, C methods

2. Create `backoff/context.go`:
   - `Context` interface embedding BackOff with additional `Context() context.Context` method
   - `backOffContext` struct with embedded BackOff and ctx field
   - `WithContext(ctx context.Context, backOff BackOff) Context`:
     - Panic on nil context
     - Unwrap if already wrapped (avoid double-wrapping)
     - Return new backOffContext
   - `NextBackOff()` on backOffContext: check ctx.Done(), return Stop if cancelled, otherwise delegate
   - `getContext(b BackOff) context.Context` helper (extracts context from wrapped backoff, returns context.Background() if not wrapped)

3. Create `backoff/tries.go`:
   - `backOffTries` struct with delegate BackOff, maxTries, numTries uint64
   - `WithMaxRetries(b BackOff, max uint64) BackOff`:
     - Return wrapper that counts calls
     - Return Stop when numTries >= maxTries
   - `Reset()` resets numTries to 0 and delegates

4. Create `backoff/context_test.go`:
   - Test WithContext panics on nil context
   - Test context cancellation returns Stop
   - Test unwrapping avoids double-wrap

5. Create `backoff/tries_test.go`:
   - Test WithMaxRetries(b, 3) returns Stop after 3 calls
   - Test WithMaxRetries(b, 0) returns Stop immediately
   - Test Reset() resets counter
  </action>
  <verify>`go test ./backoff/... -run "TestContext|TestMaxRetries|TestTries" -v` passes</verify>
  <done>Timer interface, WithContext wrapper, and WithMaxRetries wrapper exist with passing tests</done>
</task>

<task type="auto">
  <name>Task 2: Create PermanentError, Retry helpers, and Ticker</name>
  <files>backoff/retry.go, backoff/ticker.go, backoff/retry_test.go, backoff/ticker_test.go</files>
  <action>
Create retry helpers and ticker adapted from reference:

1. Create `backoff/retry.go`:
   - `Operation func() error` type
   - `OperationWithData[T any] func() (T, error)` generic type
   - `Notify func(error, time.Duration)` type for error callbacks
   
   - `PermanentError` struct with `Err error` field:
     - `Error() string` returns Err.Error()
     - `Unwrap() error` returns Err
     - `Is(target error) bool` checks if target is *PermanentError
   
   - `Permanent(err error) error`:
     - Return nil if err is nil
     - Wrap in PermanentError
   
   - `Retry(o Operation, b BackOff) error`:
     - Call RetryNotify with nil notify
   
   - `RetryWithData[T any](o OperationWithData[T], b BackOff) (T, error)`:
     - Call RetryNotifyWithData with nil notify
   
   - `RetryNotify(operation Operation, b BackOff, notify Notify) error`:
     - Wrap operation to return struct{}, call doRetryNotify
   
   - `RetryNotifyWithData[T any](operation OperationWithData[T], b BackOff, notify Notify) (T, error)`:
     - Call doRetryNotify with nil timer
   
   - `doRetryNotify[T any](...)` internal helper:
     - Reset backoff
     - Loop: call operation
     - If success, return result
     - If PermanentError (use errors.As), return unwrapped error
     - Get next backoff, if Stop return last error
     - Call notify if not nil
     - Sleep using timer, respect context cancellation

CRITICAL: Use stdlib `errors.As` not `github.com/pkg/errors` - the reference uses pkg/errors but we use stdlib.

2. Create `backoff/ticker.go`:
   - `Ticker` struct with C channel, backOff, ctx, timer, stop channel, stopOnce
   - `NewTicker(b BackOff) *Ticker`:
     - Call NewTickerWithTimer with defaultTimer
   - `NewTickerWithTimer(backOff BackOff, timer Timer) *Ticker`:
     - Create channels, reset backoff, start goroutine
   - `Stop()` method with sync.Once
   - Internal run() loop: send ticks, wait for next backoff duration, stop on context or Stop

3. Create `backoff/retry_test.go`:
   - Test Retry succeeds on first try
   - Test Retry retries on transient errors
   - Test Retry stops on PermanentError
   - Test Retry respects context cancellation
   - Test RetryWithData returns data on success

4. Create `backoff/ticker_test.go`:
   - Test Ticker sends at least one tick
   - Test Ticker stops on Stop() call
   - Test Ticker respects context cancellation
  </action>
  <verify>`go test ./backoff/... -v` passes with no race conditions</verify>
  <done>Retry helpers with PermanentError and Ticker exist with comprehensive tests</done>
</task>

</tasks>

<verification>
```bash
# All backoff tests pass
go test ./backoff/... -v

# No race conditions
go test -race ./backoff/...

# Verify complete package
go build ./backoff/...
```
</verification>

<success_criteria>
- [ ] Timer interface enables testable sleeps
- [ ] WithContext() returns Stop when context cancelled
- [ ] WithMaxRetries() returns Stop after N attempts
- [ ] PermanentError stops retry without retrying
- [ ] Retry/RetryNotify execute with backoff delays
- [ ] Ticker delivers ticks at backoff intervals
- [ ] All tests pass including race detector
- [ ] Uses stdlib errors.As (not pkg/errors)
</success_criteria>

<output>
After completion, create `.planning/phases/32-backoff-package/32-02-SUMMARY.md`
</output>
