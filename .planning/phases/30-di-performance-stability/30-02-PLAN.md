---
phase: 30-di-performance-stability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - di/service.go
  - app.go
autonomous: true

must_haves:
  truths:
    - "collectProviderConfigs only instantiates services that implement ConfigProvider"
    - "Non-ConfigProvider services are NOT instantiated during config collection"
    - "Config discovery behavior is identical for actual ConfigProvider implementations"
  artifacts:
    - path: "di/service.go"
      provides: "ServiceType() method on ServiceWrapper interface"
      contains: "ServiceType() reflect.Type"
    - path: "app.go"
      provides: "Type-based ConfigProvider check before instantiation"
      contains: "configProviderType"
  key_links:
    - from: "collectProviderConfigs"
      to: "wrapper.ServiceType()"
      via: "type check before resolve"
      pattern: "ServiceType.*Implements"
---

<objective>
Fix collectProviderConfigs to check service type before instantiation instead of instantiating all services to check if they implement ConfigProvider.

Purpose: Currently collectProviderConfigs() instantiates EVERY registered service just to check `if cp, ok := instance.(ConfigProvider)`. This causes side effects and unnecessary work. We should check the type at registration time without instantiation.

Output: ServiceWrapper with ServiceType() method, collectProviderConfigs using type-based check.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@di/service.go
@app.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ServiceType() to ServiceWrapper interface</name>
  <files>di/service.go</files>
  <action>
Add a new method to the ServiceWrapper interface and implement it for all service types:

1. **Update imports** - add `"reflect"` to imports

2. **Add to ServiceWrapper interface** (after line 35):
```go
// ServiceType returns the reflect.Type of the service.
// Used for type-checking without instantiation (e.g., interface implementation checks).
ServiceType() reflect.Type
```

3. **Implement for lazySingleton[T]** (after HasLifecycle):
```go
func (s *lazySingleton[T]) ServiceType() reflect.Type {
    var zero T
    return reflect.TypeOf(zero)
}
```

4. **Implement for transientService[T]** (after HasLifecycle):
```go
func (s *transientService[T]) ServiceType() reflect.Type {
    var zero T
    return reflect.TypeOf(zero)
}
```

5. **Implement for eagerSingleton[T]** (after HasLifecycle):
```go
func (s *eagerSingleton[T]) ServiceType() reflect.Type {
    var zero T
    return reflect.TypeOf(zero)
}
```

6. **Implement for instanceService[T]** (after HasLifecycle):
```go
func (s *instanceService[T]) ServiceType() reflect.Type {
    var zero T
    return reflect.TypeOf(zero)
}
```

7. **Implement for instanceServiceAny** (after HasLifecycle):
```go
func (s *instanceServiceAny) ServiceType() reflect.Type {
    return reflect.TypeOf(s.value)
}
```

Note: For generic types, we use `var zero T; reflect.TypeOf(zero)` to get the type.
For instanceServiceAny, we use the actual value since it's non-generic.
  </action>
  <verify>
`go build ./di/...` succeeds
`grep -n "ServiceType() reflect.Type" di/service.go` shows interface and implementations
  </verify>
  <done>ServiceWrapper interface has ServiceType() method implemented by all service types</done>
</task>

<task type="auto">
  <name>Task 2: Update collectProviderConfigs to use type check</name>
  <files>app.go</files>
  <action>
Modify collectProviderConfigs to check service type BEFORE instantiation:

1. **Add package-level variable** near the top of app.go (after imports):
```go
// configProviderType is cached for efficient interface checks
var configProviderType = reflect.TypeOf((*ConfigProvider)(nil)).Elem()
```

2. **Update collectProviderConfigs** (around line 377):

**Before:**
```go
// Use ResolveByName() instead of GetInstance() to ensure dependencies are recorded
instance, err := a.container.ResolveByName(typeName, nil)
if err != nil {
    continue // Skip services that fail to resolve
}

cp, ok := instance.(ConfigProvider)
if !ok {
    continue
}
```

**After:**
```go
// Check if service type implements ConfigProvider BEFORE instantiation
// This avoids side effects of instantiating non-ConfigProvider services
serviceType := wrapper.ServiceType()
if serviceType == nil {
    continue
}

// For pointer types, check both pointer and element type
if !serviceType.Implements(configProviderType) {
    // Also check pointer-to-type in case methods are on *T
    if serviceType.Kind() != reflect.Ptr {
        ptrType := reflect.PtrTo(serviceType)
        if !ptrType.Implements(configProviderType) {
            continue
        }
    } else {
        continue
    }
}

// Only now instantiate - we know it implements ConfigProvider
instance, err := a.container.ResolveByName(typeName, nil)
if err != nil {
    continue // Skip services that fail to resolve
}

cp, ok := instance.(ConfigProvider)
if !ok {
    // This shouldn't happen if type check above is correct, but be defensive
    continue
}
```

Key insight: We check `Implements()` on the reflect.Type, which tells us if the type satisfies the interface WITHOUT creating an instance. Only after confirming it implements ConfigProvider do we call ResolveByName.
  </action>
  <verify>
`go build ./...` succeeds
`go test ./... -run Config -v` passes
  </verify>
  <done>collectProviderConfigs checks type before instantiation, avoiding unnecessary side effects</done>
</task>

<task type="auto">
  <name>Task 3: Add test and run full suite</name>
  <files>app.go</files>
  <action>
Run the complete test suite to verify config discovery still works correctly:

1. Run config-related tests: `go test ./... -run Config -v`
2. Run all tests: `go test ./... -count=1`
3. Verify no regressions in ConfigProvider discovery

Expected behavior:
- Services implementing ConfigProvider are still discovered
- Services NOT implementing ConfigProvider are no longer instantiated during discovery
- All existing tests pass

If tests fail, analyze and fix. Common issues:
- reflect.Type may be nil for certain edge cases
- Pointer vs value receiver implementation checks
  </action>
  <verify>
`go test ./... -count=1` all pass
  </verify>
  <done>All tests pass, config discovery works without unnecessary instantiation</done>
</task>

</tasks>

<verification>
1. `go test ./... -count=1` all pass
2. Services implementing ConfigProvider are still discovered correctly
3. Non-ConfigProvider services are NOT instantiated during collectProviderConfigs
</verification>

<success_criteria>
- ServiceWrapper interface has ServiceType() method
- All 5 service types implement ServiceType()
- collectProviderConfigs uses type check before instantiation
- Only ConfigProvider implementations are instantiated during discovery
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/30-di-performance-stability/30-02-SUMMARY.md`
</output>
