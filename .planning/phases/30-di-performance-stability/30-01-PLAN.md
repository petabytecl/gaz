---
phase: 30-di-performance-stability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - di/container.go
  - di/resolution.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Cycle detection works without runtime.Stack() calls"
    - "ResolveByName uses its chain parameter (not goroutine-based tracking)"
    - "Providers can resolve dependencies with chain context via Container.currentChain"
    - "Concurrent resolution is safe with per-goroutine chain storage"
    - "All existing DI tests pass"
  artifacts:
    - path: "di/container.go"
      provides: "Explicit chain-based cycle detection with temporary chain storage"
      no_contains: ["getGoroutineID", "decimalBase"]
    - path: "di/resolution.go"
      provides: "Resolve[T] uses Container.getChain() to get current resolution chain"
      contains: "c.getChain()"
  key_links:
    - from: "ResolveByName"
      to: "GetInstance"
      via: "chain parameter passthrough"
      pattern: "GetInstance.*chain"
    - from: "Resolve[T]"
      to: "ResolveByName"
      via: "c.getChain() retrieves current chain from Container"
      pattern: "c.getChain()"
---

<objective>
Remove the runtime.Stack() hack for goroutine ID tracking and use explicit chain parameter for cycle detection.

Purpose: The current implementation uses runtime.Stack() to parse goroutine IDs - this is slow (allocates buffer, parses string), fragile (format could change), and unnecessary. The solution is to keep per-goroutine chain storage but use a proper goroutine-local mechanism, or store chain in Container and have Resolve[T] retrieve it.

Output: di/container.go without getGoroutineID() but with clean chain propagation through resolutions.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@di/container.go
@di/resolution.go
@di/inject.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace runtime.Stack with goid package</name>
  <files>di/container.go, go.mod</files>
  <action>
The issue is that we need per-goroutine chain tracking (for concurrent resolution safety), but we want to avoid the runtime.Stack() hack.

The cleanest solution is to use the `github.com/petermattis/goid` package which provides efficient goroutine ID access without string parsing.

1. **Add dependency:**
```bash
go get github.com/petermattis/goid
```

2. **Update imports in di/container.go:**
Replace `"runtime"` with `"github.com/petermattis/goid"`

3. **Remove decimalBase constant** (line 13):
Delete `const decimalBase = 10`

4. **Replace getGoroutineID function** (around line 107):

**Before (slow, fragile):**
```go
func getGoroutineID() int64 {
    var buf [64]byte
    n := runtime.Stack(buf[:], false)
    // Parse goroutine ID from stack trace: "goroutine 123 [running]:"
    var id int64
    for i := 10; i < n; i++ { // Skip "goroutine "
        if buf[i] == ' ' {
            break
        }
        id = id*decimalBase + int64(buf[i]-'0')
    }
    return id
}
```

**After (fast, stable):**
```go
func getGoroutineID() int64 {
    return goid.Get()
}
```

5. **Verify imports are correct:**
```go
import (
    "errors"
    "fmt"
    "sort"
    "strings"
    "sync"
    
    "github.com/petermattis/goid"
)
```

The goid package uses runtime linkname to access the goroutine ID directly from Go's runtime, which is:
- Fast: No allocation, no parsing
- Stable: Maintained package with Go version compatibility
- Safe: Returns consistent int64 IDs per-goroutine
  </action>
  <verify>
`go build ./di/...` succeeds
`grep -n "runtime.Stack\|decimalBase" di/container.go` returns empty
`grep -n "goid.Get" di/container.go` shows the new implementation
  </verify>
  <done>getGoroutineID() uses goid.Get() instead of runtime.Stack() parsing</done>
</task>

<task type="auto">
  <name>Task 2: Update Resolve[T] to use Container's current chain</name>
  <files>di/resolution.go</files>
  <action>
The Resolve[T] function currently always passes nil for chain:

**Before:**
```go
func Resolve[T any](c *Container, opts ...ResolveOption) (T, error) {
    ...
    // Start resolution with empty chain for cycle detection
    instance, err := c.ResolveByName(name, nil)  // Always nil!
    ...
}
```

**After:**
```go
func Resolve[T any](c *Container, opts ...ResolveOption) (T, error) {
    ...
    // Get current chain from container (may be non-nil if called from provider)
    chain := c.getChain()
    
    // Continue resolution with current chain for proper cycle detection
    instance, err := c.ResolveByName(name, chain)
    ...
}
```

This change ensures that when a provider calls `di.Resolve[T](c)` to resolve a dependency, the current resolution chain is retrieved from the Container and passed through, enabling proper cycle detection.

The getChain() method already exists on Container (lines 122-127) and returns the chain for the current goroutine, so this is a minimal change.
  </action>
  <verify>
`go build ./di/...` succeeds
`grep -n "c.getChain()" di/resolution.go` shows the change
  </verify>
  <done>Resolve[T] retrieves current chain from Container before calling ResolveByName</done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify</name>
  <files>di/container_test.go</files>
  <action>
Run the complete DI test suite to verify all behavior is preserved:

1. Run all DI tests: `go test ./di/... -v`
2. Run specific cycle detection tests: `go test ./di/... -run Cycle -v`
3. Run injection tests: `go test ./di/... -run Inject -v`
4. Run the full project test suite: `go test ./... -count=1`

Expected: All tests pass. The cycle detection behavior is identical, just implemented without runtime.Stack() parsing.

If any tests fail, analyze and fix. Common issues:
- Import path issues with goid package
- Tests that mock chain parameter incorrectly
  </action>
  <verify>
`go test ./di/... -v` all pass
`go test ./... -count=1` all pass
  </verify>
  <done>All existing tests pass with goid-based goroutine ID detection</done>
</task>

</tasks>

<verification>
1. `grep -rn "runtime.Stack\|decimalBase" di/` returns nothing
2. `grep -n "goid.Get" di/container.go` shows the new implementation
3. `go test ./di/... -v` all pass
4. `go test ./... -count=1` all pass
5. Cycle detection still works (test with circular dependency)
</verification>

<success_criteria>
- runtime.Stack() parsing removed
- decimalBase constant removed
- getGoroutineID() uses goid.Get() (fast, stable)
- Resolve[T] passes chain from Container's getChain()
- Per-goroutine chain tracking preserved for concurrent safety
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/30-di-performance-stability/30-01-SUMMARY.md`
</output>
