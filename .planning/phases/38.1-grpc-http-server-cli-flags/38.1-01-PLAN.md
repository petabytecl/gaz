---
phase: 38.1-grpc-http-server-cli-flags
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/module.go
  - server/module_test.go
autonomous: true

must_haves:
  truths:
    - "Users can configure gRPC port via --grpc-port flag"
    - "Users can configure HTTP port via --http-port flag"
    - "Users can configure gRPC reflection via --grpc-reflection flag"
    - "Users can configure gRPC dev mode via --grpc-dev-mode flag"
    - "Flags integrate with cobra command when app has WithCobra"
    - "Module options still work when flags are not used"
  artifacts:
    - path: "server/module.go"
      provides: "CLI flag registration via gaz.Module pattern"
      contains: "fs.IntVar"
    - path: "server/module_test.go"
      provides: "Flag integration tests"
      contains: "TestModuleFlagsRegistration"
  key_links:
    - from: "server/module.go"
      to: "gaz.Module"
      via: "gaz.NewModule().Flags().Provide().Build()"
      pattern: "gaz\\.NewModule\\("
---

<objective>
Convert server.NewModule to return gaz.Module with CLI flag registration.

Purpose: Enable users to configure gRPC and HTTP server ports and settings via CLI flags (--grpc-port, --http-port, etc.) when the app is used with Cobra.

Output: Updated server/module.go returning gaz.Module with Flags() integration, plus tests verifying flag registration and value binding.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-transport-foundations/38-03-SUMMARY.md

@server/module.go
@module_builder.go
@app_use.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert server.NewModule to gaz.Module with CLI flags</name>
  <files>server/module.go</files>
  <action>
Refactor server.NewModule() to return gaz.Module (not di.Module) with CLI flag registration.

**Key changes:**

1. **Import gaz package** - Add `"github.com/petabytecl/gaz"` and `"github.com/spf13/pflag"` imports.

2. **Change return type** - Return `gaz.Module` instead of `di.Module`.

3. **Use gaz.NewModule pattern** with Flags() and Provide():

```go
func NewModule(opts ...ModuleOption) gaz.Module {
    cfg := defaultModuleConfig()
    for _, opt := range opts {
        opt(cfg)
    }

    return gaz.NewModule("server").
        Flags(func(fs *pflag.FlagSet) {
            // Use IntVar/BoolVar to bind directly to cfg fields
            // Flag values are written to cfg when flags are parsed
            // Default values come from cfg (which may have been set by module options)
            fs.IntVar(&cfg.grpcPort, "grpc-port", cfg.grpcPort, "gRPC server port")
            fs.IntVar(&cfg.httpPort, "http-port", cfg.httpPort, "HTTP server port")
            fs.BoolVar(&cfg.grpcReflection, "grpc-reflection", cfg.grpcReflection, "Enable gRPC reflection")
            fs.BoolVar(&cfg.grpcDevMode, "grpc-dev-mode", cfg.grpcDevMode, "Enable gRPC development mode")
        }).
        Provide(func(c *gaz.Container) error {
            // At this point, flags have been parsed and cfg values are updated
            // by pflag via the pointer binding

            // Register gRPC with final config values
            grpcOpts := []grpc.ModuleOption{
                grpc.WithPort(cfg.grpcPort),
                grpc.WithReflection(cfg.grpcReflection),
                grpc.WithDevMode(cfg.grpcDevMode),
            }
            grpcModule := grpc.NewModule(grpcOpts...)
            if err := grpcModule.Register(c); err != nil {
                return fmt.Errorf("register grpc module: %w", err)
            }

            // Register HTTP with final config values
            httpOpts := []shttp.ModuleOption{
                shttp.WithPort(cfg.httpPort),
            }
            if cfg.httpHandler != nil {
                httpOpts = append(httpOpts, shttp.WithHandler(cfg.httpHandler))
            }
            httpModule := shttp.NewModule(httpOpts...)
            if err := httpModule.Register(c); err != nil {
                return fmt.Errorf("register http module: %w", err)
            }

            return nil
        }).
        Build()
}
```

**Why IntVar/BoolVar pattern:**
- pflag.IntVar binds flag value directly to cfg.grpcPort pointer
- When flags are parsed (before Build()), values are written to cfg
- When Provide() runs (during Build()), cfg has final merged values
- Module options set defaults in cfg BEFORE flags are registered
- Flag defaults come FROM cfg, so module options take effect

**Flag naming convention:**
- `--grpc-port` (not `--server-grpc-port`) - server module is root-level
- `--http-port`, `--grpc-reflection`, `--grpc-dev-mode`

**Note:** Container type is `*gaz.Container` (alias for `*di.Container`).
  </action>
  <verify>
```bash
go build ./server/...
go vet ./server/...
```
  </verify>
  <done>
- NewModule returns gaz.Module
- Flags() registers --grpc-port, --http-port, --grpc-reflection, --grpc-dev-mode
- Provide() uses cfg values (merged from options + flags)
- Imports compile without cycles
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for flag registration and binding</name>
  <files>server/module_test.go</files>
  <action>
Add test cases to verify:

1. **Flags are registered on cobra command:**

```go
func (s *ModuleTestSuite) TestModuleFlagsRegistration() {
    // Create a module
    m := server.NewModule()

    // Check that module provides FlagsFn
    flagsProvider, ok := m.(interface{ FlagsFn() func(*pflag.FlagSet) })
    s.Require().True(ok, "module should implement FlagsFn")

    fn := flagsProvider.FlagsFn()
    s.Require().NotNil(fn, "FlagsFn should return non-nil function")

    // Apply flags to a test FlagSet
    fs := pflag.NewFlagSet("test", pflag.ContinueOnError)
    fn(fs)

    // Verify flags are registered with correct defaults
    grpcPort := fs.Lookup("grpc-port")
    s.Require().NotNil(grpcPort, "--grpc-port flag should be registered")
    s.Equal("50051", grpcPort.DefValue)

    httpPort := fs.Lookup("http-port")
    s.Require().NotNil(httpPort, "--http-port flag should be registered")
    s.Equal("8080", httpPort.DefValue)

    grpcReflection := fs.Lookup("grpc-reflection")
    s.Require().NotNil(grpcReflection, "--grpc-reflection flag should be registered")
    s.Equal("true", grpcReflection.DefValue)

    grpcDevMode := fs.Lookup("grpc-dev-mode")
    s.Require().NotNil(grpcDevMode, "--grpc-dev-mode flag should be registered")
    s.Equal("false", grpcDevMode.DefValue)
}
```

2. **Module options affect flag defaults:**

```go
func (s *ModuleTestSuite) TestModuleOptionsAffectFlagDefaults() {
    // Create module with custom options
    m := server.NewModule(
        server.WithGRPCPort(9090),
        server.WithHTTPPort(3000),
        server.WithGRPCReflection(false),
    )

    flagsProvider := m.(interface{ FlagsFn() func(*pflag.FlagSet) })
    fs := pflag.NewFlagSet("test", pflag.ContinueOnError)
    flagsProvider.FlagsFn()(fs)

    // Options should have set the defaults
    s.Equal("9090", fs.Lookup("grpc-port").DefValue)
    s.Equal("3000", fs.Lookup("http-port").DefValue)
    s.Equal("false", fs.Lookup("grpc-reflection").DefValue)
}
```

3. **Flag values override options:**

```go
func (s *ModuleTestSuite) TestFlagValuesOverrideOptions() {
    // Create module with options
    m := server.NewModule(server.WithGRPCPort(9090))

    // Simulate flag parsing
    flagsProvider := m.(interface{ FlagsFn() func(*pflag.FlagSet) })
    fs := pflag.NewFlagSet("test", pflag.ContinueOnError)
    flagsProvider.FlagsFn()(fs)

    // Parse flags to override
    err := fs.Parse([]string{"--grpc-port=7777"})
    s.Require().NoError(err)

    // Now apply the module - the grpc server should use port 7777
    // (This is tested implicitly by verifying the flag was parsed)
    val, _ := fs.GetInt("grpc-port")
    s.Equal(7777, val)
}
```

**Add pflag import if not present.**
  </action>
  <verify>
```bash
go test -race -v ./server/... -run TestModule
```
  </verify>
  <done>
- TestModuleFlagsRegistration passes (flags registered with correct names and defaults)
- TestModuleOptionsAffectFlagDefaults passes (module options set flag defaults)
- TestFlagValuesOverrideOptions passes (parsed flags update bound values)
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify integration and coverage</name>
  <files>server/module.go, server/module_test.go</files>
  <action>
1. Run full test suite for server package:
```bash
go test -race -v ./server/...
```

2. Check coverage meets 90% threshold:
```bash
go test -race -coverprofile=coverage.out ./server/...
go tool cover -func=coverage.out | grep -E "^total|module.go"
```

3. Run linter:
```bash
golangci-lint run ./server/...
```

4. If any tests fail or coverage drops, fix the issues.

**Potential issues to watch for:**
- Import cycle (server -> gaz): Should not occur since gaz doesn't import server
- ireturn linter: May need to add "server" to ireturn allow pattern (already done in 38-03)
- Missing test coverage on new code paths
  </action>
  <verify>
```bash
make lint && make cover
```
  </verify>
  <done>
- All server tests pass
- Coverage >= 90%
- Linter passes
- No import cycles
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Flag availability:** Create a test app with server.NewModule() and verify flags appear on cobra command
2. **Flag defaults:** Verify --grpc-port defaults to 50051, --http-port to 8080
3. **Option override:** Verify WithGRPCPort(9090) changes --grpc-port default to 9090
4. **Flag override:** Verify --grpc-port=7777 on command line overrides option default
5. **Build passes:** `go build ./...`
6. **Tests pass:** `make test`
7. **Lint passes:** `make lint`
</verification>

<success_criteria>
- [ ] server.NewModule() returns gaz.Module (not di.Module)
- [ ] --grpc-port, --http-port, --grpc-reflection, --grpc-dev-mode flags registered
- [ ] Module options set flag defaults (precedence: flags > options > hardcoded defaults)
- [ ] Tests verify flag registration and value binding
- [ ] All tests pass with `make test`
- [ ] Linter passes with `make lint`
- [ ] Coverage >= 90%
</success_criteria>

<output>
After completion, create `.planning/phases/38.1-grpc-http-server-cli-flags/38.1-01-SUMMARY.md`
</output>
