---
phase: 26-module-service-consolidation
plan: 03
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - worker/module.go
  - worker/module_test.go
  - cron/module.go
  - cron/module_test.go
autonomous: true

must_haves:
  truths:
    - "worker.NewModule() returns gaz.Module with functional options"
    - "cron.NewModule() returns gaz.Module with functional options"
    - "Both modules work with zero arguments using sensible defaults"
  artifacts:
    - path: "worker/module.go"
      provides: "NewModule factory for worker subsystem"
      exports: ["NewModule", "ModuleOption"]
      contains: "func NewModule"
    - path: "cron/module.go"
      provides: "NewModule factory for cron subsystem"
      exports: ["NewModule", "ModuleOption"]
      contains: "func NewModule"
  key_links:
    - from: "worker/module.go"
      to: "gaz.NewModule"
      via: "module builder delegation"
      pattern: "gaz\\.NewModule"
    - from: "cron/module.go"
      to: "gaz.NewModule"
      via: "module builder delegation"
      pattern: "gaz\\.NewModule"
---

<objective>
Add NewModule() factory functions to worker and cron packages with functional options pattern.

Purpose: Provide consistent module factory API across all subsystem packages, following the pattern established in health.NewModule().

Output: worker/module.go and cron/module.go with NewModule() factories and option types
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-module-service-consolidation/26-CONTEXT.md
@.planning/phases/26-module-service-consolidation/26-RESEARCH.md

@worker/manager.go
@worker/doc.go
@cron/scheduler.go
@cron/doc.go
@module_builder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worker/module.go with NewModule()</name>
  <files>worker/module.go</files>
  <action>
Create new file worker/module.go with NewModule() factory:

```go
package worker

import (
    "log/slog"

    "github.com/petabytecl/gaz"
)

// ModuleOption configures the worker module.
type ModuleOption func(*moduleConfig)

type moduleConfig struct {
    // Currently no configurable options exposed
    // Placeholder for future extensibility (e.g., WithMaxRestarts)
}

func defaultModuleConfig() *moduleConfig {
    return &moduleConfig{}
}

// NewModule creates a worker module with the given options.
// Returns a gaz.Module that provides worker management infrastructure.
//
// Prerequisites:
//   - *slog.Logger must be registered (automatically registered by gaz.New())
//
// Note: Workers are auto-discovered during gaz.App.Build() when services
// implement the worker.Worker interface. This module provides the Manager
// for explicit access if needed.
//
// Example:
//
//     app := gaz.New()
//     app.Use(worker.NewModule())
func NewModule(opts ...ModuleOption) gaz.Module {
    cfg := defaultModuleConfig()
    for _, opt := range opts {
        opt(cfg)
    }

    return gaz.NewModule("worker").
        Provide(func(c *gaz.Container) error {
            // Validate prerequisites
            if !gaz.Has[*slog.Logger](c) {
                return fmt.Errorf("worker module requires *slog.Logger to be registered")
            }
            
            // Worker Manager is auto-created in gaz.New(), so this module
            // just validates prerequisites. Future options could register
            // additional worker-related components here.
            return nil
        }).
        Build()
}
```

Add necessary import for fmt.

Note: The worker.Manager is already created in gaz.New() and workers are auto-discovered. This module serves as:
1. Explicit opt-in for the worker subsystem
2. Prerequisite validation
3. Foundation for future configurable options (e.g., WithMaxRestarts)
  </action>
  <verify>
Run: `go build ./worker/...` — compiles successfully
  </verify>
  <done>
worker/module.go exists with NewModule() factory function
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cron/module.go with NewModule()</name>
  <files>cron/module.go</files>
  <action>
Create new file cron/module.go with NewModule() factory:

```go
package cron

import (
    "fmt"
    "log/slog"

    "github.com/petabytecl/gaz"
)

// ModuleOption configures the cron module.
type ModuleOption func(*moduleConfig)

type moduleConfig struct {
    // Currently no configurable options exposed
    // Placeholder for future extensibility (e.g., WithTimezone)
}

func defaultModuleConfig() *moduleConfig {
    return &moduleConfig{}
}

// NewModule creates a cron module with the given options.
// Returns a gaz.Module that provides cron scheduling infrastructure.
//
// Prerequisites:
//   - *slog.Logger must be registered (automatically registered by gaz.New())
//
// Note: Cron jobs are auto-discovered during gaz.App.Build() when services
// implement the cron.CronJob interface. This module provides explicit
// opt-in and future configuration options.
//
// Example:
//
//     app := gaz.New()
//     app.Use(cron.NewModule())
func NewModule(opts ...ModuleOption) gaz.Module {
    cfg := defaultModuleConfig()
    for _, opt := range opts {
        opt(cfg)
    }

    return gaz.NewModule("cron").
        Provide(func(c *gaz.Container) error {
            // Validate prerequisites
            if !gaz.Has[*slog.Logger](c) {
                return fmt.Errorf("cron module requires *slog.Logger to be registered")
            }
            
            // Scheduler is auto-created in gaz.New(), so this module
            // just validates prerequisites. Future options could configure
            // timezone, error handlers, etc.
            return nil
        }).
        Build()
}
```

Note: Similar to worker, the cron.Scheduler is already created in gaz.New(). This module provides:
1. Explicit opt-in for cron subsystem
2. Prerequisite validation  
3. Foundation for future options (e.g., WithTimezone, WithErrorHandler)
  </action>
  <verify>
Run: `go build ./cron/...` — compiles successfully
  </verify>
  <done>
cron/module.go exists with NewModule() factory function
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for worker and cron NewModule()</name>
  <files>worker/module_test.go, cron/module_test.go</files>
  <action>
Create worker/module_test.go:

```go
package worker

import (
    "testing"

    "github.com/petabytecl/gaz"
    "github.com/stretchr/testify/require"
)

func TestNewModule(t *testing.T) {
    t.Run("zero arguments works with defaults", func(t *testing.T) {
        app := gaz.New()
        app.Use(NewModule())
        
        err := app.Build()
        require.NoError(t, err)
    })
    
    t.Run("returns valid gaz.Module", func(t *testing.T) {
        mod := NewModule()
        require.NotNil(t, mod)
        require.Equal(t, "worker", mod.Name())
    })
}
```

Create cron/module_test.go:

```go
package cron

import (
    "testing"

    "github.com/petabytecl/gaz"
    "github.com/stretchr/testify/require"
)

func TestNewModule(t *testing.T) {
    t.Run("zero arguments works with defaults", func(t *testing.T) {
        app := gaz.New()
        app.Use(NewModule())
        
        err := app.Build()
        require.NoError(t, err)
    })
    
    t.Run("returns valid gaz.Module", func(t *testing.T) {
        mod := NewModule()
        require.NotNil(t, mod)
        require.Equal(t, "cron", mod.Name())
    })
}
```
  </action>
  <verify>
Run: `go test ./worker/... -run TestNewModule -v` — passes
Run: `go test ./cron/... -run TestNewModule -v` — passes
  </verify>
  <done>
Tests verify NewModule() works with zero args and returns proper gaz.Module
  </done>
</task>

</tasks>

<verification>
1. `go build ./worker/... ./cron/...` — compiles
2. `go test ./worker/... ./cron/... -v` — all tests pass
3. `go doc worker.NewModule` — shows documentation
4. `go doc cron.NewModule` — shows documentation
</verification>

<success_criteria>
- [ ] worker/module.go exists with NewModule(), ModuleOption
- [ ] cron/module.go exists with NewModule(), ModuleOption
- [ ] Both NewModule() functions return gaz.Module directly
- [ ] Both work with zero arguments
- [ ] Tests verify basic functionality
- [ ] MOD-03 (worker, cron): packages export NewModule()
</success_criteria>

<output>
After completion, create `.planning/phases/26-module-service-consolidation/26-03-SUMMARY.md`
</output>
