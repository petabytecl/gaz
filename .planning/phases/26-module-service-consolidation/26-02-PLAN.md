---
phase: 26-module-service-consolidation
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - health/module.go
  - health/module_test.go
autonomous: true

must_haves:
  truths:
    - "health.NewModule() works with zero arguments using sensible defaults"
    - "health.NewModule(opts...) accepts functional options for customization"
    - "health.NewModule() returns gaz.Module directly (not a builder)"
  artifacts:
    - path: "health/module.go"
      provides: "NewModule factory with ModuleOption type"
      exports: ["NewModule", "ModuleOption", "WithPort", "WithLivenessPath", "WithReadinessPath", "WithStartupPath"]
      contains: "func NewModule"
    - path: "health/module_test.go"
      provides: "Tests for NewModule factory"
      contains: "TestNewModule"
  key_links:
    - from: "health/module.go"
      to: "gaz.NewModule"
      via: "internal builder delegation"
      pattern: "gaz\\.NewModule"
---

<objective>
Add NewModule() factory function to health package with functional options pattern.

Purpose: Replace the existing health.Module(c *Container) function with health.NewModule(opts...) that returns gaz.Module directly, following uber-go/fx conventions.

Output: health/module.go with NewModule() factory, ModuleOption type, and With* options
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-module-service-consolidation/26-CONTEXT.md
@.planning/phases/26-module-service-consolidation/26-RESEARCH.md

@health/module.go
@health/config.go
@module_builder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ModuleOption type and With* functions to health package</name>
  <files>health/module.go</files>
  <action>
Add functional options infrastructure at the top of health/module.go (after imports):

```go
// ModuleOption configures the health module.
type ModuleOption func(*moduleConfig)

type moduleConfig struct {
    port          int
    livenessPath  string
    readinessPath string
    startupPath   string
}

func defaultModuleConfig() *moduleConfig {
    cfg := DefaultConfig()
    return &moduleConfig{
        port:          cfg.Port,
        livenessPath:  cfg.LivenessPath,
        readinessPath: cfg.ReadinessPath,
        startupPath:   cfg.StartupPath,
    }
}

// WithPort sets the health server port. Default is 9090.
func WithPort(port int) ModuleOption {
    return func(c *moduleConfig) {
        c.port = port
    }
}

// WithLivenessPath sets the liveness endpoint path. Default is "/live".
func WithLivenessPath(path string) ModuleOption {
    return func(c *moduleConfig) {
        c.livenessPath = path
    }
}

// WithReadinessPath sets the readiness endpoint path. Default is "/ready".
func WithReadinessPath(path string) ModuleOption {
    return func(c *moduleConfig) {
        c.readinessPath = path
    }
}

// WithStartupPath sets the startup endpoint path. Default is "/startup".
func WithStartupPath(path string) ModuleOption {
    return func(c *moduleConfig) {
        c.startupPath = path
    }
}
```

These options use the `With{Property}(value)` naming pattern per CONTEXT.md decisions.
  </action>
  <verify>
Run: `go build ./health/...` — compiles successfully
  </verify>
  <done>
ModuleOption type and four With* functions exist in health/module.go
  </done>
</task>

<task type="auto">
  <name>Task 2: Add NewModule() factory function</name>
  <files>health/module.go</files>
  <action>
Add NewModule() factory function that:
1. Accepts variadic ModuleOption
2. Builds moduleConfig from options  
3. Returns gaz.Module directly (not a builder)
4. Registers Config from options, then delegates to existing Module() logic

```go
// NewModule creates a health module with the given options.
// Returns a gaz.Module that registers health check components.
//
// Components registered:
//   - health.Config (from options or defaults)
//   - *health.ShutdownCheck
//   - *health.Manager
//   - *health.ManagementServer (eager, starts HTTP server)
//
// Example:
//
//     app := gaz.New()
//     app.Use(health.NewModule())                           // defaults
//     app.Use(health.NewModule(health.WithPort(8081)))      // custom port
func NewModule(opts ...ModuleOption) gaz.Module {
    cfg := defaultModuleConfig()
    for _, opt := range opts {
        opt(cfg)
    }

    return gaz.NewModule("health").
        Provide(func(c *gaz.Container) error {
            // Register Config from module options
            healthCfg := Config{
                Port:          cfg.port,
                LivenessPath:  cfg.livenessPath,
                ReadinessPath: cfg.readinessPath,
                StartupPath:   cfg.startupPath,
            }
            if err := gaz.For[Config](c).Instance(healthCfg); err != nil {
                return fmt.Errorf("register health config: %w", err)
            }

            // Delegate to existing Module() for component registration
            return Module(c)
        }).
        Build()
}
```

Keep the existing Module(c *Container) function for internal use (it's still called by NewModule and auto-registration in gaz.App.Build()).
  </action>
  <verify>
Run: `go build ./health/...` — compiles successfully
  </verify>
  <done>
health.NewModule() exists and returns gaz.Module directly
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for NewModule()</name>
  <files>health/module_test.go</files>
  <action>
Add test cases for NewModule() in health/module_test.go:

```go
func TestNewModule(t *testing.T) {
    t.Run("zero arguments uses defaults", func(t *testing.T) {
        app := gaz.New()
        app.Use(NewModule())
        
        err := app.Build()
        require.NoError(t, err)
        
        // Verify Config was registered with defaults
        cfg, err := gaz.Resolve[Config](app.Container())
        require.NoError(t, err)
        assert.Equal(t, 9090, cfg.Port)
        assert.Equal(t, "/live", cfg.LivenessPath)
        assert.Equal(t, "/ready", cfg.ReadinessPath)
        assert.Equal(t, "/startup", cfg.StartupPath)
    })
    
    t.Run("WithPort overrides port", func(t *testing.T) {
        app := gaz.New()
        app.Use(NewModule(WithPort(8081)))
        
        err := app.Build()
        require.NoError(t, err)
        
        cfg, err := gaz.Resolve[Config](app.Container())
        require.NoError(t, err)
        assert.Equal(t, 8081, cfg.Port)
    })
    
    t.Run("multiple options combine", func(t *testing.T) {
        app := gaz.New()
        app.Use(NewModule(
            WithPort(8082),
            WithLivenessPath("/health/live"),
            WithReadinessPath("/health/ready"),
            WithStartupPath("/health/startup"),
        ))
        
        err := app.Build()
        require.NoError(t, err)
        
        cfg, err := gaz.Resolve[Config](app.Container())
        require.NoError(t, err)
        assert.Equal(t, 8082, cfg.Port)
        assert.Equal(t, "/health/live", cfg.LivenessPath)
        assert.Equal(t, "/health/ready", cfg.ReadinessPath)
        assert.Equal(t, "/health/startup", cfg.StartupPath)
    })
    
    t.Run("registers all health components", func(t *testing.T) {
        app := gaz.New()
        app.Use(NewModule())
        
        err := app.Build()
        require.NoError(t, err)
        
        // Verify all components registered
        _, err = gaz.Resolve[*ShutdownCheck](app.Container())
        require.NoError(t, err)
        
        _, err = gaz.Resolve[*Manager](app.Container())
        require.NoError(t, err)
        
        _, err = gaz.Resolve[*ManagementServer](app.Container())
        require.NoError(t, err)
    })
}
```

Note: Adjust imports as needed (github.com/stretchr/testify/require, github.com/stretchr/testify/assert).
  </action>
  <verify>
Run: `go test ./health/... -run TestNewModule -v` — all tests pass
  </verify>
  <done>
TestNewModule covers zero-arg, single option, multiple options, and component registration cases
  </done>
</task>

</tasks>

<verification>
1. `go build ./health/...` — compiles
2. `go test ./health/... -v` — all tests pass
3. `go doc health.NewModule` — shows proper documentation
4. `go doc health.ModuleOption` — shows type documentation
</verification>

<success_criteria>
- [ ] health.ModuleOption type exists
- [ ] health.WithPort, WithLivenessPath, WithReadinessPath, WithStartupPath exist
- [ ] health.NewModule() accepts options and returns gaz.Module
- [ ] NewModule() with zero args uses defaults from DefaultConfig()
- [ ] Tests verify all option combinations
- [ ] MOD-03 (health): health package exports NewModule()
</success_criteria>

<output>
After completion, create `.planning/phases/26-module-service-consolidation/26-02-SUMMARY.md`
</output>
