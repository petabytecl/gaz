---
phase: 26-module-service-consolidation
plan: 04
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - eventbus/module.go
  - eventbus/module_test.go
  - config/module.go
  - config/module_test.go
autonomous: true

must_haves:
  truths:
    - "eventbus.NewModule() returns gaz.Module with functional options"
    - "config.NewModule() returns gaz.Module with functional options"
    - "Both modules work with zero arguments using sensible defaults"
  artifacts:
    - path: "eventbus/module.go"
      provides: "NewModule factory for eventbus subsystem"
      exports: ["NewModule", "ModuleOption"]
      contains: "func NewModule"
    - path: "config/module.go"
      provides: "NewModule factory for config subsystem"
      exports: ["NewModule", "ModuleOption"]
      contains: "func NewModule"
  key_links:
    - from: "eventbus/module.go"
      to: "gaz.NewModule"
      via: "module builder delegation"
      pattern: "gaz\\.NewModule"
    - from: "config/module.go"
      to: "gaz.NewModule"
      via: "module builder delegation"
      pattern: "gaz\\.NewModule"
---

<objective>
Add NewModule() factory functions to eventbus and config packages with functional options pattern.

Purpose: Complete MOD-03 by adding NewModule() to remaining subsystem packages, ensuring all five packages have consistent module factory APIs.

Output: eventbus/module.go and config/module.go with NewModule() factories and option types
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-module-service-consolidation/26-CONTEXT.md
@.planning/phases/26-module-service-consolidation/26-RESEARCH.md

@eventbus/bus.go
@eventbus/doc.go
@config/manager.go
@config/options.go
@module_builder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create eventbus/module.go with NewModule()</name>
  <files>eventbus/module.go</files>
  <action>
Create new file eventbus/module.go with NewModule() factory:

```go
package eventbus

import (
    "fmt"
    "log/slog"

    "github.com/petabytecl/gaz"
)

// ModuleOption configures the eventbus module.
type ModuleOption func(*moduleConfig)

type moduleConfig struct {
    // Currently no configurable options exposed
    // Placeholder for future extensibility (e.g., WithBufferSize)
}

func defaultModuleConfig() *moduleConfig {
    return &moduleConfig{}
}

// NewModule creates an eventbus module with the given options.
// Returns a gaz.Module that provides pub/sub infrastructure.
//
// Prerequisites:
//   - *slog.Logger must be registered (automatically registered by gaz.New())
//
// Note: EventBus is auto-created during gaz.New() and registered in the
// container. This module provides explicit opt-in and future configuration.
//
// Example:
//
//     app := gaz.New()
//     app.Use(eventbus.NewModule())
func NewModule(opts ...ModuleOption) gaz.Module {
    cfg := defaultModuleConfig()
    for _, opt := range opts {
        opt(cfg)
    }

    return gaz.NewModule("eventbus").
        Provide(func(c *gaz.Container) error {
            // Validate prerequisites
            if !gaz.Has[*slog.Logger](c) {
                return fmt.Errorf("eventbus module requires *slog.Logger to be registered")
            }
            
            // EventBus is auto-created in gaz.New() and registered.
            // This module validates prerequisites and serves as foundation
            // for future options (e.g., WithBufferSize, WithErrorHandler).
            return nil
        }).
        Build()
}
```

Note: EventBus is already created and registered in gaz.New(). This module provides:
1. Explicit opt-in for eventbus subsystem
2. Prerequisite validation
3. Foundation for future configuration options
  </action>
  <verify>
Run: `go build ./eventbus/...` — compiles successfully
  </verify>
  <done>
eventbus/module.go exists with NewModule() factory function
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config/module.go with NewModule()</name>
  <files>config/module.go</files>
  <action>
Create new file config/module.go with NewModule() factory:

```go
package config

import (
    "github.com/petabytecl/gaz"
)

// ModuleOption configures the config module.
type ModuleOption func(*moduleConfig)

type moduleConfig struct {
    // Currently no configurable options exposed
    // Placeholder for future extensibility (e.g., WithWatcher)
}

func defaultModuleConfig() *moduleConfig {
    return &moduleConfig{}
}

// NewModule creates a config module with the given options.
// Returns a gaz.Module that provides configuration infrastructure.
//
// Note: Configuration is typically set up via gaz.App.WithConfig().
// This module provides explicit opt-in for advanced use cases like
// additional config sources or watchers.
//
// Example:
//
//     app := gaz.New()
//     app.Use(config.NewModule())
func NewModule(opts ...ModuleOption) gaz.Module {
    cfg := defaultModuleConfig()
    for _, opt := range opts {
        opt(cfg)
    }

    return gaz.NewModule("config").
        Provide(func(c *gaz.Container) error {
            // Config infrastructure is set up in gaz.New() and
            // configured via WithConfig(). This module provides
            // a placeholder for future extensions like:
            // - Additional config sources
            // - Config watchers
            // - Remote config providers
            return nil
        }).
        Build()
}
```

Note: Config is handled primarily through gaz.App.WithConfig(). This module provides:
1. Consistent API with other subsystem packages
2. Foundation for future advanced config features
3. Explicit opt-in pattern
  </action>
  <verify>
Run: `go build ./config/...` — compiles successfully
  </verify>
  <done>
config/module.go exists with NewModule() factory function
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for eventbus and config NewModule()</name>
  <files>eventbus/module_test.go, config/module_test.go</files>
  <action>
Create eventbus/module_test.go:

```go
package eventbus

import (
    "testing"

    "github.com/petabytecl/gaz"
    "github.com/stretchr/testify/require"
)

func TestNewModule(t *testing.T) {
    t.Run("zero arguments works with defaults", func(t *testing.T) {
        app := gaz.New()
        app.Use(NewModule())
        
        err := app.Build()
        require.NoError(t, err)
    })
    
    t.Run("returns valid gaz.Module", func(t *testing.T) {
        mod := NewModule()
        require.NotNil(t, mod)
        require.Equal(t, "eventbus", mod.Name())
    })
}
```

Create config/module_test.go:

```go
package config

import (
    "testing"

    "github.com/petabytecl/gaz"
    "github.com/stretchr/testify/require"
)

func TestNewModule(t *testing.T) {
    t.Run("zero arguments works with defaults", func(t *testing.T) {
        app := gaz.New()
        app.Use(NewModule())
        
        err := app.Build()
        require.NoError(t, err)
    })
    
    t.Run("returns valid gaz.Module", func(t *testing.T) {
        mod := NewModule()
        require.NotNil(t, mod)
        require.Equal(t, "config", mod.Name())
    })
}
```
  </action>
  <verify>
Run: `go test ./eventbus/... -run TestNewModule -v` — passes
Run: `go test ./config/... -run TestNewModule -v` — passes
  </verify>
  <done>
Tests verify NewModule() works with zero args and returns proper gaz.Module
  </done>
</task>

</tasks>

<verification>
1. `go build ./eventbus/... ./config/...` — compiles
2. `go test ./eventbus/... ./config/... -v` — all tests pass
3. `go doc eventbus.NewModule` — shows documentation
4. `go doc config.NewModule` — shows documentation
</verification>

<success_criteria>
- [ ] eventbus/module.go exists with NewModule(), ModuleOption
- [ ] config/module.go exists with NewModule(), ModuleOption
- [ ] Both NewModule() functions return gaz.Module directly
- [ ] Both work with zero arguments
- [ ] Tests verify basic functionality
- [ ] MOD-03 (eventbus, config): packages export NewModule()
</success_criteria>

<output>
After completion, create `.planning/phases/26-module-service-consolidation/26-04-SUMMARY.md`
</output>
