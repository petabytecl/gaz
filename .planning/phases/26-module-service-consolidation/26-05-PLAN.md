---
phase: 26-module-service-consolidation
plan: 05
type: execute
wave: 3
depends_on: ["26-02", "26-03", "26-04"]
files_modified:
  - di/doc.go
  - compat.go
autonomous: true

must_haves:
  truths:
    - "di package doc.go explains when to import di vs gaz"
    - "New users understand gaz is the preferred entry point"
    - "All existing tests pass with consolidated module system"
  artifacts:
    - path: "di/doc.go"
      provides: "Documentation of di vs gaz relationship"
      contains: "When to Use di vs gaz"
    - path: "compat.go"
      provides: "Type re-exports from di"
      contains: "type Container"
  key_links:
    - from: "di/doc.go"
      to: "user documentation"
      via: "godoc"
      pattern: "import.*gaz"
---

<objective>
Document the di/gaz relationship clearly so new users understand which package to import.

Purpose: MOD-04 requires clear documentation of the import relationship. New users should immediately know that `gaz` is the entry point while `di` is available for advanced standalone use.

Output: Updated di/doc.go with clear guidance, verified full test suite passes
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-module-service-consolidation/26-CONTEXT.md
@.planning/phases/26-module-service-consolidation/26-RESEARCH.md
@.planning/phases/26-module-service-consolidation/26-01-SUMMARY.md
@.planning/phases/26-module-service-consolidation/26-02-SUMMARY.md
@.planning/phases/26-module-service-consolidation/26-03-SUMMARY.md
@.planning/phases/26-module-service-consolidation/26-04-SUMMARY.md

@di/doc.go
@compat.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update di/doc.go with di vs gaz guidance</name>
  <files>di/doc.go</files>
  <action>
Update di/doc.go to include clear guidance on when to use di vs gaz:

```go
// Package di provides a lightweight, type-safe dependency injection container.
//
// # When to Use di vs gaz
//
// Most applications should import "github.com/petabytecl/gaz" directly:
//
//     import "github.com/petabytecl/gaz"
//
//     app := gaz.New()
//     gaz.For[*MyService](app.Container()).Provider(NewMyService)
//     app.Build()
//     app.Run(ctx)
//
// The gaz package re-exports all di types (Container, For, Resolve, Has, etc.)
// and adds application lifecycle, configuration, workers, cron, health, and eventbus.
//
// Import di directly only when:
//   - You need standalone DI without gaz.App lifecycle
//   - You're building a library that depends only on the container
//   - You want to minimize import surface in tests
//
// # Re-exported Types
//
// The following types are re-exported by the gaz package:
//   - Container → gaz.Container
//   - For[T]() → gaz.For[T]()
//   - Resolve[T]() → gaz.Resolve[T]()
//   - Has[T]() → gaz.Has[T]()
//   - Named() → gaz.Named()
//   - RegistrationBuilder → gaz.RegistrationBuilder
//   - ServiceWrapper → gaz.ServiceWrapper (internal)
//   - TypeName[T]() → gaz.TypeName[T]() (internal)
//
// For full application development, prefer the gaz package.
//
// # Container Usage
//
// Create a container, register services, build, and resolve:
//
//     c := di.NewContainer()
//     di.For[*Database](c).Provider(NewDatabase)
//     di.For[*UserService](c).Provider(NewUserService)
//     if err := c.Build(); err != nil {
//         log.Fatal(err)
//     }
//     svc, _ := di.Resolve[*UserService](c)
//
// See the gaz package for full application examples with lifecycle management.
package di
```

Preserve any existing content that doesn't conflict with this new guidance.
  </action>
  <verify>
Run: `go doc di` — shows the updated package documentation
Run: `go build ./di/...` — compiles successfully
  </verify>
  <done>
di/doc.go contains clear guidance on when to use di vs gaz
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify compat.go re-exports are documented</name>
  <files>compat.go</files>
  <action>
Verify compat.go has proper documentation for re-exported types. If documentation is missing or unclear, update it:

1. Check that compat.go exists and contains type aliases like:
```go
// Container is the dependency injection container.
// See di.Container for details.
type Container = di.Container
```

2. Ensure each re-exported type has a brief doc comment pointing to the original.

3. If compat.go is missing doc comments, add them:
```go
// Container is the dependency injection container.
// This is an alias for di.Container.
type Container = di.Container

// RegistrationBuilder provides fluent API for registering services.
// This is an alias for di.RegistrationBuilder.
type RegistrationBuilder[T any] = di.RegistrationBuilder[T]

// ServiceWrapper wraps registered services.
// This is an alias for di.ServiceWrapper.
type ServiceWrapper = di.ServiceWrapper
```

Existing doc comments should be preserved if they're adequate.
  </action>
  <verify>
Run: `go doc gaz.Container` — shows Container documentation
Run: `go build ./...` — compiles successfully
  </verify>
  <done>
compat.go re-exports have adequate documentation
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and verify all requirements</name>
  <files>(verification only, no file changes)</files>
  <action>
Run comprehensive verification to confirm all MOD requirements are met:

1. MOD-01: service.Builder absorbed into gaz.App
   - Verify: `grep -r "HealthConfigProvider" app.go` shows auto-registration logic

2. MOD-02: gaz/service package removed
   - Verify: `ls service/ 2>&1` returns "No such file or directory"

3. MOD-03: All subsystem packages export NewModule()
   - Verify: `go doc health.NewModule` shows factory function
   - Verify: `go doc worker.NewModule` shows factory function
   - Verify: `go doc cron.NewModule` shows factory function
   - Verify: `go doc eventbus.NewModule` shows factory function
   - Verify: `go doc config.NewModule` shows factory function

4. MOD-04: di/gaz relationship documented
   - Verify: `go doc di | grep -A5 "When to Use"` shows guidance

5. All tests pass:
   - Run: `go test ./... -count=1`
   - All tests must pass with consolidated module system

6. Build succeeds:
   - Run: `go build ./...`
  </action>
  <verify>
Run: `go test ./... -count=1` — all tests pass
Run: `go build ./...` — all packages build
  </verify>
  <done>
All MOD requirements verified, full test suite passes
  </done>
</task>

</tasks>

<verification>
1. `go test ./... -count=1` — all tests pass
2. `go build ./...` — all packages build
3. `go doc di` — shows di vs gaz guidance
4. `ls service/` — directory does not exist
5. For each subsystem: `go doc {pkg}.NewModule` — shows factory
</verification>

<success_criteria>
- [ ] di/doc.go contains "When to Use di vs gaz" section
- [ ] di/doc.go lists re-exported types
- [ ] compat.go re-exports have documentation
- [ ] Full test suite passes (`go test ./... -count=1`)
- [ ] All MOD requirements verified:
  - [ ] MOD-01: HealthConfigProvider in gaz.App.Build()
  - [ ] MOD-02: service/ directory deleted
  - [ ] MOD-03: All 5 packages have NewModule()
  - [ ] MOD-04: di/gaz relationship documented
</success_criteria>

<output>
After completion, create `.planning/phases/26-module-service-consolidation/26-05-SUMMARY.md`
</output>
