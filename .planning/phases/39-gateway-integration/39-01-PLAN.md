---
phase: 39-gateway-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/gateway/config.go
  - server/gateway/headers.go
  - server/gateway/gateway.go
  - server/gateway/errors.go
autonomous: true

must_haves:
  truths:
    - "Gateway can be configured with port, gRPC target, and CORS options"
    - "HTTP headers are correctly forwarded to gRPC metadata"
    - "Gateway auto-discovers services implementing GatewayRegistrar"
    - "Gateway connects to gRPC server via loopback"
    - "Error responses use RFC 7807 Problem Details format"
    - "Dev mode includes debug info, prod mode strips it"
  artifacts:
    - path: "server/gateway/config.go"
      provides: "Config, CORSConfig structs with defaults and validation"
      exports: ["Config", "CORSConfig", "DefaultConfig", "DefaultCORSConfig", "DefaultPort"]
    - path: "server/gateway/headers.go"
      provides: "Header matcher for HTTP-to-gRPC metadata forwarding"
      exports: ["AllowedHeaders", "HeaderMatcher"]
    - path: "server/gateway/gateway.go"
      provides: "Gateway struct, GatewayRegistrar interface, lifecycle"
      exports: ["Gateway", "GatewayRegistrar", "NewGateway"]
    - path: "server/gateway/errors.go"
      provides: "RFC 7807 Problem Details error handler"
      exports: ["ProblemDetails", "ErrorHandler"]
  key_links:
    - from: "server/gateway/gateway.go"
      to: "di.ResolveAll[GatewayRegistrar]"
      via: "OnStart auto-discovery"
      pattern: "di\\.ResolveAll\\[GatewayRegistrar\\]"
    - from: "server/gateway/gateway.go"
      to: "grpc.NewClient"
      via: "loopback connection"
      pattern: "grpc\\.NewClient"
    - from: "server/gateway/gateway.go"
      to: "runtime.NewServeMux"
      via: "ServeMux with options"
      pattern: "runtime\\.NewServeMux"
---

<objective>
Implement the core Gateway package with configuration, header matching, main Gateway struct with lifecycle, and RFC 7807 error handling.

Purpose: Create the foundation for HTTP-to-gRPC translation using grpc-gateway v2, with auto-discovery of services via DI.

Output: Four source files that compile and provide the core Gateway functionality.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-gateway-integration/39-CONTEXT.md
@.planning/phases/39-gateway-integration/39-RESEARCH.md

# Reference existing patterns
@server/grpc/config.go
@server/grpc/server.go
@server/http/server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create configuration and header matcher</name>
  <files>server/gateway/config.go, server/gateway/headers.go</files>
  <action>
  Create the configuration and header matching for the Gateway package.

  **server/gateway/config.go:**
  - Define `DefaultPort = 8080` (HTTP gateway port, distinct from gRPC 50051 and health 9090)
  - Define `Config` struct with fields:
    - `Port int` - Gateway HTTP port (default 8080)
    - `GRPCTarget string` - gRPC server target for loopback (default "localhost:50051")
    - `CORS CORSConfig` - CORS configuration
  - Add JSON/YAML/mapstructure tags for all fields
  - Define `CORSConfig` struct with fields:
    - `AllowedOrigins []string`
    - `AllowedMethods []string`
    - `AllowedHeaders []string`
    - `ExposedHeaders []string`
    - `AllowCredentials bool`
    - `MaxAge int` (seconds)
  - Implement `DefaultConfig() Config` returning safe defaults
  - Implement `DefaultCORSConfig(devMode bool) CORSConfig`:
    - Dev mode: AllowedOrigins: ["*"], AllowedMethods: [GET, POST, PUT, PATCH, DELETE, OPTIONS], AllowedHeaders: ["*"], AllowCredentials: false, MaxAge: 86400
    - Prod mode: AllowedOrigins: [] (must be configured), AllowedMethods: [GET, POST, PUT, PATCH, DELETE], AllowedHeaders: [Authorization, Content-Type, X-Request-ID], ExposedHeaders: [X-Request-ID], AllowCredentials: true, MaxAge: 86400
  - Implement `SetDefaults()` method for config.Defaulter interface
  - Implement `Validate() error` method for config.Validator interface (validate port range 1-65535)

  **server/gateway/headers.go:**
  - Define `AllowedHeaders` slice containing headers to forward: "authorization", "x-request-id", "x-correlation-id", "x-forwarded-for", "x-forwarded-host", "accept-language"
  - Implement `HeaderMatcher(key string) (string, bool)` function:
    - Check if lowercase key is in AllowedHeaders
    - If yes, return (key, true)
    - Otherwise, return `runtime.DefaultHeaderMatcher(key)` to fall back to default behavior
  - Import `github.com/grpc-ecosystem/grpc-gateway/v2/runtime`

  **Important:** Run `go get github.com/grpc-ecosystem/grpc-gateway/v2@v2.27.7` and `go get github.com/rs/cors` to add dependencies.

  Follow existing patterns from `server/grpc/config.go` for Config struct style.
  </action>
  <verify>
  - `go build ./server/gateway/...` succeeds
  - Config and CORSConfig structs exported
  - HeaderMatcher function compiles and is exported
  </verify>
  <done>
  - config.go exports Config, CORSConfig, DefaultConfig, DefaultCORSConfig, DefaultPort
  - headers.go exports AllowedHeaders, HeaderMatcher
  - Both files compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Gateway struct with lifecycle</name>
  <files>server/gateway/gateway.go</files>
  <action>
  Create the main Gateway struct and GatewayRegistrar interface.

  **server/gateway/gateway.go:**
  - Define `GatewayRegistrar` interface:
    ```go
    type GatewayRegistrar interface {
        RegisterGateway(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error
    }
    ```
    Services implement this to register their HTTP handlers with the Gateway.

  - Define `Gateway` struct with fields:
    - `config Config`
    - `mux *runtime.ServeMux`
    - `conn *grpc.ClientConn`
    - `container *di.Container`
    - `logger *slog.Logger`
    - `devMode bool`
    - `handler http.Handler` (the final handler with CORS wrapping)

  - Implement `NewGateway(cfg Config, logger *slog.Logger, container *di.Container, devMode bool) *Gateway`:
    - Store all parameters
    - Return Gateway pointer

  - Implement `OnStart(ctx context.Context) error` (di.Starter):
    1. Determine gRPC target: use config.GRPCTarget if set, otherwise "localhost:50051"
    2. Create loopback connection with `grpc.NewClient(target, grpc.WithTransportCredentials(insecure.NewCredentials()))`
    3. Store connection in g.conn
    4. Create ServeMux with options:
       - `runtime.WithErrorHandler(g.errorHandler)` (call method from errors.go)
       - `runtime.WithIncomingHeaderMatcher(HeaderMatcher)`
    5. Store mux in g.mux
    6. Auto-discover registrars with `di.ResolveAll[GatewayRegistrar](g.container)`
    7. For each registrar, call `r.RegisterGateway(ctx, g.mux, g.conn)`
    8. Build CORS handler wrapping mux using rs/cors:
       ```go
       corsHandler := cors.New(cors.Options{
           AllowedOrigins:   g.config.CORS.AllowedOrigins,
           AllowedMethods:   g.config.CORS.AllowedMethods,
           AllowedHeaders:   g.config.CORS.AllowedHeaders,
           ExposedHeaders:   g.config.CORS.ExposedHeaders,
           AllowCredentials: g.config.CORS.AllowCredentials,
           MaxAge:           g.config.CORS.MaxAge,
           Debug:            g.devMode,
       })
       g.handler = corsHandler.Handler(g.mux)
       ```
    9. Log info: "Gateway initialized", services count, grpc target
    10. Return nil

  - Implement `OnStop(ctx context.Context) error` (di.Stopper):
    1. If g.conn is not nil, close it
    2. Log "Gateway stopped"
    3. Return nil

  - Implement `Handler() http.Handler`:
    - Return g.handler (for use with http.Server)

  - Implement `errorHandler` method that calls the ErrorHandler from errors.go (will be implemented in Task 3)

  **Note:** The actual HTTP serving is done by the existing `server/http.Server` - Gateway just provides the http.Handler.

  Use `grpc.NewClient` (NOT deprecated `grpc.Dial`).
  </action>
  <verify>
  - `go build ./server/gateway/...` succeeds
  - Gateway struct exported with NewGateway constructor
  - GatewayRegistrar interface exported
  - OnStart, OnStop, Handler methods exist
  </verify>
  <done>
  - gateway.go exports Gateway, GatewayRegistrar, NewGateway
  - Gateway implements di.Starter and di.Stopper interfaces
  - Handler() returns http.Handler for use with server/http.Server
  </done>
</task>

<task type="auto">
  <name>Task 3: Create RFC 7807 error handler</name>
  <files>server/gateway/errors.go</files>
  <action>
  Create the RFC 7807 Problem Details error handler.

  **server/gateway/errors.go:**
  - Define `ProblemDetails` struct:
    ```go
    type ProblemDetails struct {
        Type     string `json:"type"`                        // URI reference identifying problem type
        Title    string `json:"title"`                       // Human-readable summary
        Status   int    `json:"status"`                      // HTTP status code
        Detail   string `json:"detail,omitempty"`            // Human-readable explanation
        Instance string `json:"instance,omitempty"`          // URI reference (correlation ID)
        // Dev mode extensions
        Code string `json:"code,omitempty"` // gRPC code name (dev only)
    }
    ```

  - Implement `ErrorHandler(devMode bool) runtime.ErrorHandlerFunc`:
    Returns a closure that creates RFC 7807 responses:
    ```go
    func ErrorHandler(devMode bool) runtime.ErrorHandlerFunc {
        return func(ctx context.Context, mux *runtime.ServeMux, marshaler runtime.Marshaler, w http.ResponseWriter, r *http.Request, err error) {
            s := status.Convert(err)
            httpStatus := runtime.HTTPStatusFromCode(s.Code())

            problem := ProblemDetails{
                Type:     fmt.Sprintf("https://grpc.io/docs/guides/status-codes/#%s", strings.ToLower(s.Code().String())),
                Title:    s.Code().String(),
                Status:   httpStatus,
                Instance: r.Header.Get("X-Request-ID"),
            }

            if devMode {
                problem.Detail = s.Message()
                problem.Code = s.Code().String()
            } else {
                // Sanitize for production - use generic message
                problem.Detail = http.StatusText(httpStatus)
            }

            w.Header().Set("Content-Type", "application/problem+json")
            w.WriteHeader(httpStatus)
            json.NewEncoder(w).Encode(problem)
        }
    }
    ```

  - Import required packages:
    - `context`
    - `encoding/json`
    - `fmt`
    - `net/http`
    - `strings`
    - `github.com/grpc-ecosystem/grpc-gateway/v2/runtime`
    - `google.golang.org/grpc/status`

  **Key details:**
  - Use `status.Convert(err)` to convert error to gRPC status
  - Use `runtime.HTTPStatusFromCode` for standard gRPC-to-HTTP status mapping
  - Dev mode exposes actual error message and gRPC code
  - Prod mode uses generic HTTP status text (no internal details)
  - Content-Type is "application/problem+json" per RFC 7807
  </action>
  <verify>
  - `go build ./server/gateway/...` succeeds
  - ProblemDetails struct exported
  - ErrorHandler function exported and returns runtime.ErrorHandlerFunc
  </verify>
  <done>
  - errors.go exports ProblemDetails, ErrorHandler
  - Error responses include type, title, status, detail, instance fields
  - Dev mode includes gRPC code, prod mode strips details
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./server/gateway/...` - all files compile
2. `go vet ./server/gateway/...` - no vet issues
3. Package exports: Config, CORSConfig, Gateway, GatewayRegistrar, NewGateway, ProblemDetails, ErrorHandler, HeaderMatcher
4. No linting errors: `golangci-lint run ./server/gateway/...`
</verification>

<success_criteria>
- Gateway package exists at server/gateway/
- 4 source files: config.go, headers.go, gateway.go, errors.go
- Gateway implements di.Starter, di.Stopper
- GatewayRegistrar interface defined for service auto-discovery
- CORS configuration supports dev/prod modes
- RFC 7807 error responses with dev/prod differentiation
- Package compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/39-gateway-integration/39-01-SUMMARY.md`
</output>
