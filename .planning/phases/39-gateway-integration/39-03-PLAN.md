---
phase: 39-gateway-integration
plan: 03
type: execute
wave: 3
depends_on: ["39-02"]
files_modified:
  - server/gateway/config_test.go
  - server/gateway/headers_test.go
  - server/gateway/gateway_test.go
  - server/gateway/errors_test.go
  - server/gateway/module_test.go
autonomous: true

must_haves:
  truths:
    - "Config defaults are correctly applied"
    - "Config validation catches invalid ports"
    - "Header matcher forwards allowed headers"
    - "Gateway OnStart discovers and registers services"
    - "Gateway OnStop closes connection"
    - "Error handler produces RFC 7807 responses"
    - "Module registers Gateway with container"
    - "Coverage is at least 90%"
  artifacts:
    - path: "server/gateway/config_test.go"
      provides: "Config and CORSConfig tests"
      contains: "TestConfig"
    - path: "server/gateway/headers_test.go"
      provides: "Header matcher tests"
      contains: "TestHeaderMatcher"
    - path: "server/gateway/gateway_test.go"
      provides: "Gateway lifecycle tests"
      contains: "TestGateway"
    - path: "server/gateway/errors_test.go"
      provides: "RFC 7807 error handler tests"
      contains: "TestErrorHandler"
    - path: "server/gateway/module_test.go"
      provides: "Module registration tests"
      contains: "TestModule"
  key_links:
    - from: "server/gateway/*_test.go"
      to: "server/gateway/*.go"
      via: "testify assertions"
      pattern: "require\\.|assert\\."
---

<objective>
Create comprehensive tests for the Gateway package to achieve 90%+ coverage.

Purpose: Ensure Gateway functionality is correct and maintainable via thorough test coverage.

Output: Test files for all Gateway components with 90%+ coverage.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-gateway-integration/39-01-SUMMARY.md
@.planning/phases/39-gateway-integration/39-02-SUMMARY.md

# Reference existing test patterns
@server/grpc/server_test.go
@server/grpc/config_test.go
@server/grpc/module_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config and headers tests</name>
  <files>server/gateway/config_test.go, server/gateway/headers_test.go</files>
  <action>
  Create tests for configuration and header matching using testify suite pattern.

  **server/gateway/config_test.go:**
  Use testify suite pattern:
  ```go
  type ConfigTestSuite struct {
      suite.Suite
  }

  func TestConfigTestSuite(t *testing.T) {
      suite.Run(t, new(ConfigTestSuite))
  }
  ```

  Test cases:
  - `TestDefaultConfig`: DefaultConfig() returns expected values (port 8080, etc.)
  - `TestDefaultCORSConfig_DevMode`: Wide-open CORS settings
  - `TestDefaultCORSConfig_ProdMode`: Strict CORS settings (empty origins, credentials enabled)
  - `TestConfig_SetDefaults`: Zero values get defaults applied
  - `TestConfig_SetDefaults_PreservesExisting`: Non-zero values are preserved
  - `TestConfig_Validate_Valid`: Valid config passes validation
  - `TestConfig_Validate_InvalidPort_Zero`: Port 0 fails validation
  - `TestConfig_Validate_InvalidPort_Negative`: Port -1 fails validation
  - `TestConfig_Validate_InvalidPort_TooHigh`: Port 70000 fails validation

  **server/gateway/headers_test.go:**
  Test cases:
  - `TestHeaderMatcher_AllowedHeaders`: Each allowed header returns (key, true)
  - `TestHeaderMatcher_Authorization`: "Authorization" -> (key, true)
  - `TestHeaderMatcher_XRequestID`: "X-Request-ID" -> (key, true)
  - `TestHeaderMatcher_XCorrelationID`: "X-Correlation-ID" -> (key, true)
  - `TestHeaderMatcher_XForwardedFor`: "X-Forwarded-For" -> (key, true)
  - `TestHeaderMatcher_AcceptLanguage`: "Accept-Language" -> (key, true)
  - `TestHeaderMatcher_CaseInsensitive`: Headers work regardless of case
  - `TestHeaderMatcher_UnknownHeader`: Unknown header falls back to default matcher
  - `TestAllowedHeaders`: AllowedHeaders slice contains expected values

  Use `require.Equal`, `require.True`, `require.False` for assertions.
  </action>
  <verify>
  - `go test -v ./server/gateway/... -run TestConfig` passes
  - `go test -v ./server/gateway/... -run TestHeader` passes
  - All test cases cover expected scenarios
  </verify>
  <done>
  - config_test.go tests Config, CORSConfig, SetDefaults, Validate
  - headers_test.go tests HeaderMatcher for all allowed and unknown headers
  - Tests use testify suite pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Create gateway and error handler tests</name>
  <files>server/gateway/gateway_test.go, server/gateway/errors_test.go</files>
  <action>
  Create tests for Gateway struct and RFC 7807 error handler.

  **server/gateway/gateway_test.go:**
  Use testify suite pattern:
  ```go
  type GatewayTestSuite struct {
      suite.Suite
  }

  func TestGatewayTestSuite(t *testing.T) {
      suite.Run(t, new(GatewayTestSuite))
  }
  ```

  Test cases:
  - `TestNewGateway`: Constructor stores config and parameters
  - `TestGateway_OnStart_CreatesConnection`: OnStart creates gRPC client connection
  - `TestGateway_OnStart_DiscoveryNoServices`: Works with zero registrars
  - `TestGateway_OnStart_DiscoveryWithServices`: Registers discovered services (mock registrar)
  - `TestGateway_OnStop`: Closes connection cleanly
  - `TestGateway_OnStop_NilConnection`: Handles nil connection gracefully
  - `TestGateway_Handler`: Returns non-nil http.Handler after OnStart

  For testing with mock registrar, create a test helper:
  ```go
  type mockRegistrar struct {
      called bool
  }

  func (m *mockRegistrar) RegisterGateway(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
      m.called = true
      return nil
  }
  ```

  Register the mock with di.For[GatewayRegistrar](c).Instance(&mockRegistrar{}).

  **server/gateway/errors_test.go:**
  Test cases:
  - `TestProblemDetails_JSONSerialization`: Struct serializes to expected JSON format
  - `TestErrorHandler_DevMode`: Returns full error details
  - `TestErrorHandler_ProdMode`: Returns only generic status text
  - `TestErrorHandler_StatusMapping_NotFound`: gRPC NotFound -> HTTP 404
  - `TestErrorHandler_StatusMapping_InvalidArgument`: gRPC InvalidArgument -> HTTP 400
  - `TestErrorHandler_StatusMapping_Unauthenticated`: gRPC Unauthenticated -> HTTP 401
  - `TestErrorHandler_StatusMapping_PermissionDenied`: gRPC PermissionDenied -> HTTP 403
  - `TestErrorHandler_StatusMapping_Internal`: gRPC Internal -> HTTP 500
  - `TestErrorHandler_ContentType`: Response has Content-Type: application/problem+json
  - `TestErrorHandler_InstanceHeader`: Uses X-Request-ID as instance field

  Use `httptest.NewRecorder()` and `http.NewRequest()` for testing error handler.
  Create gRPC errors with `status.Error(codes.NotFound, "not found")`.
  </action>
  <verify>
  - `go test -v ./server/gateway/... -run TestGateway` passes
  - `go test -v ./server/gateway/... -run TestError` passes
  - Error handler tests verify RFC 7807 format
  </verify>
  <done>
  - gateway_test.go tests NewGateway, OnStart, OnStop, Handler
  - errors_test.go tests ErrorHandler for dev/prod modes and status mappings
  - Tests verify RFC 7807 Problem Details format
  </done>
</task>

<task type="auto">
  <name>Task 3: Create module tests and verify coverage</name>
  <files>server/gateway/module_test.go</files>
  <action>
  Create tests for module registration and verify overall coverage.

  **server/gateway/module_test.go:**
  Use testify suite pattern following server/grpc/module_test.go:
  ```go
  type ModuleTestSuite struct {
      suite.Suite
  }

  func TestModuleTestSuite(t *testing.T) {
      suite.Run(t, new(ModuleTestSuite))
  }
  ```

  Test cases:
  - `TestNewModule_Defaults`: NewModule() creates module with default config
  - `TestNewModule_WithPort`: WithPort(9000) sets port
  - `TestNewModule_WithGRPCTarget`: WithGRPCTarget("localhost:50051") sets target
  - `TestNewModule_WithDevMode`: WithDevMode(true) enables dev mode
  - `TestNewModule_WithCORS`: WithCORS(CORSConfig{...}) sets custom CORS
  - `TestNewModule_RegistersConfig`: Module registers Config in container
  - `TestNewModule_RegistersGateway`: Module registers *Gateway in container
  - `TestModule_GatewayIsEager`: Gateway has eager lifecycle
  - `TestNewModuleWithFlags_DefinesFlags`: Flags are added to FlagSet
  - `TestNewModuleWithFlags_ReadsValues`: Flag values are used at registration time

  For flag tests, use:
  ```go
  fs := pflag.NewFlagSet("test", pflag.ContinueOnError)
  mod := NewModuleWithFlags(fs)
  fs.Parse([]string{"--gateway-port=9000"})
  // Then verify config uses 9000
  ```

  After all tests pass, verify coverage:
  ```bash
  go test -coverprofile=coverage.out ./server/gateway/...
  go tool cover -func=coverage.out | grep gateway
  ```

  **Coverage target:** 90%+ for server/gateway package.

  If coverage is below 90%, add additional tests for uncovered branches:
  - Edge cases in Config validation
  - Error paths in Gateway.OnStart
  - Nil handling in various methods
  </action>
  <verify>
  - `go test -v ./server/gateway/... -run TestModule` passes
  - `go test -race ./server/gateway/...` passes (race detection)
  - `go test -cover ./server/gateway/...` shows 90%+ coverage
  - `make test` passes with gateway package included
  </verify>
  <done>
  - module_test.go tests NewModule, NewModuleWithFlags, options
  - All tests pass with race detection
  - Package coverage is 90%+
  - `make test` passes
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go test -race ./server/gateway/...` - all tests pass
2. `go test -cover ./server/gateway/...` - 90%+ coverage
3. `make test` - full test suite passes
4. `make lint` - no linting errors in tests
</verification>

<success_criteria>
- 5 test files: config_test.go, headers_test.go, gateway_test.go, errors_test.go, module_test.go
- All tests use testify suite pattern
- Tests cover config, headers, gateway lifecycle, error handling, module registration
- Coverage is 90%+ for server/gateway package
- Race detection passes
- Full test suite (make test) passes
</success_criteria>

<output>
After completion, create `.planning/phases/39-gateway-integration/39-03-SUMMARY.md`
</output>
