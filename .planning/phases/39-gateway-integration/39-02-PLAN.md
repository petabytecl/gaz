---
phase: 39-gateway-integration
plan: 02
type: execute
wave: 2
depends_on: ["39-01"]
files_modified:
  - server/gateway/module.go
  - server/gateway/doc.go
autonomous: true

must_haves:
  truths:
    - "Gateway can be added to an app via NewModule()"
    - "Gateway port is configurable via --gateway-port flag"
    - "gRPC target is configurable via --gateway-grpc-target flag"
    - "Dev mode is inherited from gRPC server configuration"
    - "Gateway integrates with existing server/http.Server for serving"
  artifacts:
    - path: "server/gateway/module.go"
      provides: "DI module registration with CLI flag support"
      exports: ["NewModule", "NewModuleWithFlags", "ModuleOption", "WithPort", "WithGRPCTarget", "WithDevMode", "WithCORS"]
    - path: "server/gateway/doc.go"
      provides: "Package documentation"
      contains: "Package gateway provides"
  key_links:
    - from: "server/gateway/module.go"
      to: "di.For[*Gateway]"
      via: "Provider registration"
      pattern: "di\\.For\\[\\*Gateway\\]"
    - from: "server/gateway/module.go"
      to: "server/http.Server"
      via: "SetHandler integration"
      pattern: "http\\.Server"
---

<objective>
Create the Gateway DI module with options pattern, CLI flag support, and package documentation.

Purpose: Enable easy integration of Gateway into gaz applications via NewModule() with configuration options and CLI flags for runtime configuration.

Output: Module that registers Gateway with the DI container, plus package docs.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-gateway-integration/39-CONTEXT.md

# Reference existing module patterns
@server/grpc/module.go
@server/http/module.go

# Reference prior plan
@.planning/phases/39-gateway-integration/39-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Gateway module with options</name>
  <files>server/gateway/module.go</files>
  <action>
  Create the DI module following existing patterns from server/grpc/module.go.

  **server/gateway/module.go:**

  - Define `ModuleOption func(*moduleConfig)` type

  - Define internal `moduleConfig` struct:
    ```go
    type moduleConfig struct {
        port       int
        grpcTarget string
        cors       *CORSConfig
        devMode    bool
    }
    ```

  - Implement `defaultModuleConfig() *moduleConfig`:
    - port: DefaultPort (8080)
    - grpcTarget: "" (will use default "localhost:50051")
    - cors: nil (will use DefaultCORSConfig based on devMode)
    - devMode: false

  - Implement option functions:
    - `WithPort(port int) ModuleOption` - sets gateway HTTP port
    - `WithGRPCTarget(target string) ModuleOption` - sets gRPC server target for loopback
    - `WithDevMode(enabled bool) ModuleOption` - enables dev mode (verbose errors, debug CORS)
    - `WithCORS(cfg CORSConfig) ModuleOption` - sets custom CORS configuration

  - Implement `NewModule(opts ...ModuleOption) di.Module`:
    1. Apply options to default config
    2. Return `di.NewModuleFunc("gateway", func(c *di.Container) error { ... })`
    3. Inside the module func:
       - Build Config from moduleConfig:
         ```go
         cors := cfg.cors
         if cors == nil {
             defaultCORS := DefaultCORSConfig(cfg.devMode)
             cors = &defaultCORS
         }
         gatewayCfg := Config{
             Port:       cfg.port,
             GRPCTarget: cfg.grpcTarget,
             CORS:       *cors,
         }
         ```
       - Register Config: `di.For[Config](c).Instance(gatewayCfg)`
       - Call Module(c, cfg.devMode) for component registration

  - Implement `NewModuleWithFlags(fs *pflag.FlagSet, opts ...ModuleOption) di.Module`:
    1. Apply options to get initial config
    2. Define flag pointers:
       - `--gateway-port` (int, default from config, "Gateway HTTP port")
       - `--gateway-grpc-target` (string, default "", "gRPC server target (default: localhost:<grpc-port>)")
       - `--gateway-dev-mode` (bool, default from config, "Enable development mode")
    3. Return module that reads flags at registration time:
       ```go
       return di.NewModuleFunc("gateway", func(c *di.Container) error {
           // Read flag values (deferred evaluation)
           port := *portFlag
           grpcTarget := *grpcTargetFlag
           devMode := *devModeFlag

           cors := cfg.cors
           if cors == nil {
               defaultCORS := DefaultCORSConfig(devMode)
               cors = &defaultCORS
           }
           // ... register Config and call Module()
       })
       ```

  - Implement `Module(c *di.Container, devMode bool) error`:
    1. Register Gateway with Eager lifecycle:
       ```go
       return di.For[*Gateway](c).Eager().Provider(func(c *di.Container) (*Gateway, error) {
           cfg, err := di.Resolve[Config](c)
           if err != nil {
               return nil, fmt.Errorf("resolve gateway config: %w", err)
           }
           logger, err := di.Resolve[*slog.Logger](c)
           if err != nil {
               return nil, fmt.Errorf("resolve logger: %w", err)
           }
           return NewGateway(cfg, logger, c, devMode), nil
       })
       ```

  **Integration pattern:**
  The Gateway provides an http.Handler via Handler() method. Users integrate with server/http.Server:
  ```go
  // In user code after both modules are registered:
  gateway := gaz.MustResolve[*gateway.Gateway](c)
  httpServer := gaz.MustResolve[*http.Server](c)
  httpServer.SetHandler(gateway.Handler())
  ```

  This is documented in doc.go but not automatically wired - Gateway provides the handler, HTTP server serves it.
  </action>
  <verify>
  - `go build ./server/gateway/...` succeeds
  - NewModule, NewModuleWithFlags exported
  - All ModuleOption functions exported
  - Module follows same pattern as server/grpc/module.go
  </verify>
  <done>
  - module.go exports NewModule, NewModuleWithFlags, ModuleOption, WithPort, WithGRPCTarget, WithDevMode, WithCORS
  - NewModuleWithFlags registers CLI flags for runtime configuration
  - Gateway registered as Eager so it initializes on app start
  </done>
</task>

<task type="auto">
  <name>Task 2: Create package documentation</name>
  <files>server/gateway/doc.go</files>
  <action>
  Create package documentation following existing patterns.

  **server/gateway/doc.go:**
  ```go
  // Package gateway provides an HTTP-to-gRPC gateway using grpc-gateway.
  //
  // The Gateway translates RESTful HTTP/JSON requests into gRPC calls,
  // enabling a single gRPC service to serve both gRPC and HTTP clients.
  // It uses grpc-gateway's runtime.ServeMux for request translation
  // and rs/cors for CORS handling.
  //
  // # Auto-Discovery
  //
  // Services that want HTTP exposure implement the GatewayRegistrar interface:
  //
  //     type GatewayRegistrar interface {
  //         RegisterGateway(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error
  //     }
  //
  // The Gateway auto-discovers all registered GatewayRegistrar implementations
  // via di.ResolveAll and registers them during startup.
  //
  // # Usage
  //
  // Basic usage with NewModule:
  //
  //     app := gaz.New()
  //     app.Use(grpc.NewModule())
  //     app.Use(http.NewModule(http.WithPort(8080)))
  //     app.Use(gateway.NewModule())
  //
  //     // After modules, wire the handler
  //     gateway := gaz.MustResolve[*gateway.Gateway](app.Container())
  //     httpServer := gaz.MustResolve[*http.Server](app.Container())
  //     httpServer.SetHandler(gateway.Handler())
  //
  // With CLI flags:
  //
  //     app := gaz.New()
  //     app.Use(gateway.NewModuleWithFlags(rootCmd.Flags()))
  //     // --gateway-port, --gateway-grpc-target, --gateway-dev-mode available
  //
  // # CORS Configuration
  //
  // In development mode (WithDevMode(true)), CORS is permissive:
  //   - AllowedOrigins: ["*"]
  //   - AllowedHeaders: ["*"]
  //   - AllowCredentials: false
  //
  // In production mode, CORS must be explicitly configured:
  //
  //     gateway.NewModule(gateway.WithCORS(gateway.CORSConfig{
  //         AllowedOrigins:   []string{"https://example.com"},
  //         AllowedMethods:   []string{"GET", "POST"},
  //         AllowCredentials: true,
  //     }))
  //
  // # Error Responses
  //
  // Errors are returned in RFC 7807 Problem Details format:
  //
  //     {
  //         "type": "https://grpc.io/docs/guides/status-codes/#not_found",
  //         "title": "NOT_FOUND",
  //         "status": 404,
  //         "detail": "resource not found",
  //         "instance": "req-123"
  //     }
  //
  // In production, the detail field contains only generic HTTP status text.
  // In development mode, it includes the actual gRPC error message.
  package gateway
  ```

  Follow the doc.go pattern from server/grpc/doc.go and server/http/doc.go.
  </action>
  <verify>
  - `go doc ./server/gateway` shows package documentation
  - Documentation covers GatewayRegistrar, usage, CORS, errors
  </verify>
  <done>
  - doc.go provides comprehensive package documentation
  - Examples show NewModule, NewModuleWithFlags, GatewayRegistrar usage
  - CORS dev/prod modes documented
  - RFC 7807 error format documented
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./server/gateway/...` - module compiles
2. `go doc ./server/gateway` - shows package documentation
3. Package exports: NewModule, NewModuleWithFlags, ModuleOption, WithPort, WithGRPCTarget, WithDevMode, WithCORS
4. `golangci-lint run ./server/gateway/...` - no linting errors
</verification>

<success_criteria>
- module.go provides NewModule and NewModuleWithFlags
- CLI flags: --gateway-port, --gateway-grpc-target, --gateway-dev-mode
- Gateway registered as Eager with Provider
- doc.go documents package usage, GatewayRegistrar, CORS, errors
- Package compiles and lints clean
</success_criteria>

<output>
After completion, create `.planning/phases/39-gateway-integration/39-02-SUMMARY.md`
</output>
