---
phase: 17-expose-configprovider-flags-to-cobra-cli
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config/manager.go
  - config/viper/backend.go
  - app.go
  - cobra_flags.go
autonomous: true

must_haves:
  truths:
    - "RegisterCobraFlags method exists on App"
    - "ConfigProvider flags are registered as persistent pflags on the command"
    - "Flags are bound to viper with original dot-notation key"
    - "Build() remains idempotent when RegisterCobraFlags called first"
  artifacts:
    - path: "cobra_flags.go"
      provides: "RegisterCobraFlags implementation"
      exports: ["RegisterCobraFlags"]
    - path: "config/manager.go"
      provides: "FlagBinder interface for individual flag binding"
      contains: "BindPFlag"
    - path: "config/viper/backend.go"
      provides: "BindPFlag implementation wrapping viper"
      contains: "func (b *Backend) BindPFlag"
  key_links:
    - from: "cobra_flags.go"
      to: "config/manager.go"
      via: "FlagBinder interface type assertion"
      pattern: "FlagBinder"
    - from: "cobra_flags.go"
      to: "app.go"
      via: "calls loadConfig, registerProviderValuesEarly, collectProviderConfigs"
      pattern: "a\\.loadConfig|a\\.registerProviderValuesEarly|a\\.collectProviderConfigs"
---

<objective>
Implement RegisterCobraFlags method to expose ConfigProvider flags to Cobra CLI.

Purpose: Allow CLI flags to override config values and appear in --help output. This bridges the ConfigProvider pattern with Cobra's flag system, following research recommendation for explicit flag registration before Execute().

Output: New RegisterCobraFlags method on App, FlagBinder interface for individual flag binding, idempotent config loading operations.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-expose-configprovider-flags-to-cobra-cli/17-RESEARCH.md

@cobra.go
@app.go
@provider_config.go
@config/manager.go
@config/viper/backend.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FlagBinder interface and implement BindPFlag</name>
  <files>config/manager.go, config/viper/backend.go</files>
  <action>
1. In config/manager.go, add a new FlagBinder interface (alongside existing flagBinder):

```go
// FlagBinder is implemented by backends that can bind individual pflags.
// This extends the flagBinder interface with single-flag binding support.
type FlagBinder interface {
    BindPFlag(key string, flag *pflag.Flag) error
}
```

2. In config/viper/backend.go, add the BindPFlag method:

```go
// BindPFlag binds a single pflag to a configuration key.
// This allows CLI flags to override config values via viper precedence.
func (b *Backend) BindPFlag(key string, flag *pflag.Flag) error {
    return b.v.BindPFlag(key, flag)
}
```

This wraps viper's native BindPFlag method. The key uses dot notation (e.g., "server.host") while the flag uses hyphen notation (e.g., "server-host").
  </action>
  <verify>
Run `go build ./config/...` to verify compilation.
Verify interface is satisfied: add `_ FlagBinder = (*Backend)(nil)` compile-time check.
  </verify>
  <done>
FlagBinder interface exists in config package. ViperBackend implements BindPFlag.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add idempotency tracking to App config operations</name>
  <files>app.go</files>
  <action>
1. Add tracking fields to App struct (around line 82):

```go
type App struct {
    // ... existing fields ...
    
    // Idempotency tracking for operations that may run during RegisterCobraFlags
    configLoaded           bool
    providerValuesRegistered bool
    providerConfigsCollected bool
}
```

2. Modify loadConfig() to be idempotent:

```go
func (a *App) loadConfig() error {
    if a.configLoaded {
        return nil // Already loaded
    }
    if a.configMgr == nil {
        return nil
    }
    // ... existing logic ...
    a.configLoaded = true
    return nil
}
```

3. Modify registerProviderValuesEarly() to be idempotent:

```go
func (a *App) registerProviderValuesEarly() error {
    if a.providerValuesRegistered {
        return nil // Already registered
    }
    if a.configMgr == nil {
        return nil
    }
    pv := &ProviderValues{backend: a.configMgr.Backend()}
    if err := a.registerInstance(pv); err != nil {
        return err
    }
    a.providerValuesRegistered = true
    return nil
}
```

4. Modify collectProviderConfigs() to be idempotent by adding check at start:

```go
func (a *App) collectProviderConfigs() error {
    if a.providerConfigsCollected {
        return nil // Already collected
    }
    // ... existing logic ...
    a.providerConfigsCollected = true
    return a.registerProviderFlags()
}
```

Set the flag BEFORE calling registerProviderFlags() to avoid re-entry issues.
  </action>
  <verify>
Run `go test ./... -run TestBuild` to verify Build() still works correctly.
Test that Build() is idempotent by calling it twice.
  </verify>
  <done>
loadConfig(), registerProviderValuesEarly(), and collectProviderConfigs() are idempotent.
Build() works correctly whether RegisterCobraFlags was called first or not.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement RegisterCobraFlags method</name>
  <files>cobra_flags.go</files>
  <action>
Create new file `cobra_flags.go` with RegisterCobraFlags implementation:

```go
package gaz

import (
    "fmt"
    "strings"
    "time"

    "github.com/petabytecl/gaz/config"
    "github.com/spf13/cobra"
    "github.com/spf13/pflag"
)

// RegisterCobraFlags registers ConfigProvider flags as persistent pflags on the command.
// This must be called BEFORE cmd.Execute() for flags to appear in --help output.
//
// The method:
// 1. Loads configuration (so defaults are available)
// 2. Registers ProviderValues for provider dependency injection
// 3. Collects ConfigProvider flags from registered services
// 4. Registers typed pflags on cmd.PersistentFlags()
// 5. Binds each flag to viper with the original dot-notation key
//
// Example:
//
//     app := gaz.New()
//     gaz.For[*ServerConfig](app.Container()).Provider(NewServerConfig)
//     app.RegisterCobraFlags(rootCmd)  // Register before Execute
//     app.WithCobra(rootCmd)
//     rootCmd.Execute()
func (a *App) RegisterCobraFlags(cmd *cobra.Command) error {
    // Load config (idempotent) - needed for defaults
    if err := a.loadConfig(); err != nil {
        return fmt.Errorf("loading config for flag registration: %w", err)
    }

    // Register ProviderValues early (idempotent) - needed if providers depend on it
    if err := a.registerProviderValuesEarly(); err != nil {
        return fmt.Errorf("registering provider values: %w", err)
    }

    // Collect ConfigProvider info (idempotent) - populates a.providerConfigs
    if err := a.collectProviderConfigs(); err != nil {
        return fmt.Errorf("collecting provider configs: %w", err)
    }

    // Register pflags and bind to viper
    return a.registerPFlags(cmd)
}

// registerPFlags registers pflags on the command and binds to viper.
func (a *App) registerPFlags(cmd *cobra.Command) error {
    fs := cmd.PersistentFlags()

    // Get FlagBinder from backend
    fb, ok := a.configMgr.Backend().(config.FlagBinder)
    if !ok {
        // Backend doesn't support individual flag binding, skip
        return nil
    }

    for _, entry := range a.providerConfigs {
        for _, flag := range entry.flags {
            fullKey := entry.namespace + "." + flag.Key
            flagName := configKeyToFlagName(fullKey)

            // Skip if already registered (collision prevention)
            if fs.Lookup(flagName) != nil {
                continue
            }

            // Register typed flag with default and description
            if err := registerTypedFlag(fs, flag, flagName); err != nil {
                return fmt.Errorf("registering flag %s: %w", flagName, err)
            }

            // Bind to viper with ORIGINAL dot-notation key
            if err := fb.BindPFlag(fullKey, fs.Lookup(flagName)); err != nil {
                return fmt.Errorf("binding flag %s to key %s: %w", flagName, fullKey, err)
            }
        }
    }
    return nil
}

// configKeyToFlagName transforms a config key to a POSIX flag name.
// Example: "server.host" -> "server-host"
func configKeyToFlagName(key string) string {
    return strings.ReplaceAll(key, ".", "-")
}

// registerTypedFlag registers a typed pflag based on ConfigFlag.Type.
func registerTypedFlag(fs *pflag.FlagSet, flag ConfigFlag, name string) error {
    switch flag.Type {
    case ConfigFlagTypeString:
        def, _ := flag.Default.(string)
        fs.String(name, def, flag.Description)
    case ConfigFlagTypeInt:
        def, _ := flag.Default.(int)
        fs.Int(name, def, flag.Description)
    case ConfigFlagTypeBool:
        def, _ := flag.Default.(bool)
        fs.Bool(name, def, flag.Description)
    case ConfigFlagTypeDuration:
        def, _ := flag.Default.(time.Duration)
        fs.Duration(name, def, flag.Description)
    case ConfigFlagTypeFloat:
        def, _ := flag.Default.(float64)
        fs.Float64(name, def, flag.Description)
    default:
        // Unknown type, treat as string
        def, _ := flag.Default.(string)
        fs.String(name, def, flag.Description)
    }
    return nil
}
```

Key design decisions:
- Uses PersistentFlags() so flags work across subcommands
- Key transformation: "server.host" -> "--server-host" 
- Binds to viper with original key ("server.host") for correct lookup
- Skips already-registered flags to avoid panics
- Returns nil if backend doesn't support FlagBinder (graceful degradation)
  </action>
  <verify>
Run `go build ./...` to verify compilation.
Run `go vet ./...` to check for issues.
  </verify>
  <done>
RegisterCobraFlags method exists on App. Transforms config keys to flag names. Binds to viper with correct keys.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test ./...` passes (existing tests still work)
3. New code compiles without errors
4. Interface assertions pass compile-time checks
</verification>

<success_criteria>
- RegisterCobraFlags method exists on App
- FlagBinder interface exists in config package
- ViperBackend implements BindPFlag
- Config loading operations are idempotent
- Build() works correctly with or without prior RegisterCobraFlags call
</success_criteria>

<output>
After completion, create `.planning/phases/17-expose-configprovider-flags-to-cobra-cli/17-01-SUMMARY.md`
</output>
