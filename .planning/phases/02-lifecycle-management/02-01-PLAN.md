---
phase: 02
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [container.go]
autonomous: true
must_haves:
  truths:
    - "Container records all service dependencies during resolution"
    - "Graph is accessible via internal API for lifecycle engine"
    - "Graph correctly captures A -> B relationships"
  artifacts:
    - path: "container.go"
      provides: "Dependency graph storage"
      contains: "dependencyGraph"
  key_links:
    - from: "resolveByName"
      to: "dependencyGraph"
      via: "recordDependency"
---

<objective>
Enable the container to record the dependency graph during service resolution.

Purpose: This graph is the foundation for deterministic lifecycle ordering (startup/shutdown).
Output: A populated dependency graph within the container.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@container.go

# resolveByName is the key injection point
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependency graph storage to Container</name>
  <files>container.go</files>
  <action>
    Modify `Container` struct:
    - Add `dependencyGraph map[string][]string` to store adjacency list (parent -> children).
    - Initialize it in `New()`.
    - Add `graphMu sync.RWMutex` (or reuse `mu` if appropriate, but separate lock is better for granularity).
    - Add internal method `recordDependency(parent, child string)` that appends child to parent's list safely.
    - Add internal method `getGraph() map[string][]string` that returns a copy of the graph (for the lifecycle engine).
  </action>
  <verify>
    Create a test in `container_test.go` (temporary or permanent) that inspects the unexported graph via a test helper or by exporting a read-only view.
  </verify>
  <done>
    `Container` has a `dependencyGraph` field initialized and accessible via internal methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Capture dependencies in resolveByName</name>
  <files>container.go</files>
  <action>
    Update `resolveByName` method:
    - Identify the parent service (the one currently requesting dependencies).
    - Retrieve parent from `chain` (it's the last element in `chain` *before* we push the current name).
    - If `len(chain) > 0`, the parent is `chain[len(chain)-1]`.
    - Call `c.recordDependency(parent, name)` to record `parent -> name`.
    - Ensure this happens *before* pushing the current name to the chain.
  </action>
  <verify>
    Run `go test ./...` to ensure no regressions in existing resolution/cycle detection.
    Add a specific test case:
    - Register A depending on B.
    - Resolve A.
    - Check if graph contains A -> [B].
  </verify>
  <done>
    Dependencies are automatically recorded during resolution.
  </done>
</task>

</tasks>

<verification>
Run `go test ./...` to ensure the graph recording doesn't interfere with existing resolution logic.
</verification>

<success_criteria>
- [ ] Container struct has dependency storage
- [ ] Resolving A that depends on B results in Graph[A] containing B
- [ ] Thread-safe recording (mutex protected)
</success_criteria>

<output>
After completion, create `.planning/phases/02-lifecycle-management/02-01-SUMMARY.md`
</output>
