---
phase: 02
plan: 03
type: tdd
wave: 2
depends_on: [02-01, 02-02]
files_modified: [lifecycle_engine.go, lifecycle_engine_test.go]
autonomous: true
must_haves:
  truths:
    - "Services start in topological order (dependencies first)"
    - "Services stop in reverse topological order (dependents first)"
    - "Circular dependencies detected (or handled by graph)"
    - "Independent services can start in parallel (future proofing, though sequential for now is fine)"
  artifacts:
    - path: "lifecycle_engine.go"
      provides: "Order computation logic"
  key_links:
    - from: "Container.getGraph"
      to: "LifecycleEngine"
      via: "input to sorting algo"
---

<objective>
Implement the core lifecycle ordering logic (the "Brain").

Purpose: Ensure services start/stop in the mathematically correct order based on the dependency graph.
Output: Tested logic that takes a graph and returns execution layers.
</objective>

<feature>
  <name>Lifecycle Ordering Engine</name>
  <files>lifecycle_engine.go, lifecycle_engine_test.go</files>
  <behavior>
    1. Input: Dependency Graph (map[string][]string)
    2. Input: List of services (map[string]Service)
    3. Output: Startup Order (Layered: [[A, B], [C]])
    4. Output: Shutdown Order (Reverse: [[C], [B, A]])
    
    Logic:
    - Perform Topological Sort (Kahn's Algorithm).
    - Group into "levels" where services in a level have no dependencies on each other (allows parallel startup in future).
    - Filter to only include services that exist and have hooks (optimization).
  </behavior>
  <implementation>
    func ComputeStartupOrder(graph map[string][]string) ([][]string, error)
    func ComputeShutdownOrder(startupOrder [][]string) [][]string
  </implementation>
</feature>
