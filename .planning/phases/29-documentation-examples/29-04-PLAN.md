---
phase: 29-documentation-examples
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/background-workers/main.go
  - examples/background-workers/go.mod
  - examples/microservice/main.go
  - examples/microservice/go.mod
  - examples/microservice/config.yaml
autonomous: true

must_haves:
  truths:
    - "Background workers tutorial exists as runnable example app"
    - "Microservice tutorial exists as runnable example app"
    - "Both examples compile and build successfully"
    - "Examples use v3 patterns exclusively"
  artifacts:
    - path: "examples/background-workers/main.go"
      provides: "Background workers tutorial code"
      min_lines: 50
      contains: "worker.NewModule"
    - path: "examples/microservice/main.go"
      provides: "Microservice tutorial code"
      min_lines: 80
      contains: "gaz.New"
  key_links:
    - from: "examples/background-workers/main.go"
      to: "worker package"
      via: "Import and usage"
      pattern: "worker\\."
    - from: "examples/microservice/main.go"
      to: "gaz core"
      via: "App lifecycle"
      pattern: "gaz\\.(New|For|Resolve)"
---

<objective>
Create two new tutorial example applications demonstrating v3 patterns.

Purpose: CONTEXT.md specifies use-case based tutorials for "Background workers" and "Microservices". These fill gaps in existing /examples directory and fulfill DOC-02/DOC-03 requirements.

Output: Two complete, runnable example apps (50-100+ lines each) in /examples directory.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-documentation-examples/29-RESEARCH.md
@.planning/phases/29-documentation-examples/29-CONTEXT.md

# Existing example patterns
@examples/http-server/main.go
@examples/lifecycle/main.go
@examples/modules/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create background-workers example</name>
  <files>examples/background-workers/main.go, examples/background-workers/go.mod</files>
  <action>
Create `examples/background-workers/` directory with a complete tutorial app demonstrating:

1. Implementing the Worker interface (OnStart/OnStop with context)
2. Using worker.NewModule() for DI integration
3. Multiple workers running concurrently
4. Graceful shutdown handling

Structure:
```
examples/background-workers/
├── main.go      # Main application (50-80 lines)
└── go.mod       # Module file
```

**main.go content:**

```go
// Package main demonstrates background worker patterns with gaz.
//
// This example shows:
//   - Implementing the worker.Worker interface
//   - Registering workers with gaz DI
//   - Graceful shutdown with context cancellation
//
// Run with: go run main.go
// Stop with: Ctrl+C (SIGINT)
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    "github.com/petabytecl/gaz"
    "github.com/petabytecl/gaz/worker"
)

// EmailWorker processes email queue.
type EmailWorker struct {
    name string
}

func NewEmailWorker() *EmailWorker {
    return &EmailWorker{name: "email-worker"}
}

func (w *EmailWorker) Name() string { return w.name }

func (w *EmailWorker) OnStart(ctx context.Context) error {
    fmt.Printf("[%s] starting\n", w.name)
    
    ticker := time.NewTicker(2 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("[%s] context cancelled, stopping\n", w.name)
            return nil
        case <-ticker.C:
            fmt.Printf("[%s] processing emails...\n", w.name)
        }
    }
}

func (w *EmailWorker) OnStop(ctx context.Context) error {
    fmt.Printf("[%s] stopped\n", w.name)
    return nil
}

// NotificationWorker sends push notifications.
type NotificationWorker struct {
    name string
}

// ... similar implementation for second worker

func main() {
    app := gaz.New()
    
    // Register worker module
    app.UseDI(worker.NewModule())
    
    // Register workers as DI providers
    gaz.For[*EmailWorker](app.Container()).Eager().Provider(
        func(c *gaz.Container) (*EmailWorker, error) {
            return NewEmailWorker(), nil
        },
    )
    
    // ... register NotificationWorker
    
    if err := app.Build(); err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("Starting workers (Ctrl+C to stop)...")
    if err := app.Run(context.Background()); err != nil {
        log.Fatal(err)
    }
}
```

**go.mod:**
```
module github.com/petabytecl/gaz/examples/background-workers

go 1.25

require github.com/petabytecl/gaz v0.0.0

replace github.com/petabytecl/gaz => ../..
```
  </action>
  <verify>
```bash
cd examples/background-workers && go build -o /dev/null .
```
  </verify>
  <done>examples/background-workers/ contains compilable app demonstrating worker.Worker interface, worker.NewModule(), and graceful shutdown</done>
</task>

<task type="auto">
  <name>Task 2: Create microservice example</name>
  <files>examples/microservice/main.go, examples/microservice/go.mod, examples/microservice/config.yaml</files>
  <action>
Create `examples/microservice/` directory with a complete tutorial app demonstrating a realistic microservice with:

1. Configuration loading from YAML
2. HTTP health endpoints
3. Background worker
4. Event bus for internal messaging
5. Graceful shutdown

Structure:
```
examples/microservice/
├── main.go      # Main application (80-120 lines)
├── go.mod       # Module file
└── config.yaml  # Example configuration
```

**main.go content:**

```go
// Package main demonstrates a complete microservice with gaz.
//
// This example shows:
//   - Config loading with struct unmarshaling
//   - Health check endpoints (/healthz, /readyz)
//   - Background worker with event bus
//   - Full lifecycle management
//
// Run with: go run main.go
// Check health: curl http://localhost:8081/healthz
// Stop with: Ctrl+C (SIGINT)
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "time"

    "github.com/petabytecl/gaz"
    "github.com/petabytecl/gaz/config"
    viperbackend "github.com/petabytecl/gaz/config/viper"
    "github.com/petabytecl/gaz/eventbus"
    "github.com/petabytecl/gaz/health"
    "github.com/petabytecl/gaz/worker"
)

// AppConfig holds service configuration.
type AppConfig struct {
    Server struct {
        Port int `gaz:"port"`
    } `gaz:"server"`
    Health struct {
        Port int `gaz:"port"`
    } `gaz:"health"`
}

// OrderCreatedEvent is published when an order is created.
type OrderCreatedEvent struct {
    OrderID string
    Amount  float64
}

// OrderProcessor handles order events.
type OrderProcessor struct {
    bus *eventbus.Bus
}

func NewOrderProcessor(bus *eventbus.Bus) *OrderProcessor {
    return &OrderProcessor{bus: bus}
}

func (p *OrderProcessor) Name() string { return "order-processor" }

func (p *OrderProcessor) OnStart(ctx context.Context) error {
    sub := p.bus.Subscribe(func(ctx context.Context, evt OrderCreatedEvent) error {
        fmt.Printf("Processing order %s: $%.2f\n", evt.OrderID, evt.Amount)
        return nil
    })
    
    <-ctx.Done()
    sub.Unsubscribe()
    return nil
}

func (p *OrderProcessor) OnStop(ctx context.Context) error {
    return nil
}

// ... (HTTP handler, etc.)

func main() {
    app := gaz.New()
    
    // Load configuration
    backend := viperbackend.New(
        viperbackend.WithConfigFile("config.yaml", "."),
    )
    cfg := config.NewManager(backend)
    
    if err := app.SetConfigManager(cfg); err != nil {
        log.Fatal(err)
    }
    
    // Register modules
    app.UseDI(health.NewModule())
    app.UseDI(worker.NewModule())
    app.UseDI(eventbus.NewModule())
    
    // Register services
    // ... providers for OrderProcessor, HTTP server, etc.
    
    if err := app.Build(); err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("Microservice starting...")
    if err := app.Run(context.Background()); err != nil {
        log.Fatal(err)
    }
}
```

**config.yaml:**
```yaml
server:
  port: 8080

health:
  port: 8081
```

**go.mod:**
```
module github.com/petabytecl/gaz/examples/microservice

go 1.25

require github.com/petabytecl/gaz v0.0.0

replace github.com/petabytecl/gaz => ../..
```
  </action>
  <verify>
```bash
cd examples/microservice && go build -o /dev/null .
```
  </verify>
  <done>examples/microservice/ contains compilable app demonstrating config, health, worker, eventbus modules with full lifecycle</done>
</task>

</tasks>

<verification>
```bash
# Verify both examples compile
go build ./examples/background-workers/...
go build ./examples/microservice/...

# Check line counts meet minimum
wc -l examples/background-workers/main.go examples/microservice/main.go
```
</verification>

<success_criteria>
1. examples/background-workers/ exists with main.go (50+ lines), go.mod
2. examples/microservice/ exists with main.go (80+ lines), go.mod, config.yaml
3. Both examples compile with `go build`
4. Examples use v3 patterns: NewModule(), For[T](), interface-based lifecycle
5. No deprecated v2 patterns (no fluent OnStart/OnStop, no service.Builder)
6. Code is well-commented explaining what each section demonstrates
</success_criteria>

<output>
After completion, create `.planning/phases/29-documentation-examples/29-04-SUMMARY.md`
</output>
