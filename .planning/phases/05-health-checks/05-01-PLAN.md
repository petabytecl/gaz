---
phase: 05-health-checks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - health/types.go
  - health/checker.go
  - health/shutdown.go
autonomous: true
must_haves:
  truths:
    - "Application has distinct types for Liveness, Readiness, and Startup checks"
    - "Shutdown signal causes Readiness check to immediately fail"
    - "Health module uses alexliesenfeld/health under the hood"
  artifacts:
    - path: "health/types.go"
      provides: "Check interfaces"
    - path: "health/shutdown.go"
      provides: "ShutdownReadinessChecker"
  key_links:
    - from: "health/shutdown.go"
      to: "lifecycle.OnStop"
      via: "hook registration"
---

<objective>
Establish the core health check infrastructure, including interfaces for different check types (Liveness, Readiness, Startup) and a specific Shutdown check that integrates with the application lifecycle.

Purpose: Foundation for production-grade observability.
Output: Type definitions, core checker logic, and shutdown signal integration.
</objective>

<context>
@.planning/phases/05-health-checks/05-RESEARCH.md
@.planning/phases/02-lifecycle-management/02-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and define interfaces</name>
  <files>go.mod, health/types.go</files>
  <action>
    1. Run `go get github.com/alexliesenfeld/health`.
    2. Create `health/types.go` defining marker interfaces to distinguish check types in DI:
       - `LivenessCheck` (interface{ Check(ctx) error })
       - `ReadinessCheck` (interface{ Check(ctx) error })
       - `StartupCheck` (interface{ Check(ctx) error })
    3. Define `CheckOptions` struct for per-check configuration (name, timeout).
  </action>
  <verify>
    `go list -m github.com/alexliesenfeld/health` returns version.
    `go build ./health/...` passes.
  </verify>
  <done>
    Interfaces defined and library installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ShutdownReadinessChecker</name>
  <files>health/shutdown.go</files>
  <action>
    Implement `ShutdownCheck` struct that implements `ReadinessCheck`.
    - Use `atomic.Bool` to track state (default: up/false).
    - `Check(ctx)`: return error if shutting down.
    - `MarkShuttingDown()`: sets state to down/true.
    - Ensure it is thread-safe.
  </action>
  <verify>
    Create test: Assert `Check` returns nil initially, then returns error after `MarkShuttingDown` is called.
  </verify>
  <done>
    Shutdown logic implemented and tested.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Health Manager</name>
  <files>health/manager.go</files>
  <action>
    Create `Manager` struct that:
    - Accepts lists of `LivenessCheck`, `ReadinessCheck`, `StartupCheck` via DI (slices).
    - exposes methods to get the underlying `health.Checker` for each type.
    - Uses `alexliesenfeld/health` `NewChecker` to aggregate checks.
    - Configures global timeouts from options.
  </action>
  <verify>
    Test that Manager correctly aggregates multiple mock checks into a single `health.Checker`.
  </verify>
  <done>
    Manager aggregates distinct checks by type.
  </done>
</task>

</tasks>

<verification>
Run `go test ./health/...`
</verification>

<success_criteria>
- Core health module compiles
- Interfaces separate the three probe types
- Shutdown checker flips state correctly
- Manager aggregates checks
</success_criteria>

<output>
After completion, create `.planning/phases/05-health-checks/05-01-SUMMARY.md`
</output>
