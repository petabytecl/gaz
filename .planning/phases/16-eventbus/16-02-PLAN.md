---
phase: 16-eventbus
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - eventbus/bus.go
autonomous: true

must_haves:
  truths:
    - "Subscribe[T]() returns Subscription handle for unsubscribe"
    - "Publish[T]() delivers event to all matching handlers"
    - "Handlers run concurrently (fire-and-forget)"
    - "Panics in handlers are recovered and logged"
    - "EventBus.Close() waits for in-flight handlers"
    - "Publishing to closed bus is silent no-op"
  artifacts:
    - path: "eventbus/bus.go"
      provides: "EventBus with Subscribe, Publish, Close, lifecycle"
      exports: ["EventBus", "New", "Subscribe", "Publish"]
      min_lines: 150
  key_links:
    - from: "eventbus/bus.go"
      to: "reflect.Type"
      via: "type-based routing key"
      pattern: "reflect\\.TypeOf.*Elem"
    - from: "eventbus/bus.go"
      to: "worker.Worker"
      via: "implements interface"
      pattern: "Name.*Start.*Stop"
---

<objective>
Implement EventBus core with generic Subscribe[T]() and Publish[T]() methods, type-based routing, async delivery with per-subscription buffers, and lifecycle integration.

Purpose: Complete the EventBus implementation with all core pub/sub functionality.
Output: Fully functional EventBus implementing worker.Worker interface.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-eventbus/16-CONTEXT.md
@.planning/phases/16-eventbus/16-RESEARCH.md
@.planning/phases/16-eventbus/16-01-SUMMARY.md
@eventbus/event.go
@eventbus/subscription.go
@eventbus/options.go
@worker/worker.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EventBus struct with Subscribe[T]() implementation</name>
  <files>eventbus/bus.go</files>
  <action>
1. Create `eventbus/bus.go` with EventBus struct:
   ```go
   // subscriptionKey uniquely identifies a subscription target.
   type subscriptionKey struct {
       eventType reflect.Type
       topic     string // Empty = wildcard (all topics)
   }

   // asyncSubscription holds a subscription's channel and handler.
   type asyncSubscription struct {
       id      uint64
       ch      chan any          // Buffered channel for events
       done    chan struct{}     // Closed when handler goroutine exits
       handler func(context.Context, any) // Type-erased handler
   }

   // EventBus provides type-safe in-process pub/sub.
   type EventBus struct {
       mu       sync.RWMutex
       handlers map[subscriptionKey][]*asyncSubscription
       nextID   uint64
       closed   bool
       logger   *slog.Logger
   }

   // New creates a new EventBus.
   func New(logger *slog.Logger) *EventBus {
       return &EventBus{
           handlers: make(map[subscriptionKey][]*asyncSubscription),
           logger:   logger.With("component", "eventbus.EventBus"),
       }
   }
   ```

2. Implement Subscribe[T]() with type-based routing per RESEARCH.md:
   ```go
   // Subscribe registers a handler for events of type T.
   // Returns a Subscription that can be used to unsubscribe.
   // Options: WithTopic() for topic filtering, WithBufferSize() for buffer.
   func Subscribe[T Event](b *EventBus, handler Handler[T], opts ...SubscribeOption) *Subscription {
       options := applyOptions(opts)

       b.mu.Lock()
       defer b.mu.Unlock()

       if b.closed {
           return nil // Can't subscribe to closed bus
       }

       eventType := reflect.TypeOf((*T)(nil)).Elem()
       key := subscriptionKey{eventType: eventType, topic: options.topic}

       b.nextID++
       id := b.nextID

       // Create async subscription with per-subscriber buffer
       sub := &asyncSubscription{
           id:   id,
           ch:   make(chan any, options.bufferSize),
           done: make(chan struct{}),
           handler: func(ctx context.Context, event any) {
               handler(ctx, event.(T))
           },
       }

       // Start handler goroutine
       go sub.run(b.logger)

       b.handlers[key] = append(b.handlers[key], sub)

       return &Subscription{
           id:        id,
           eventType: eventType,
           topic:     options.topic,
           bus:       b,
       }
   }
   ```

3. Implement asyncSubscription.run() with panic recovery:
   ```go
   func (s *asyncSubscription) run(logger *slog.Logger) {
       defer close(s.done)
       for event := range s.ch {
           s.safeInvoke(context.Background(), event, logger)
       }
   }

   func (s *asyncSubscription) safeInvoke(ctx context.Context, event any, logger *slog.Logger) {
       defer func() {
           if r := recover(); r != nil {
               logger.Error("handler panic recovered",
                   "error", r,
                   "stack", string(debug.Stack()),
               )
           }
       }()
       s.handler(ctx, event)
   }
   ```

4. Implement unsubscribe method (satisfies unsubscriber interface):
   ```go
   func (b *EventBus) unsubscribe(eventType reflect.Type, topic string, id uint64) {
       b.mu.Lock()
       defer b.mu.Unlock()

       key := subscriptionKey{eventType: eventType, topic: topic}
       subs := b.handlers[key]

       for i, sub := range subs {
           if sub.id == id {
               close(sub.ch) // Signal handler to exit
               <-sub.done    // Wait for handler to finish
               b.handlers[key] = append(subs[:i], subs[i+1:]...)
               if len(b.handlers[key]) == 0 {
                   delete(b.handlers, key)
               }
               return
           }
       }
   }
   ```
  </action>
  <verify>`go build ./eventbus/...` compiles successfully</verify>
  <done>EventBus struct with Subscribe[T]() implementation and panic recovery</done>
</task>

<task type="auto">
  <name>Task 2: Implement Publish[T]() and Close() with drain</name>
  <files>eventbus/bus.go</files>
  <action>
1. Implement Publish[T]() with topic matching:
   ```go
   // Publish sends an event to all matching subscribers.
   // Matching includes:
   //   - Subscribers for exact (type, topic) pair
   //   - Subscribers for (type, "") wildcard (subscribed to all topics)
   //
   // Publish returns immediately (fire-and-forget). Events are queued
   // in each subscriber's buffer. Blocks if any subscriber's buffer is full.
   //
   // Publishing to a closed bus is a silent no-op (idempotent).
   func Publish[T Event](ctx context.Context, b *EventBus, event T, topic string) {
       b.mu.RLock()
       if b.closed {
           b.mu.RUnlock()
           return // Silent no-op per CONTEXT.md
       }

       eventType := reflect.TypeOf(event)

       // Find all matching handlers (exact topic + wildcard)
       var handlers []*asyncSubscription

       // Exact topic match
       exactKey := subscriptionKey{eventType: eventType, topic: topic}
       handlers = append(handlers, b.handlers[exactKey]...)

       // Wildcard match (empty topic = all topics)
       if topic != "" {
           wildcardKey := subscriptionKey{eventType: eventType, topic: ""}
           handlers = append(handlers, b.handlers[wildcardKey]...)
       }

       b.mu.RUnlock()

       // Deliver to each handler (blocks if buffer full per CONTEXT.md)
       for _, h := range handlers {
           select {
           case h.ch <- event:
               // Delivered
           case <-ctx.Done():
               return // Context cancelled, stop publishing
           }
       }
   }
   ```

2. Implement lifecycle methods (worker.Worker interface):
   ```go
   // Name implements worker.Worker interface.
   func (b *EventBus) Name() string {
       return "eventbus.EventBus"
   }

   // Start implements worker.Worker interface.
   // EventBus is always ready - no initialization needed.
   func (b *EventBus) Start() {
       b.logger.Info("eventbus started")
   }

   // Stop implements worker.Worker interface.
   // Calls Close() to drain in-flight handlers.
   func (b *EventBus) Stop() {
       b.Close()
   }
   ```

3. Implement Close() with drain per CONTEXT.md:
   ```go
   // Close shuts down the EventBus and waits for in-flight handlers.
   // After Close, Publish is a no-op and Subscribe returns nil.
   // Safe to call multiple times (idempotent).
   func (b *EventBus) Close() {
       b.mu.Lock()
       if b.closed {
           b.mu.Unlock()
           return
       }
       b.closed = true

       // Collect all subscriptions
       var allSubs []*asyncSubscription
       for _, subs := range b.handlers {
           allSubs = append(allSubs, subs...)
       }
       b.mu.Unlock()

       // Close all channels (signals handlers to drain and exit)
       for _, sub := range allSubs {
           close(sub.ch)
       }

       // Wait for all handlers to finish processing
       for _, sub := range allSubs {
           <-sub.done
       }

       b.logger.Info("eventbus stopped", "subscriptions_drained", len(allSubs))
   }
   ```

4. Add required imports at top of file:
   ```go
   import (
       "context"
       "log/slog"
       "reflect"
       "runtime/debug"
       "sync"
   )
   ```
  </action>
  <verify>`go build ./eventbus/...` compiles, `go vet ./eventbus/...` passes</verify>
  <done>Publish[T]() with topic matching, Close() with drain, lifecycle methods</done>
</task>

</tasks>

<verification>
1. `go build ./eventbus/...` - Package compiles
2. `go vet ./eventbus/...` - No vet errors
3. `grep -q "func Subscribe\[T Event\]" eventbus/bus.go` - Generic Subscribe exists
4. `grep -q "func Publish\[T Event\]" eventbus/bus.go` - Generic Publish exists
5. `grep -q "func (b \*EventBus) Close()" eventbus/bus.go` - Close method exists
6. `grep -q "func (b \*EventBus) Name()" eventbus/bus.go` - Name method exists (worker.Worker)
7. `grep -q "recover()" eventbus/bus.go` - Panic recovery implemented
</verification>

<success_criteria>
- Subscribe[T]() creates subscription with per-subscriber buffer
- Publish[T]() delivers to exact topic and wildcard subscribers
- Handlers run in goroutines with panic recovery
- Close() drains all in-flight handlers before returning
- Publishing to closed bus is silent no-op
- EventBus implements worker.Worker (Name, Start, Stop)
- Package compiles and passes vet
</success_criteria>

<output>
After completion, create `.planning/phases/16-eventbus/16-02-SUMMARY.md`
</output>
