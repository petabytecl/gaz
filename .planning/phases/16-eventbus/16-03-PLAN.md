---
phase: 16-eventbus
plan: 03
type: execute
wave: 3
depends_on: ["16-02"]
files_modified:
  - app.go
autonomous: true

must_haves:
  truths:
    - "EventBus created during App construction"
    - "EventBus registered as singleton in DI container"
    - "EventBus discoverable as worker.Worker for lifecycle"
    - "EventBus resolvable via di.Resolve[*eventbus.EventBus]"
  artifacts:
    - path: "app.go"
      provides: "EventBus integration with App"
      contains: "eventbus.New"
  key_links:
    - from: "app.go"
      to: "eventbus.EventBus"
      via: "singleton registration"
      pattern: "For\\[\\*eventbus\\.EventBus\\]"
    - from: "app.go"
      to: "workerMgr.Register"
      via: "lifecycle integration"
      pattern: "workerMgr\\.Register\\(a\\.eventBus\\)"
---

<objective>
Integrate EventBus with gaz App for DI registration and lifecycle management.

Purpose: Enable EventBus resolution from DI container and automatic lifecycle management.
Output: EventBus created during App construction, registered as singleton, managed by WorkerManager.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-eventbus/16-CONTEXT.md
@.planning/phases/16-eventbus/16-02-SUMMARY.md
@app.go
@eventbus/bus.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EventBus field to App struct and create during construction</name>
  <files>app.go</files>
  <action>
1. Add import for eventbus package:
   ```go
   import (
       // ... existing imports
       "github.com/eagurin/gaz/eventbus"
   )
   ```

2. Add eventBus field to App struct (near workerMgr and scheduler fields):
   ```go
   type App struct {
       // ... existing fields
       workerMgr  *worker.Manager
       scheduler  *cron.Scheduler
       eventBus   *eventbus.EventBus  // Add this field
       // ... rest of fields
   }
   ```

3. In the App constructor (where workerMgr and scheduler are created), create EventBus:
   ```go
   // Create EventBus with logger
   eventBus := eventbus.New(logger)
   ```

4. Assign to App struct field:
   ```go
   app := &App{
       // ... existing fields
       workerMgr:  workerMgr,
       scheduler:  scheduler,
       eventBus:   eventBus,  // Add this
       // ... rest
   }
   ```
  </action>
  <verify>`go build ./...` compiles successfully</verify>
  <done>App struct has eventBus field, EventBus created during App construction</done>
</task>

<task type="auto">
  <name>Task 2: Register EventBus as DI singleton and with WorkerManager</name>
  <files>app.go</files>
  <action>
1. In App constructor (after creating eventBus, before returning app), register EventBus as singleton:
   ```go
   // Register EventBus as singleton for DI resolution
   di.For[*eventbus.EventBus](container).Instance(eventBus)
   ```

   This allows any service to inject `*eventbus.EventBus` as a dependency.

2. In Build() method, register EventBus with WorkerManager for lifecycle (add after discoverWorkers and before discoverCronJobs):
   ```go
   // Register EventBus with worker manager for lifecycle management
   if err := a.workerMgr.Register(a.eventBus); err != nil {
       errs = append(errs, fmt.Errorf("registering eventbus: %w", err))
   }
   ```

   This ensures:
   - EventBus.Start() called during app startup (after Starter hooks)
   - EventBus.Stop() called during app shutdown (before Stopper hooks)

3. Verify the order in Build():
   - discoverWorkers() - discovers user workers
   - Register eventBus with workerMgr - always registered
   - discoverCronJobs() - discovers cron jobs
   - Register scheduler with workerMgr (if jobs exist)

4. Add accessor method for EventBus (optional, for direct access):
   ```go
   // EventBus returns the application's EventBus for pub/sub.
   // Prefer injecting *eventbus.EventBus as a dependency instead.
   func (a *App) EventBus() *eventbus.EventBus {
       return a.eventBus
   }
   ```
  </action>
  <verify>`go build ./...` compiles, `go test ./...` passes</verify>
  <done>EventBus registered as DI singleton, registered with WorkerManager for lifecycle</done>
</task>

</tasks>

<verification>
1. `go build ./...` - Full project compiles
2. `go test ./...` - All tests pass
3. `grep -q "eventbus.New" app.go` - EventBus creation
4. `grep -q "For\[\\*eventbus\\.EventBus\]" app.go` - DI registration
5. `grep -q "workerMgr.Register(a.eventBus)" app.go` - Worker registration
</verification>

<success_criteria>
- EventBus created during App construction with logger
- EventBus registered as singleton via di.For[*eventbus.EventBus]().Instance()
- EventBus registered with WorkerManager for lifecycle
- Services can inject *eventbus.EventBus as dependency
- App.EventBus() accessor available for direct access
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-eventbus/16-03-SUMMARY.md`
</output>
