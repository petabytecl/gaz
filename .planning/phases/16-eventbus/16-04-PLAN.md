---
phase: 16-eventbus
plan: 04
type: execute
wave: 4
depends_on: ["16-03"]
files_modified:
  - eventbus/bus_test.go
autonomous: true

must_haves:
  truths:
    - "Subscribe/Publish delivers events to handlers"
    - "Unsubscribe stops event delivery to that handler"
    - "Topic filtering routes events correctly"
    - "Panicking handler doesn't crash bus or block other handlers"
    - "Close() waits for in-flight handlers"
    - "Publishing to closed bus is no-op"
    - "EventBus implements worker.Worker interface"
  artifacts:
    - path: "eventbus/bus_test.go"
      provides: "Comprehensive test coverage"
      min_lines: 200
  key_links:
    - from: "eventbus/bus_test.go"
      to: "eventbus.Subscribe"
      via: "tests Subscribe function"
      pattern: "Subscribe\\["
    - from: "eventbus/bus_test.go"
      to: "eventbus.Publish"
      via: "tests Publish function"
      pattern: "Publish\\["
---

<objective>
Create comprehensive tests for EventBus covering all functionality: Subscribe/Publish, unsubscribe, topic filtering, panic recovery, lifecycle, and edge cases.

Purpose: Verify all EventBus functionality works correctly and meets requirements.
Output: Test file with 70%+ coverage of eventbus package.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-eventbus/16-CONTEXT.md
@.planning/phases/16-eventbus/16-03-SUMMARY.md
@eventbus/bus.go
@cron/scheduler_test.go
@worker/manager_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core Subscribe/Publish tests</name>
  <files>eventbus/bus_test.go</files>
  <action>
1. Create test file with test event type:
   ```go
   package eventbus

   import (
       "context"
       "log/slog"
       "os"
       "sync"
       "sync/atomic"
       "testing"
       "time"

       "github.com/stretchr/testify/assert"
       "github.com/stretchr/testify/require"
   )

   // testEvent implements Event interface for testing
   type testEvent struct {
       ID      string
       Message string
   }

   func (e testEvent) EventName() string { return "testEvent" }

   func testLogger() *slog.Logger {
       return slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))
   }
   ```

2. Test basic Subscribe/Publish flow:
   ```go
   func TestSubscribeAndPublish(t *testing.T) {
       bus := New(testLogger())
       defer bus.Close()

       var received atomic.Value

       sub := Subscribe(bus, func(ctx context.Context, e testEvent) {
           received.Store(e)
       })
       require.NotNil(t, sub)

       Publish(context.Background(), bus, testEvent{ID: "1", Message: "hello"}, "")

       // Wait for async delivery
       time.Sleep(50 * time.Millisecond)

       got := received.Load()
       require.NotNil(t, got)
       assert.Equal(t, "1", got.(testEvent).ID)
       assert.Equal(t, "hello", got.(testEvent).Message)
   }
   ```

3. Test multiple subscribers:
   ```go
   func TestMultipleSubscribers(t *testing.T) {
       bus := New(testLogger())
       defer bus.Close()

       var count atomic.Int32

       Subscribe(bus, func(ctx context.Context, e testEvent) { count.Add(1) })
       Subscribe(bus, func(ctx context.Context, e testEvent) { count.Add(1) })
       Subscribe(bus, func(ctx context.Context, e testEvent) { count.Add(1) })

       Publish(context.Background(), bus, testEvent{ID: "1"}, "")
       time.Sleep(50 * time.Millisecond)

       assert.Equal(t, int32(3), count.Load())
   }
   ```

4. Test unsubscribe:
   ```go
   func TestUnsubscribe(t *testing.T) {
       bus := New(testLogger())
       defer bus.Close()

       var count atomic.Int32

       sub := Subscribe(bus, func(ctx context.Context, e testEvent) {
           count.Add(1)
       })

       Publish(context.Background(), bus, testEvent{ID: "1"}, "")
       time.Sleep(50 * time.Millisecond)
       assert.Equal(t, int32(1), count.Load())

       sub.Unsubscribe()

       Publish(context.Background(), bus, testEvent{ID: "2"}, "")
       time.Sleep(50 * time.Millisecond)
       assert.Equal(t, int32(1), count.Load()) // No change after unsubscribe
   }
   ```

5. Test topic filtering:
   ```go
   func TestTopicFiltering(t *testing.T) {
       bus := New(testLogger())
       defer bus.Close()

       var adminCount, userCount, wildcardCount atomic.Int32

       Subscribe(bus, func(ctx context.Context, e testEvent) {
           adminCount.Add(1)
       }, WithTopic("admin"))

       Subscribe(bus, func(ctx context.Context, e testEvent) {
           userCount.Add(1)
       }, WithTopic("user"))

       Subscribe(bus, func(ctx context.Context, e testEvent) {
           wildcardCount.Add(1)
       }) // No topic = wildcard

       Publish(context.Background(), bus, testEvent{ID: "1"}, "admin")
       Publish(context.Background(), bus, testEvent{ID: "2"}, "user")
       time.Sleep(100 * time.Millisecond)

       assert.Equal(t, int32(1), adminCount.Load())
       assert.Equal(t, int32(1), userCount.Load())
       assert.Equal(t, int32(2), wildcardCount.Load()) // Wildcard receives all
   }
   ```
  </action>
  <verify>`go test ./eventbus/... -run "TestSubscribe|TestMultiple|TestUnsubscribe|TestTopic" -v` passes</verify>
  <done>Core Subscribe/Publish tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create lifecycle, panic recovery, and edge case tests</name>
  <files>eventbus/bus_test.go</files>
  <action>
1. Test panic recovery:
   ```go
   func TestPanicRecovery(t *testing.T) {
       bus := New(testLogger())
       defer bus.Close()

       var safeCount atomic.Int32

       // Handler that panics
       Subscribe(bus, func(ctx context.Context, e testEvent) {
           panic("test panic")
       })

       // Handler that should still receive events
       Subscribe(bus, func(ctx context.Context, e testEvent) {
           safeCount.Add(1)
       })

       Publish(context.Background(), bus, testEvent{ID: "1"}, "")
       time.Sleep(100 * time.Millisecond)

       // Safe handler should have received the event
       assert.Equal(t, int32(1), safeCount.Load())
   }
   ```

2. Test Close() drains handlers:
   ```go
   func TestCloseDrainsHandlers(t *testing.T) {
       bus := New(testLogger())

       var completed atomic.Bool
       var wg sync.WaitGroup
       wg.Add(1)

       Subscribe(bus, func(ctx context.Context, e testEvent) {
           defer wg.Done()
           time.Sleep(100 * time.Millisecond) // Simulate slow handler
           completed.Store(true)
       })

       Publish(context.Background(), bus, testEvent{ID: "1"}, "")

       // Close should wait for handler to complete
       bus.Close()

       // Handler should have completed before Close returned
       assert.True(t, completed.Load())
   }
   ```

3. Test publish to closed bus:
   ```go
   func TestPublishToClosedBus(t *testing.T) {
       bus := New(testLogger())

       var count atomic.Int32
       Subscribe(bus, func(ctx context.Context, e testEvent) {
           count.Add(1)
       })

       bus.Close()

       // Should be silent no-op, no panic
       Publish(context.Background(), bus, testEvent{ID: "1"}, "")
       time.Sleep(50 * time.Millisecond)

       assert.Equal(t, int32(0), count.Load())
   }
   ```

4. Test subscribe to closed bus:
   ```go
   func TestSubscribeToClosedBus(t *testing.T) {
       bus := New(testLogger())
       bus.Close()

       sub := Subscribe(bus, func(ctx context.Context, e testEvent) {})
       assert.Nil(t, sub)
   }
   ```

5. Test worker.Worker interface:
   ```go
   func TestWorkerInterface(t *testing.T) {
       bus := New(testLogger())

       assert.Equal(t, "eventbus.EventBus", bus.Name())

       // Start/Stop should not panic
       bus.Start()
       bus.Stop()
   }
   ```

6. Test buffer size option:
   ```go
   func TestBufferSizeOption(t *testing.T) {
       bus := New(testLogger())
       defer bus.Close()

       var received atomic.Int32

       // Small buffer
       Subscribe(bus, func(ctx context.Context, e testEvent) {
           time.Sleep(10 * time.Millisecond)
           received.Add(1)
       }, WithBufferSize(2))

       // Publish several events
       for i := 0; i < 5; i++ {
           Publish(context.Background(), bus, testEvent{ID: "1"}, "")
       }

       time.Sleep(200 * time.Millisecond)
       assert.Equal(t, int32(5), received.Load())
   }
   ```

7. Test context cancellation:
   ```go
   func TestContextCancellation(t *testing.T) {
       bus := New(testLogger())
       defer bus.Close()

       // Slow consumer with tiny buffer
       Subscribe(bus, func(ctx context.Context, e testEvent) {
           time.Sleep(100 * time.Millisecond)
       }, WithBufferSize(1))

       ctx, cancel := context.WithTimeout(context.Background(), 10*time.Millisecond)
       defer cancel()

       // This should not block forever due to context cancellation
       for i := 0; i < 10; i++ {
           Publish(ctx, bus, testEvent{ID: "1"}, "")
       }
   }
   ```

8. Run coverage check:
   ```go
   // At end of test file, add comment:
   // Run: go test -coverprofile=coverage.out ./eventbus/...
   // Target: 70%+ coverage
   ```
  </action>
  <verify>`go test ./eventbus/... -v` passes, `go test -cover ./eventbus/...` shows 70%+</verify>
  <done>All tests pass with 70%+ coverage</done>
</task>

</tasks>

<verification>
1. `go test ./eventbus/... -v` - All tests pass
2. `go test -cover ./eventbus/...` - Coverage at least 70%
3. `go vet ./eventbus/...` - No vet errors
4. `go test ./...` - All project tests pass (including new eventbus tests)
</verification>

<success_criteria>
- Subscribe/Publish delivers events correctly
- Unsubscribe stops delivery to that handler
- Topic filtering routes events correctly
- Wildcard subscribers receive all events of type
- Panic in handler doesn't crash bus or block others
- Close() waits for in-flight handlers
- Publishing to closed bus is silent no-op
- Subscribing to closed bus returns nil
- EventBus implements worker.Worker interface
- Buffer size option works correctly
- Context cancellation in Publish works
- Test coverage at least 70%
</success_criteria>

<output>
After completion, create `.planning/phases/16-eventbus/16-04-SUMMARY.md`
</output>
