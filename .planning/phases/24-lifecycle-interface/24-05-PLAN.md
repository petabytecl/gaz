---
phase: 24-lifecycle-interface
plan: 05
type: execute
wave: 3
depends_on: ["24-03", "24-04"]
files_modified:
  - doc.go
  - di/doc.go
  - worker/doc.go
  - lifecycle.go
  - gaz.go
autonomous: true

must_haves:
  truths:
    - "Package documentation reflects interface-only lifecycle pattern"
    - "worker.Worker interface documentation is updated"
    - "No references to fluent OnStart/OnStop remain in docs"
    - "All tests pass (full suite verification)"
  artifacts:
    - path: "doc.go"
      provides: "Updated package documentation"
      contains: "implements Starter"
    - path: "di/doc.go"
      provides: "DI package docs without fluent hooks"
      min_lines: 30
  key_links:
    - from: "doc.go"
      to: "lifecycle.go"
      via: "documentation references interfaces"
      pattern: "Starter|Stopper"
---

<objective>
Update documentation to reflect interface-only lifecycle and verify full phase completion

Purpose: Ensure all documentation accurately describes the v3.0 interface-based lifecycle pattern. Remove references to removed fluent hook APIs. Verify the complete phase with full test suite.

Output: Updated documentation, passing full test suite, phase complete
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-lifecycle-interface/24-CONTEXT.md

@.planning/phases/24-lifecycle-interface/24-01-SUMMARY.md
@.planning/phases/24-lifecycle-interface/24-02-SUMMARY.md
@.planning/phases/24-lifecycle-interface/24-03-SUMMARY.md
@.planning/phases/24-lifecycle-interface/24-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Package Documentation</name>
  <files>doc.go, di/doc.go</files>
  <action>
    Update package-level documentation to reflect interface-only lifecycle:

    **In doc.go (main gaz package):**
    1. Find lifecycle examples that show fluent hooks
    2. Update to show interface-based pattern:
       ```go
       // Lifecycle management: services implementing Starter or Stopper
       // interfaces automatically participate in app lifecycle.
       //
       //     type Server struct { ... }
       //
       //     func (s *Server) OnStart(ctx context.Context) error {
       //         return s.listener.Listen()
       //     }
       //
       //     func (s *Server) OnStop(ctx context.Context) error {
       //         return s.listener.Close()
       //     }
       //
       //     di.For[*Server](c).Provider(NewServer)  // Auto-detected lifecycle
       ```
    3. Remove any mentions of fluent OnStart/OnStop methods
    4. Emphasize interface-based auto-detection

    **In di/doc.go:**
    1. Remove the example showing `.OnStart()` fluent method (~line 43)
    2. Replace with interface-based example
    3. Document that Starter/Stopper interfaces are the lifecycle mechanism
    4. Clarify that implementing these interfaces is all that's needed
  </action>
  <verify>
    `grep -n "\.OnStart\|\.OnStop" doc.go di/doc.go` returns no fluent hook examples
    Docs show interface-based lifecycle pattern
  </verify>
  <done>
    Package documentation reflects interface-only lifecycle pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Worker and Lifecycle Documentation</name>
  <files>worker/doc.go, lifecycle.go</files>
  <action>
    **In worker/doc.go:**
    1. Update package overview to mention new interface signatures
    2. Document that Worker now has OnStart(ctx)/OnStop(ctx) error
    3. Update any examples to show new signatures
    4. Clarify relationship between worker.Worker and di.Starter/di.Stopper:
       - worker.Worker has matching signatures (OnStart/OnStop with ctx and error)
       - Workers registered with manager get lifecycle managed by supervisor
       - Workers resolved via DI also participate in container lifecycle

    **In lifecycle.go (gaz package):**
    1. Review Starter and Stopper interface documentation
    2. Ensure docs are clear about automatic lifecycle participation
    3. Add note that this is the sole lifecycle mechanism (no fluent hooks)
    4. Ensure HookFunc, HookConfig, WithHookTimeout are still documented if kept
       (these may be used for other purposes, but verify they're not obsolete)

    Note: If HookFunc/HookConfig/WithHookTimeout are only used for fluent hooks, consider removing them. Check if they're used elsewhere in the codebase first.
  </action>
  <verify>
    `go doc ./worker` shows updated Worker interface docs
    `go doc ./...` shows no references to removed APIs
  </verify>
  <done>
    Worker and lifecycle documentation updated for v3.0 patterns
  </done>
</task>

<task type="auto">
  <name>Task 3: Full Test Suite Verification</name>
  <files>N/A (verification task)</files>
  <action>
    Run comprehensive verification of the entire phase:

    1. Run full test suite:
       ```bash
       go test ./... -v -count=1
       ```

    2. Verify no compilation errors:
       ```bash
       go build ./...
       ```

    3. Run linter:
       ```bash
       golangci-lint run ./...
       ```

    4. Verify coverage hasn't dropped significantly:
       ```bash
       go test ./... -coverprofile=coverage.out
       go tool cover -func=coverage.out | tail -1
       ```
       (Should still be near 92.9% or higher)

    5. Final verification - no fluent hooks remain:
       ```bash
       # Look for any remaining fluent hook patterns
       grep -rn "\.OnStart(\|\.OnStop(" --include="*.go" .
       ```
       Should only find interface method definitions, not fluent calls.

    6. Verify worker interface compliance:
       ```bash
       # All Worker implementations should have OnStart/OnStop
       grep -rn "implements.*Worker\|func.*OnStart\|func.*OnStop" --include="*.go" .
       ```
  </action>
  <verify>
    `go test ./... -v -count=1` passes all tests
    `go build ./...` compiles without errors
    Coverage is >= 90%
  </verify>
  <done>
    Full test suite passes, no regressions, phase 24 requirements met
  </done>
</task>

</tasks>

<verification>
Final phase verification:

```bash
# Full test suite
go test ./... -v -count=1

# Build verification
go build ./...

# Coverage check
go test ./... -coverprofile=coverage.out && go tool cover -func=coverage.out | tail -1

# No fluent hooks remaining
grep -rn "\.OnStart(\|\.OnStop(" --include="*.go" . | grep -v "func.*OnStart\|func.*OnStop" | wc -l
# Should be 0
```

Requirements verification:
- LIF-01: RegistrationBuilder has no OnStart/OnStop methods ✓
- LIF-02: worker.Worker uses OnStart(ctx)/OnStop(ctx) error ✓
- LIF-03: Skipped per user decision (no Adapt() helper) ✓
</verification>

<success_criteria>
1. All package documentation reflects interface-only lifecycle
2. No references to fluent OnStart/OnStop in documentation
3. Full test suite passes with all tests
4. Build succeeds for all packages
5. Coverage remains at or above 90%
6. All v3.0 LIF-01, LIF-02 requirements verified
</success_criteria>

<output>
After completion, create `.planning/phases/24-lifecycle-interface/24-05-SUMMARY.md`
</output>
