---
phase: 24-lifecycle-interface
plan: 04
type: execute
wave: 2
depends_on: ["24-02"]
files_modified:
  - shutdown_test.go
  - app_test.go
  - app_integration_test.go
  - lifecycle_test.go
  - cobra_test.go
  - health/module.go
  - examples/http-server/main.go
  - examples/cobra-cli/main.go
autonomous: true

must_haves:
  truths:
    - "No fluent OnStart/OnStop calls remain on RegistrationBuilder"
    - "All tests use interface-based lifecycle (Starter/Stopper)"
    - "All package tests pass"
    - "Examples demonstrate interface-based lifecycle pattern"
  artifacts:
    - path: "shutdown_test.go"
      provides: "Tests using Stopper interface"
      contains: "OnStop(context.Context)"
    - path: "health/module.go"
      provides: "Health module using interface lifecycle"
      min_lines: 40
  key_links:
    - from: "app_test.go"
      to: "di.Starter/di.Stopper"
      via: "test service implementing interfaces"
      pattern: "func.*OnStart\\(.*context\\.Context"
---

<objective>
Migrate all remaining fluent hook usages to interface-based lifecycle

Purpose: Complete the removal of fluent OnStart/OnStop hooks by converting all test and example code to use Starter/Stopper interfaces. This ensures the codebase is fully aligned with v3.0 interface-only lifecycle.

Output: All tests and examples use interface-based lifecycle, no fluent hooks remain
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-lifecycle-interface/24-CONTEXT.md

@.planning/phases/24-lifecycle-interface/24-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert Test Files to Interface-Based Lifecycle</name>
  <files>shutdown_test.go, app_test.go, lifecycle_test.go, cobra_test.go</files>
  <action>
    Convert all fluent hook usages to interface implementations:

    **Pattern for conversion:**
    
    Before (fluent hooks):
    ```go
    di.For[*MyService](c).
        OnStart(func(ctx context.Context, s *MyService) error { ... }).
        OnStop(func(ctx context.Context, s *MyService) error { ... }).
        Provider(...)
    ```

    After (interface):
    ```go
    // Add methods to the service type:
    func (s *MyService) OnStart(ctx context.Context) error { ... }
    func (s *MyService) OnStop(ctx context.Context) error { ... }

    // Registration becomes simpler:
    di.For[*MyService](c).Provider(...)
    ```

    **Files to update:**

    1. **shutdown_test.go** (~4 usages):
       - Add OnStop method to slowShutdownService, shutdownTestServiceA, shutdownTestServiceB, namedSlowService
       - Remove fluent .OnStop() calls

    2. **app_test.go** (~4 usages):
       - Add OnStart/OnStop methods to AppTestServiceA, AppTestServiceB, FailingStartService, FailingStopService
       - Remove fluent .OnStart()/.OnStop() calls

    3. **lifecycle_test.go** (~2 usages):
       - Convert MyService fluent hooks to interface methods
       - Keep lifecycleService as-is (already uses interface)

    4. **cobra_test.go** (~2 usages):
       - Add OnStart/OnStop methods to cobraTestService
       - Remove fluent calls
  </action>
  <verify>
    `grep -rn "\.OnStart\|\.OnStop" shutdown_test.go app_test.go lifecycle_test.go cobra_test.go` returns no fluent hook matches
    `go test ./... -run "Shutdown\|App\|Lifecycle\|Cobra" -v` passes
  </verify>
  <done>
    Test files use interface-based lifecycle, no fluent hooks on registration builders
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert Integration Tests and Health Module</name>
  <files>app_integration_test.go, health/module.go</files>
  <action>
    **In app_integration_test.go** (~4 usages):
    1. Find testLifecycleService and testDatabase types
    2. Add OnStart/OnStop interface methods to these types
    3. Remove fluent .OnStart()/.OnStop() chains from registration

    **In health/module.go** (~2 usages):
    1. The ManagementServer registration uses fluent hooks
    2. ManagementServer likely already has Start/Shutdown methods
    3. Create OnStart/OnStop methods that wrap existing functionality:
       ```go
       func (s *ManagementServer) OnStart(ctx context.Context) error {
           return s.Start()  // or inline the logic
       }
       func (s *ManagementServer) OnStop(ctx context.Context) error {
           return s.Shutdown(ctx)
       }
       ```
    4. Remove fluent hooks from the registration in NewModule()
  </action>
  <verify>
    `grep -rn "\.OnStart\|\.OnStop" app_integration_test.go health/module.go` returns no fluent hook matches
    `go test ./health/... -v` passes
    `go test ./... -run "Integration" -v` passes
  </verify>
  <done>
    Integration tests and health module use interface-based lifecycle
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Example Code</name>
  <files>examples/http-server/main.go, examples/cobra-cli/main.go</files>
  <action>
    Update examples to demonstrate interface-based lifecycle:

    **In examples/http-server/main.go:**
    1. Server type already has OnStart/OnStop methods (interface pattern)
    2. BUT there's redundant fluent hook registration that calls these methods
    3. Remove the fluent .OnStart()/.OnStop() chains
    4. Auto-detection will call the interface methods directly
    5. Update any comments to clarify interface-based lifecycle

    **In examples/cobra-cli/main.go:**
    1. Same pattern as http-server - Server has interface methods
    2. Remove fluent hook chains that wrap the interface calls
    3. Simplify registration to just `.Provider(...)`

    **Verify pattern:**
    The examples should show clean interface-based lifecycle:
    ```go
    // Server implements di.Starter and di.Stopper
    func (s *Server) OnStart(ctx context.Context) error { ... }
    func (s *Server) OnStop(ctx context.Context) error { ... }

    // Registration is simple - auto-detection handles lifecycle
    di.For[*Server](c).Provider(NewServer)
    ```
  </action>
  <verify>
    `grep -rn "\.OnStart\|\.OnStop" examples/http-server/main.go examples/cobra-cli/main.go` returns no fluent hook matches
    `go build ./examples/...` compiles successfully
  </verify>
  <done>
    Examples demonstrate clean interface-based lifecycle without fluent hooks
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
go test ./... -v -count=1
```

Verify no fluent hooks remain anywhere:
```bash
# Look for fluent hook calls (method chaining on registration)
grep -rn "\.OnStart\|\.OnStop" *.go examples/**/*.go health/*.go
```
Should return only interface method definitions (func OnStart), not fluent calls.

Build all examples:
```bash
go build ./examples/...
```
</verification>

<success_criteria>
1. No fluent OnStart/OnStop calls remain on RegistrationBuilder across codebase
2. All service types needing lifecycle implement Starter/Stopper interfaces
3. All tests pass (no regressions)
4. Examples cleanly demonstrate interface-based lifecycle
5. Health module uses interface-based lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/24-lifecycle-interface/24-04-SUMMARY.md`
</output>
