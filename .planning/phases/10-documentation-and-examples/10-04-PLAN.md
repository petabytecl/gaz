---
phase: 10-documentation-and-examples
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/basic/main.go
  - examples/basic/README.md
  - examples/lifecycle/main.go
  - examples/lifecycle/README.md
  - examples/config-loading/main.go
  - examples/config-loading/config.yaml
  - examples/config-loading/README.md
autonomous: true

must_haves:
  truths:
    - "User can run basic example with go run"
    - "User can see lifecycle hooks in action"
    - "User can see config loading from file and env vars"
  artifacts:
    - path: "examples/basic/main.go"
      provides: "Minimal working gaz application"
      contains: "gaz.New()"
    - path: "examples/lifecycle/main.go"
      provides: "Lifecycle hooks demonstration"
      contains: "OnStart"
    - path: "examples/config-loading/main.go"
      provides: "Config loading demonstration"
      contains: "ConfigManager"
  key_links:
    - from: "examples/basic/main.go"
      to: "gaz package"
      via: "import"
      pattern: "github.com/petabytecl/gaz"
---

<objective>
Create basic example applications demonstrating fundamental gaz patterns.

Purpose: Provide complete, runnable examples users can copy and modify.
Output: 3 example apps (basic, lifecycle, config-loading) each with main.go and README.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-documentation-and-examples/10-CONTEXT.md
@.planning/phases/10-documentation-and-examples/10-RESEARCH.md

# Source files
@app.go
@lifecycle.go
@config_manager.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create examples/basic application</name>
  <files>examples/basic/main.go, examples/basic/README.md</files>
  <action>
Create examples/ directory structure.

**examples/basic/main.go:**
Minimal working gaz application showing:
- Define a Greeter service with a Name field
- Create app with gaz.New()
- Register Greeter as singleton with ProvideSingleton
- Build the app
- Resolve the Greeter and print its Name
- Handle errors appropriately

Keep it under 40 lines. No external dependencies beyond gaz.

```go
package main

import (
    "fmt"
    "log"
    "github.com/petabytecl/gaz"
)

type Greeter struct {
    Name string
}

func main() {
    app := gaz.New()
    
    app.ProvideSingleton(func(c *gaz.Container) (*Greeter, error) {
        return &Greeter{Name: "World"}, nil
    })
    
    if err := app.Build(); err != nil {
        log.Fatal(err)
    }
    
    greeter, err := gaz.Resolve[*Greeter](app.Container())
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Hello, %s!\n", greeter.Name)
}
```

**examples/basic/README.md:**
Brief description:
- What this example demonstrates
- How to run: `go run .` from the basic/ directory
- Expected output
- What to explore next (link to lifecycle example)
  </action>
  <verify>cd examples/basic && go build . && ./basic 2>&1 || go run . 2>&1</verify>
  <done>examples/basic compiles and runs, outputs greeting</done>
</task>

<task type="auto">
  <name>Task 2: Create examples/lifecycle application</name>
  <files>examples/lifecycle/main.go, examples/lifecycle/README.md</files>
  <action>
**examples/lifecycle/main.go:**
Demonstrate lifecycle hooks (OnStart/OnStop).

Define a Server struct implementing Starter and Stopper:
```go
type Server struct {
    port int
}

func (s *Server) OnStart(ctx context.Context) error {
    fmt.Printf("Server starting on port %d\n", s.port)
    return nil
}

func (s *Server) OnStop(ctx context.Context) error {
    fmt.Println("Server stopping...")
    return nil
}
```

Main function:
- Create app with gaz.New()
- Register Server as singleton
- Build app
- Run app with context (app.Run blocks until signal)
- Show graceful shutdown on Ctrl+C

Include comments explaining:
- OnStart is called during app.Run()
- OnStop is called when shutdown signal received
- Ctrl+C triggers graceful shutdown

**examples/lifecycle/README.md:**
- What it demonstrates: lifecycle hooks, graceful shutdown
- How to run and stop (Ctrl+C)
- Expected output on start and stop
- Explain startup/shutdown ordering if multiple services
  </action>
  <verify>cd examples/lifecycle && go build . && echo "Build OK"</verify>
  <done>examples/lifecycle compiles successfully</done>
</task>

<task type="auto">
  <name>Task 3: Create examples/config-loading application</name>
  <files>examples/config-loading/main.go, examples/config-loading/config.yaml, examples/config-loading/README.md</files>
  <action>
**examples/config-loading/config.yaml:**
```yaml
server:
  port: 8080
  host: localhost
debug: true
```

**examples/config-loading/main.go:**
Demonstrate ConfigManager with file and env var loading.

Define config struct:
```go
type Config struct {
    Server struct {
        Port int    `mapstructure:"port" validate:"required,min=1,max=65535"`
        Host string `mapstructure:"host" validate:"required"`
    } `mapstructure:"server"`
    Debug bool `mapstructure:"debug"`
}
```

Main function:
- Create ConfigManager with:
  - WithName("config")
  - WithSearchPaths(".")
  - WithEnvPrefix("APP")
- Load config
- Print loaded values
- Show how env vars override: APP_SERVER_PORT=9090 go run .

Include validation demonstration:
- Show validation tags working
- Invalid config should fail at load time

**examples/config-loading/README.md:**
- What it demonstrates: config files, env vars, validation
- How to run with default config
- How to override with env vars
- Expected output
- Link to docs/configuration.md for full details
  </action>
  <verify>cd examples/config-loading && go build . && echo "Build OK"</verify>
  <done>examples/config-loading compiles with config.yaml present</done>
</task>

</tasks>

<verification>
```bash
# All example directories exist with files
ls examples/basic/main.go examples/lifecycle/main.go examples/config-loading/main.go

# All examples compile
for d in examples/*/; do
  (cd "$d" && go build . && echo "$d: BUILD OK") || echo "$d: BUILD FAILED"
done

# Each has README
ls examples/*/README.md
```
</verification>

<success_criteria>
1. examples/basic, examples/lifecycle, examples/config-loading directories exist
2. Each has main.go that compiles without errors
3. Each has README.md explaining how to run
4. examples/basic runs and prints output
5. examples/config-loading has config.yaml file
6. All examples use production-quality patterns (error handling, logging)
</success_criteria>

<output>
After completion, create `.planning/phases/10-documentation-and-examples/10-04-SUMMARY.md`
</output>
