---
phase: 10-documentation-and-examples
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/http-server/main.go
  - examples/http-server/README.md
  - examples/modules/main.go
  - examples/modules/README.md
  - examples/cobra-cli/main.go
  - examples/cobra-cli/README.md
autonomous: true

must_haves:
  truths:
    - "User can run HTTP server with health checks"
    - "User can organize providers into modules"
    - "User can build CLI app with Cobra integration"
  artifacts:
    - path: "examples/http-server/main.go"
      provides: "HTTP server with graceful shutdown"
      contains: "http.Server"
    - path: "examples/modules/main.go"
      provides: "Module organization pattern"
      contains: "Module"
    - path: "examples/cobra-cli/main.go"
      provides: "Cobra CLI integration"
      contains: "cobra.Command"
  key_links:
    - from: "examples/http-server/main.go"
      to: "health package"
      via: "import"
      pattern: "github.com/petabytecl/gaz/health"
---

<objective>
Create advanced example applications demonstrating production patterns.

Purpose: Show real-world usage patterns for HTTP servers, modules, and CLI apps.
Output: 3 example apps (http-server, modules, cobra-cli) each with main.go and README.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-documentation-and-examples/10-CONTEXT.md
@.planning/phases/10-documentation-and-examples/10-RESEARCH.md

# Source files
@app.go
@app_module.go
@cobra.go
@health/module.go
@health/server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create examples/http-server application</name>
  <files>examples/http-server/main.go, examples/http-server/README.md</files>
  <action>
**examples/http-server/main.go:**
HTTP server with graceful shutdown and health checks.

Components:
1. Config struct with server port
2. HTTP handler (simple endpoint returning JSON)
3. Server struct with http.Server, implementing Starter and Stopper
4. Health check integration using health.Module()

Key patterns to demonstrate:
- Server.OnStart() starts http.ListenAndServe in goroutine
- Server.OnStop() calls http.Server.Shutdown(ctx) for graceful drain
- Graceful shutdown timeout from gaz.WithShutdownTimeout()
- Health endpoint at /health

```go
type Server struct {
    httpServer *http.Server
}

func (s *Server) OnStart(ctx context.Context) error {
    go func() {
        if err := s.httpServer.ListenAndServe(); err != http.ErrServerClosed {
            log.Printf("HTTP server error: %v", err)
        }
    }()
    log.Printf("HTTP server listening on %s", s.httpServer.Addr)
    return nil
}

func (s *Server) OnStop(ctx context.Context) error {
    log.Println("Shutting down HTTP server...")
    return s.httpServer.Shutdown(ctx)
}
```

Include health.Module() registration to add health check server.

**examples/http-server/README.md:**
- What it demonstrates: HTTP server, graceful shutdown, health checks
- How to run and test with curl
- How to trigger graceful shutdown (Ctrl+C)
- Health endpoint URL
  </action>
  <verify>cd examples/http-server && go build . && echo "Build OK"</verify>
  <done>examples/http-server compiles with health integration</done>
</task>

<task type="auto">
  <name>Task 2: Create examples/modules application</name>
  <files>examples/modules/main.go, examples/modules/README.md</files>
  <action>
**examples/modules/main.go:**
Demonstrate organizing providers into modules.

Define multiple modules:
```go
// DatabaseModule provides database-related services
type DatabaseModule struct{}

func (m *DatabaseModule) Module() gaz.ModuleFunc {
    return func(app *gaz.App) {
        app.ProvideSingleton(NewDB)
        app.ProvideSingleton(NewUserRepo)
    }
}

// CacheModule provides caching services
type CacheModule struct{}

func (m *CacheModule) Module() gaz.ModuleFunc {
    return func(app *gaz.App) {
        app.ProvideSingleton(NewCache)
    }
}
```

Main function:
- Create app
- app.UseModule(&DatabaseModule{})
- app.UseModule(&CacheModule{})
- Build and show that all services are available

Show how modules:
- Group related providers
- Can depend on services from other modules
- Keep main.go clean

**examples/modules/README.md:**
- What it demonstrates: module organization, separation of concerns
- How to create custom modules
- When to use modules vs direct registration
  </action>
  <verify>cd examples/modules && go build . && echo "Build OK"</verify>
  <done>examples/modules compiles with module pattern</done>
</task>

<task type="auto">
  <name>Task 3: Create examples/cobra-cli application</name>
  <files>examples/cobra-cli/main.go, examples/cobra-cli/README.md</files>
  <action>
**examples/cobra-cli/main.go:**
CLI application with Cobra integration.

Demonstrate:
1. Root command with flags
2. Subcommands that use DI
3. Flag binding to config
4. gaz.WithCobra() integration

Structure:
```go
func main() {
    rootCmd := &cobra.Command{
        Use:   "myapp",
        Short: "Example CLI with gaz DI",
    }
    
    // Add flags
    rootCmd.PersistentFlags().StringP("config", "c", "", "config file path")
    rootCmd.PersistentFlags().BoolP("debug", "d", false, "enable debug mode")
    
    // Subcommand that uses injected services
    serveCmd := &cobra.Command{
        Use:   "serve",
        Short: "Start the server",
        RunE: func(cmd *cobra.Command, args []string) error {
            app := gaz.New(gaz.WithCobra(rootCmd))
            
            app.ProvideSingleton(NewServer)
            
            if err := app.Build(); err != nil {
                return err
            }
            
            return app.Run(cmd.Context())
        },
    }
    
    rootCmd.AddCommand(serveCmd)
    rootCmd.Execute()
}
```

Show:
- Flag values accessible via viper in providers
- Proper command structure
- Context propagation

**examples/cobra-cli/README.md:**
- What it demonstrates: Cobra integration, CLI structure
- How to run with different flags
- Available commands and flags
- How flags become config values
  </action>
  <verify>cd examples/cobra-cli && go build . && echo "Build OK"</verify>
  <done>examples/cobra-cli compiles with Cobra integration</done>
</task>

</tasks>

<verification>
```bash
# All advanced example directories exist
ls examples/http-server/main.go examples/modules/main.go examples/cobra-cli/main.go

# All examples compile
for d in examples/http-server examples/modules examples/cobra-cli; do
  (cd "$d" && go build . && echo "$d: BUILD OK") || echo "$d: BUILD FAILED"
done

# Each has README
ls examples/*/README.md | wc -l  # Should be 6 total (3 basic + 3 advanced)

# http-server uses health package
grep -q "github.com/petabytecl/gaz/health" examples/http-server/main.go && echo "health import OK"

# cobra-cli uses cobra
grep -q "github.com/spf13/cobra" examples/cobra-cli/main.go && echo "cobra import OK"
```
</verification>

<success_criteria>
1. examples/http-server, examples/modules, examples/cobra-cli directories exist
2. Each has main.go that compiles without errors
3. Each has README.md explaining the pattern
4. http-server demonstrates health checks and graceful shutdown
5. modules shows proper module organization pattern
6. cobra-cli integrates with Cobra command structure
7. All examples use production-quality patterns
</success_criteria>

<output>
After completion, create `.planning/phases/10-documentation-and-examples/10-05-SUMMARY.md`
</output>
