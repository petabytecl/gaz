---
phase: 13-config
plan: 03
type: execute
wave: 3
depends_on: ["13-02"]
files_modified:
  - app.go
  - errors.go
  - options.go
  - config.go
  - config_manager.go
  - validation.go
  - provider_config.go
autonomous: true

must_haves:
  truths:
    - "WithConfig[T]() on App still works identically"
    - "gaz.ErrConfigValidation aliases config.ErrConfigValidation"
    - "Existing tests pass without modification"
    - "Root gaz package does NOT re-export config types"
  artifacts:
    - path: "app.go"
      provides: "App using config.Manager internally"
      contains: "config.Manager"
    - path: "errors.go"
      provides: "Error aliases for backward compatibility"
      contains: "config.ErrConfigValidation"
    - path: "provider_config.go"
      provides: "ProviderValues using config.Backend"
      contains: "config.Backend"
  key_links:
    - from: "app.go"
      to: "config/manager.go"
      via: "App creates and uses config.Manager"
      pattern: "config\\.New|config\\.Manager"
    - from: "errors.go"
      to: "config/errors.go"
      via: "gaz.ErrConfigValidation = config.ErrConfigValidation"
      pattern: "= config\\.ErrConfigValidation"
---

<objective>
Integrate config package with App and ensure backward compatibility for existing users.

Purpose: Existing code using gaz.WithConfig, gaz.ErrConfigValidation, etc. continues to work without changes.
Output: Updated gaz root package using config.Manager internally, with old APIs preserved.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-config/13-CONTEXT.md
@.planning/phases/13-config/13-02-SUMMARY.md

# Current files to update:
@app.go
@errors.go
@options.go
@config.go
@config_manager.go
@provider_config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update App to use config.Manager internally</name>
  <files>app.go, provider_config.go</files>
  <action>
1. **Update app.go** to use config.Manager:
   - Change `configMgr *ConfigManager` field to `configMgr *config.Manager`
   - Import `"github.com/petabytecl/gaz/config"`
   - In WithConfig method, create config.Manager:
     ```go
     app.configMgr = config.New(configOpts...)
     ```
   - Update all configMgr method calls to use new Manager API
   - Keep existing WithConfig[T]() signature and behavior
   - Register ConfigManager in DI container as before (using config.Manager type)

2. **Update provider_config.go**:
   - ProviderValues should use config.Backend interface (not *viper.Viper directly)
   - Update ProviderValues struct:
     ```go
     type ProviderValues struct {
         backend config.Backend
     }
     ```
   - Update all Get* methods to delegate to backend:
     ```go
     func (pv *ProviderValues) GetString(key string) string {
         return pv.backend.GetString(key)
     }
     ```
   - Update RegisterProviderFlags and ValidateProviderFlags to work with config.Backend
   - These methods may need type assertion to access viper-specific methods, OR add those methods to Backend interface

   Note: If RegisterProviderFlags/ValidateProviderFlags need methods not in Backend interface (SetDefault, BindEnv, IsSet), either:
   a) Add those methods to Backend interface (preferred - they're general purpose)
   b) Type assert to *viper.Backend in provider_config.go

3. **ConfigManager backward compatibility**:
   Keep ConfigManager as a type alias or thin wrapper:
   ```go
   // ConfigManager is an alias for backward compatibility.
   // Deprecated: Use config.Manager directly.
   type ConfigManager = config.Manager
   
   // NewConfigManager creates a ConfigManager for backward compatibility.
   // Deprecated: Use config.New directly.
   func NewConfigManager(target any, opts ...ConfigOption) *ConfigManager {
       return config.New(opts...)
   }
   ```

4. **ConfigOption backward compatibility**:
   Keep ConfigOption type alias:
   ```go
   type ConfigOption = config.Option
   ```
  </action>
  <verify>
Run: `go build ./...` - Should compile.
Run: `go test ./...` - All existing tests should pass.
  </verify>
  <done>
App uses config.Manager internally. ProviderValues works with config.Backend. Existing code compiles without changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update errors.go and clean up old config files</name>
  <files>errors.go, options.go, config.go, config_manager.go, validation.go</files>
  <action>
1. **Update errors.go** - Add config error aliases:
   ```go
   import "github.com/petabytecl/gaz/config"
   
   // ErrConfigValidation is returned when config struct validation fails.
   // This is an alias to config.ErrConfigValidation for backward compatibility.
   var ErrConfigValidation = config.ErrConfigValidation
   ```
   
   Keep the gaz-specific errors (ErrDuplicateModule, ErrConfigKeyCollision) in gaz package.

2. **Update options.go** - Keep as re-exports for backward compat:
   ```go
   import "github.com/petabytecl/gaz/config"
   
   // ConfigOption is an alias for config.Option.
   // Deprecated: Import github.com/petabytecl/gaz/config directly.
   type ConfigOption = config.Option
   
   // Config option functions - re-export from config package
   var (
       WithName        = config.WithName
       WithType        = config.WithType
       WithEnvPrefix   = config.WithEnvPrefix
       WithSearchPaths = config.WithSearchPaths
       WithProfileEnv  = config.WithProfileEnv
       WithDefaults    = config.WithDefaults
   )
   ```

3. **Update config.go** - Keep interfaces as re-exports:
   ```go
   import "github.com/petabytecl/gaz/config"
   
   // Defaulter is an alias for config.Defaulter.
   // Deprecated: Import github.com/petabytecl/gaz/config directly.
   type Defaulter = config.Defaulter
   
   // Validator is an alias for config.Validator.
   // Deprecated: Import github.com/petabytecl/gaz/config directly.
   type Validator = config.Validator
   ```

4. **Remove config_manager.go** - All logic moved to config/manager.go:
   - Delete the file entirely OR
   - Keep minimal shims for backward compatibility:
     ```go
     // Deprecated shims - use config.Manager directly
     type ConfigManager = config.Manager
     
     func NewConfigManager(target any, opts ...ConfigOption) *ConfigManager {
         return config.New(opts...)
     }
     ```

5. **Remove validation.go** - All logic moved to config/validation.go:
   - Delete the file entirely (validation is internal to config package now)

IMPORTANT: Follow the pattern from Phase 12 (DI extraction):
- Keep type aliases for backward compatibility
- Add Deprecated comments to guide users
- Do NOT re-export types that users should import directly from config package
  </action>
  <verify>
Run: `go build ./...` - Should compile.
Run: `go test ./...` - All existing tests should pass.
Verify errors.Is works: `errors.Is(someErr, gaz.ErrConfigValidation)` should match config.ErrConfigValidation.
  </verify>
  <done>
gaz.ErrConfigValidation aliases config.ErrConfigValidation. Old config files cleaned up or replaced with shims. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles entire module
2. `go test ./...` all tests pass
3. `errors.Is(err, gaz.ErrConfigValidation)` works for config errors
4. Existing example code compiles without changes
5. No import cycles between gaz and config packages
</verification>

<success_criteria>
- [ ] App.configMgr uses config.Manager type
- [ ] ProviderValues uses config.Backend interface
- [ ] gaz.ErrConfigValidation = config.ErrConfigValidation (alias)
- [ ] gaz.Defaulter, gaz.Validator are type aliases to config package
- [ ] gaz.ConfigOption, With* functions are re-exports from config
- [ ] Old config_manager.go and validation.go removed or minimized
- [ ] All existing tests pass
- [ ] No import cycles
</success_criteria>

<output>
After completion, create `.planning/phases/13-config/13-03-SUMMARY.md`
</output>
