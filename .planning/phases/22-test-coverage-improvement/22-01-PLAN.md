---
phase: 22-test-coverage-improvement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - di/inject_test.go
  - di/types_test.go
  - di/lifecycle_engine_test.go
autonomous: true

must_haves:
  truths:
    - "parseTag function is tested with all tag variants"
    - "injectStruct handles all edge cases (non-pointer, optional, type mismatch)"
    - "TypeNameReflect is tested for reflect.Type and regular values"
    - "typeName handles nil, map, slice, pointer types"
    - "ComputeStartupOrder and ComputeShutdownOrder in di package are tested"
  artifacts:
    - path: "di/inject_test.go"
      provides: "Tests for parseTag and injectStruct"
    - path: "di/types_test.go"
      provides: "Tests for TypeNameReflect and typeName edge cases"
    - path: "di/lifecycle_engine_test.go"
      provides: "Tests for lifecycle ordering in di package"
  key_links:
    - from: "di/inject_test.go"
      to: "di/inject.go"
      via: "direct test coverage"
---

<objective>
Improve di package test coverage from 73.3% to 85%+

Purpose: The di package has the lowest coverage (73.3%) with critical functions at 0%
Output: Comprehensive tests for inject, types, and lifecycle_engine modules
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@di/inject.go
@di/types.go
@di/lifecycle_engine.go
@di/container_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add parseTag and injectStruct tests</name>
  <files>di/inject_test.go</files>
  <action>
Create di/inject_test.go with comprehensive tests:

1. TestParseTag - table-driven tests for all tag variants:
   - Empty string
   - "inject" only
   - "inject,optional"
   - "inject,name=foo"
   - "inject,name=foo,optional"
   - "optional" without inject (should not set inject=true)
   - Whitespace handling: "inject, name=foo"

2. TestInjectStruct - cover all branches:
   - Non-pointer target (returns nil, no error)
   - Non-struct pointer (returns nil, no error)
   - Unexported field with gaz tag (ErrNotSettable)
   - Optional field with missing service (zero value, no error)
   - Type mismatch (ErrTypeMismatch)
   - Successful injection by type
   - Successful injection by name
   - Field without gaz tag (skipped)
   - Field with gaz tag but no "inject" (skipped)
  </action>
  <verify>go test -v -run "TestParseTag|TestInjectStruct" ./di/...</verify>
  <done>All parseTag variants tested, injectStruct covers non-pointer, optional, type mismatch, and success paths</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeNameReflect and typeName tests</name>
  <files>di/types_test.go</files>
  <action>
Create di/types_test.go with tests for:

1. TestTypeNameReflect:
   - Pass reflect.Type directly (should use typeName)
   - Pass regular value (should call reflect.TypeOf first)
   - Test with struct, pointer, interface types

2. TestTypeName_EdgeCases - ensure full coverage of typeName function:
   - nil type (returns "nil")
   - Named type with package path
   - Named type without package path (builtin like "int")
   - Pointer type (*Foo)
   - Slice type ([]Foo)
   - Map type (map[string]Foo)
   - Interface type (should hit default case)
  </action>
  <verify>go test -v -run "TestTypeNameReflect|TestTypeName" ./di/...</verify>
  <done>TypeNameReflect tested with reflect.Type and regular values, typeName edge cases covered</done>
</task>

<task type="auto">
  <name>Task 3: Add di/lifecycle_engine tests</name>
  <files>di/lifecycle_engine_test.go</files>
  <action>
Create di/lifecycle_engine_test.go with tests:

1. TestComputeStartupOrder_DI:
   - Simple linear dependency chain
   - Services with no dependencies (all in wave 1)
   - Mixed dependencies creating multiple waves
   - Circular dependency detection (returns error)
   - Node in graph but not in services map
   - Services without lifecycle (filtered out)

2. TestComputeShutdownOrder_DI:
   - Verifies reverse of startup order
   - Empty order
   - Single layer
   - Multiple layers

Note: These are in di package, distinct from lifecycle_engine.go in root package.
  </action>
  <verify>go test -v -run "TestCompute.*_DI" ./di/...</verify>
  <done>ComputeStartupOrder and ComputeShutdownOrder in di package have test coverage</done>
</task>

</tasks>

<verification>
```bash
go test -cover ./di/... 2>&1 | grep "coverage:"
# Expected: coverage should be 85%+ (up from 73.3%)
```
</verification>

<success_criteria>
- di package coverage reaches 85%+
- parseTag coverage: 100%
- injectStruct coverage: 80%+
- TypeNameReflect coverage: 100%
- typeName coverage: 90%+
- ComputeStartupOrder/ComputeShutdownOrder (di): 80%+
</success_criteria>

<output>
After completion, create `.planning/phases/22-test-coverage-improvement/22-01-SUMMARY.md`
</output>
