---
phase: 06-logging-slog
plan: 03
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - app.go
  - lifecycle_engine.go
  - app_test.go
autonomous: true
must_haves:
  truths:
    - "App starts with a configured logger"
    - "Framework logs events via slog (not fmt)"
    - "Shutdown logs include duration"
  artifacts:
    - path: "app.go"
      provides: "App.Logger"
    - path: "lifecycle_engine.go"
      provides: "structured lifecycle logs"
  key_links:
    - from: "app.go"
      to: "logger/provider.go"
      via: "NewLogger"
---

<objective>
Integrate the logger into the `gaz` framework core.
Replace `fmt.Println` and `log.Printf` with `slog` calls in `App` and `LifecycleEngine`. Inject the logger into the Application struct.

Purpose: Provide visibility into framework internals using the new structured logging system.
Output: Updated `App` and `LifecycleEngine` using `slog`.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/06-logging-slog/06-01-SUMMARY.md
@app.go
@lifecycle_engine.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inject Logger into App</name>
  <files>app.go</files>
  <action>
    1. Update `App` struct to include `Logger *slog.Logger`.
    2. Update `New` builder to:
       - Accept `Logger` configuration (or use defaults).
       - Initialize `Logger` using `logger.NewLogger`.
       - Register `*slog.Logger` in the container (so users can inject it).
    3. Ensure `App` methods use `a.Logger` for logging.
  </action>
  <verify>Compiles</verify>
  <done>App struct has Logger field.</done>
</task>

<task type="auto">
  <name>Task 2: Update Lifecycle Engine Logging</name>
  <files>lifecycle_engine.go</files>
  <action>
    1. Inject `*slog.Logger` into `lifecycleEngine`.
    2. Replace all `fmt.Printf`, `log.Println` calls with:
       - `slog.Info("starting application", "services", count)`
       - `slog.Info("service started", "name", name, "duration", d)`
       - `slog.Error("failed to start service", "error", err)`
    3. Ensure startup banner (if any) is logged properly (Info level).
  </action>
  <verify>Run existing tests (output will change, but behavior should pass)</verify>
  <done>No stdout printing, all goes through logger.</done>
</task>

<task type="auto">
  <name>Task 3: Verify Integration</name>
  <files>app_test.go</files>
  <action>
    Update or add an integration test that:
    - Creates an App.
    - Captures log output (using a custom writer or pipe if possible, or just verifying no panic).
    - Verifies that `Resolve[*slog.Logger]()` works.
  </action>
  <verify>go test -v .</verify>
  <done>Integration verified.</done>
</task>

</tasks>

<verification>
Run `go test ./...` to ensure no regressions in core framework.
</verification>

<success_criteria>
- `App` has a `Logger` instance.
- `Lifecycle` logs via `slog`.
- `*slog.Logger` is resolvable from the container.
</success_criteria>

<output>
After completion, create `.planning/phases/06-logging-slog/06-03-SUMMARY.md`
</output>
