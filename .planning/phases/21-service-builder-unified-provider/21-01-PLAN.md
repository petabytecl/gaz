---
phase: 21-service-builder-unified-provider
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - module_builder.go
  - module_builder_test.go
  - app_use.go
  - app_use_test.go
autonomous: true

must_haves:
  truths:
    - "NewModule(name) returns a ModuleBuilder for creating reusable modules"
    - "ModuleBuilder.Provide() adds provider functions to the module"
    - "ModuleBuilder.Build() returns a Module implementing Name() and Apply()"
    - "app.Use(module) applies module providers to the app's container"
    - "Duplicate module registration (same name) returns error"
  artifacts:
    - path: "module_builder.go"
      provides: "ModuleBuilder and Module interface"
      exports: ["Module", "NewModule", "ModuleBuilder"]
      min_lines: 60
    - path: "app_use.go"
      provides: "App.Use(Module) method"
      exports: ["Use"]
      min_lines: 20
    - path: "module_builder_test.go"
      provides: "TDD tests for ModuleBuilder"
      min_lines: 80
    - path: "app_use_test.go"
      provides: "TDD tests for App.Use()"
      min_lines: 60
  key_links:
    - from: "module_builder.go"
      to: "Container"
      via: "Apply() calls provider functions with container"
      pattern: "func.*Container.*error"
    - from: "app_use.go"
      to: "module_builder.go"
      via: "Use() calls module.Apply()"
      pattern: "module\\.Apply\\(a\\.container\\)"
---

<objective>
Create the core ModuleBuilder fluent API and app.Use(Module) method for bundling and applying reusable provider modules.

Purpose: This is the foundation for the unified module system. ModuleBuilder allows creating self-contained modules that bundle providers, and app.Use() is how applications consume them.

Output: Working ModuleBuilder with Provide() and Build() methods, Module interface with Name() and Apply(), and App.Use(Module) method that applies modules to the container.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-service-builder-unified-provider/21-CONTEXT.md
@.planning/phases/21-service-builder-unified-provider/21-RESEARCH.md

# Existing patterns
@app_module.go
@errors.go
</context>

<feature>
  <name>ModuleBuilder Core + App.Use()</name>
  <files>module_builder.go, module_builder_test.go, app_use.go, app_use_test.go</files>
  <behavior>
    ModuleBuilder API:
    - NewModule("redis") -> *ModuleBuilder
    - builder.Provide(fn1, fn2) -> *ModuleBuilder (chainable)
    - builder.Build() -> Module

    Module interface:
    - Name() string
    - Apply(app *App) error

    App.Use() behavior:
    - app.Use(module) -> *App (chainable)
    - Applies module.Apply(app) to register providers
    - Returns error on duplicate module name
    - Panics if called after Build()

    Cases:
    - NewModule("test").Build() -> Module with Name()="test"
    - NewModule("test").Provide(fn).Build() -> Module that applies fn
    - app.Use(module) -> registers module providers in container
    - app.Use(module1).Use(module1) -> returns ErrDuplicateModule
  </behavior>
  <implementation>
    RED: Write failing tests for ModuleBuilder and App.Use()
    GREEN: Implement ModuleBuilder struct, builtModule type, App.Use() method
    REFACTOR: Clean up if needed
  </implementation>
</feature>

<verification>
```bash
go test -v -run "TestModule" ./...
go test -cover ./... | grep -E "(module_builder|app_use)"
```
</verification>

<success_criteria>
- All TDD tests pass
- NewModule("name").Provide(fn).Build() works
- app.Use(module) applies module providers
- Duplicate module name detection works
- Test coverage > 80% for new code
</success_criteria>

<output>
After completion, create `.planning/phases/21-service-builder-unified-provider/21-01-SUMMARY.md`
</output>
