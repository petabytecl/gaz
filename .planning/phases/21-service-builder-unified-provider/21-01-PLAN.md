---
phase: 21-service-builder-unified-provider
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - module_builder.go
  - module_builder_test.go
  - app_use.go
  - app_use_test.go
autonomous: true

must_haves:
  truths:
    - "NewModule(name) returns a ModuleBuilder for creating reusable modules"
    - "ModuleBuilder.Provide() adds provider functions to the module"
    - "ModuleBuilder.Use(otherModule) bundles child modules (applied first when parent is applied)"
    - "ModuleBuilder.Build() returns a Module implementing Name() and Apply()"
    - "app.Use(module) applies module providers to the app's container"
    - "Duplicate module registration (same name) returns error"
  artifacts:
    - path: "module_builder.go"
      provides: "ModuleBuilder and Module interface"
      exports: ["Module", "NewModule", "ModuleBuilder"]
      min_lines: 60
    - path: "app_use.go"
      provides: "App.Use(Module) method"
      exports: ["Use"]
      min_lines: 20
    - path: "module_builder_test.go"
      provides: "TDD tests for ModuleBuilder"
      min_lines: 80
    - path: "app_use_test.go"
      provides: "TDD tests for App.Use()"
      min_lines: 60
  key_links:
    - from: "module_builder.go"
      to: "Container"
      via: "Apply() calls provider functions with container"
      pattern: "func.*Container.*error"
    - from: "app_use.go"
      to: "module_builder.go"
      via: "Use() calls module.Apply()"
      pattern: "module\\.Apply\\(a\\.container\\)"
    - from: "module_builder.go"
      to: "builtModule"
      via: "Parent module applies child modules first in Apply()"
      pattern: "for.*childModules.*Apply"
---

<objective>
Create the core ModuleBuilder fluent API and app.Use(Module) method for bundling and applying reusable provider modules.

Purpose: This is the foundation for the unified module system. ModuleBuilder allows creating self-contained modules that bundle providers, and app.Use() is how applications consume them.

Output: Working ModuleBuilder with Provide() and Build() methods, Module interface with Name() and Apply(), and App.Use(Module) method that applies modules to the container.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-service-builder-unified-provider/21-CONTEXT.md
@.planning/phases/21-service-builder-unified-provider/21-RESEARCH.md

# Existing patterns
@app_module.go
@errors.go
</context>

<feature>
  <name>ModuleBuilder Core + App.Use()</name>
  <files>module_builder.go, module_builder_test.go, app_use.go, app_use_test.go</files>
  <behavior>
    ModuleBuilder API:
    - NewModule("redis") -> *ModuleBuilder
    - builder.Provide(fn1, fn2) -> *ModuleBuilder (chainable)
    - builder.Use(otherModule) -> *ModuleBuilder (bundles child module)
    - builder.Build() -> Module

    Module interface:
    - Name() string
    - Apply(app *App) error

    Module composition via Use():
    - Parent module bundles child modules
    - When parent.Apply() is called, child modules are applied FIRST
    - This is bundling (convenience), not dependency ordering (handled by DI)

    App.Use() behavior:
    - app.Use(module) -> *App (chainable)
    - Applies module.Apply(app) to register providers
    - Returns error on duplicate module name
    - Panics if called after Build()

    Cases:
    - NewModule("test").Build() -> Module with Name()="test"
    - NewModule("test").Provide(fn).Build() -> Module that applies fn
    - NewModule("parent").Use(childModule).Build() -> Parent applies child first
    - app.Use(module) -> registers module providers in container
    - app.Use(module1).Use(module1) -> returns ErrDuplicateModule
  </behavior>
  <implementation>
    RED: Write failing tests for ModuleBuilder (including Use()) and App.Use()
    GREEN: Implement ModuleBuilder struct with childModules slice, builtModule type, App.Use() method
    REFACTOR: Clean up if needed
  </implementation>
</feature>

<tasks>

<task type="tdd">
  <name>Task 1: RED - Write failing tests for ModuleBuilder and App.Use()</name>
  <files>module_builder_test.go, app_use_test.go</files>
  <action>
Write failing tests covering all behavior:

1. module_builder_test.go:
```go
func TestNewModule_ReturnsBuilder(t *testing.T) {
    mb := NewModule("test")
    require.NotNil(t, mb)
}

func TestModuleBuilder_Provide_Chainable(t *testing.T) {
    mb := NewModule("test").Provide(func(c *Container) error { return nil })
    require.NotNil(t, mb)
}

func TestModuleBuilder_Build_ReturnsModule(t *testing.T) {
    m := NewModule("test").Build()
    require.NotNil(t, m)
    assert.Equal(t, "test", m.Name())
}

func TestModuleBuilder_Use_BundlesChildModule(t *testing.T) {
    child := NewModule("child").Provide(/*...provider...*/).Build()
    parent := NewModule("parent").Use(child).Build()
    
    // When parent is applied, child should be applied first
    app := New()
    err := app.Use(parent).Build()
    require.NoError(t, err)
    
    // Verify child's provider was registered
    // (test that resolving child's provided type works)
}

func TestModuleBuilder_Apply_AppliesChildModulesFirst(t *testing.T) {
    // Track order of application
    var order []string
    child := NewModule("child").Provide(func(c *Container) error {
        order = append(order, "child")
        return nil
    }).Build()
    parent := NewModule("parent").
        Use(child).
        Provide(func(c *Container) error {
            order = append(order, "parent")
            return nil
        }).Build()
    
    app := New()
    app.Use(parent)
    
    assert.Equal(t, []string{"child", "parent"}, order)
}
```

2. app_use_test.go:
```go
func TestApp_Use_AppliesModule(t *testing.T) {
    applied := false
    m := NewModule("test").Provide(func(c *Container) error {
        applied = true
        return nil
    }).Build()
    
    New().Use(m)
    assert.True(t, applied)
}

func TestApp_Use_DuplicateModuleReturnsError(t *testing.T) {
    m := NewModule("test").Build()
    app := New().Use(m).Use(m) // same module twice
    
    // Check for error (either in Build() or stored in app)
}

func TestApp_Use_PanicsAfterBuild(t *testing.T) {
    m := NewModule("test").Build()
    app := New()
    app.Build()
    
    assert.Panics(t, func() { app.Use(m) })
}
```

Run tests - they MUST fail (types don't exist yet).
  </action>
  <verify>
```bash
go test -v ./... 2>&1 | grep -E "(FAIL|undefined)"
# Should see undefined errors for NewModule, Module, etc.
```
  </verify>
  <done>Tests exist and fail with undefined type errors</done>
</task>

<task type="tdd">
  <name>Task 2: GREEN - Implement ModuleBuilder and App.Use() to pass tests</name>
  <files>module_builder.go, app_use.go</files>
  <action>
Implement minimal code to make all tests pass:

1. module_builder.go:
```go
// Module represents a reusable bundle of providers
type Module interface {
    Name() string
    Apply(app *App) error
}

// ModuleBuilder constructs Module instances via fluent API
type ModuleBuilder struct {
    name         string
    providers    []func(*Container) error
    childModules []Module  // bundled modules, applied first
    errs         []error
}

// NewModule creates a new ModuleBuilder with the given name
func NewModule(name string) *ModuleBuilder {
    return &ModuleBuilder{name: name}
}

// Provide adds provider functions to the module
func (b *ModuleBuilder) Provide(fns ...func(*Container) error) *ModuleBuilder {
    b.providers = append(b.providers, fns...)
    return b
}

// Use bundles another module to be applied when this module is applied.
// Child modules are applied BEFORE this module's providers.
// This is for composition/bundling convenience, not dependency ordering.
func (b *ModuleBuilder) Use(m Module) *ModuleBuilder {
    b.childModules = append(b.childModules, m)
    return b
}

// Build creates the final Module
func (b *ModuleBuilder) Build() Module {
    return &builtModule{
        name:         b.name,
        providers:    b.providers,
        childModules: b.childModules,
    }
}

type builtModule struct {
    name         string
    providers    []func(*Container) error
    childModules []Module
}

func (m *builtModule) Name() string { return m.name }

func (m *builtModule) Apply(app *App) error {
    // Apply child modules FIRST (composition)
    for _, child := range m.childModules {
        if err := child.Apply(app); err != nil {
            return fmt.Errorf("child module %s: %w", child.Name(), err)
        }
    }
    // Then apply this module's providers
    for _, p := range m.providers {
        if err := p(app.container); err != nil {
            return err
        }
    }
    return nil
}
```

2. app_use.go:
```go
// Use applies a module to the app's container.
// Modules can bundle providers, configs, and other modules.
// Returns error if module with same name already registered.
// Panics if called after Build().
func (a *App) Use(m Module) *App {
    if a.built {
        panic("gaz: cannot add modules after Build()")
    }
    
    name := m.Name()
    if a.modules[name] {
        a.buildErrors = append(a.buildErrors,
            fmt.Errorf("%w: %s", ErrDuplicateModule, name))
        return a
    }
    a.modules[name] = true
    
    if err := m.Apply(a); err != nil {
        a.buildErrors = append(a.buildErrors, err)
    }
    
    return a
}
```

Run tests - they MUST pass.
  </action>
  <verify>
```bash
go test -v -run "TestModule|TestApp_Use" ./...
# All tests should pass
```
  </verify>
  <done>All ModuleBuilder and App.Use() tests pass</done>
</task>

<task type="tdd">
  <name>Task 3: REFACTOR - Clean up if needed, verify coverage</name>
  <files>module_builder.go, app_use.go, module_builder_test.go, app_use_test.go</files>
  <action>
Review implementation for cleanup opportunities:

1. Check for obvious code improvements without changing behavior
2. Add any missing edge case tests discovered during implementation
3. Ensure error messages are actionable per CONTEXT.md
4. Verify test coverage > 80%

If no refactoring needed, skip to verification.
  </action>
  <verify>
```bash
go test -cover ./... | grep -E "(module_builder|app_use)"
# Should show > 80% coverage for both files
```
  </verify>
  <done>Code is clean, tests pass, coverage > 80%</done>
</task>

</tasks>

<verification>
```bash
go test -v -run "TestModule" ./...
go test -cover ./... | grep -E "(module_builder|app_use)"
```
</verification>

<success_criteria>
- All TDD tests pass
- NewModule("name").Provide(fn).Build() works
- app.Use(module) applies module providers
- Duplicate module name detection works
- Test coverage > 80% for new code
</success_criteria>

<output>
After completion, create `.planning/phases/21-service-builder-unified-provider/21-01-SUMMARY.md`
</output>
