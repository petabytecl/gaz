---
phase: 21-service-builder-unified-provider
plan: 03
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - module_builder.go
  - module_builder_test.go
  - app_use.go
autonomous: true

must_haves:
  truths:
    - "ModuleBuilder.Flags(fn) registers CLI flags for the module"
    - "Module flags are applied when app.Use(module) is called and cobra command is available"
    - "Module flags use module-prefixed names (e.g., redis-host, not host)"
    - "ModuleBuilder.WithEnvPrefix(prefix) sets config key prefix for the module"
  artifacts:
    - path: "module_builder.go"
      provides: "Enhanced ModuleBuilder with Flags() and WithEnvPrefix()"
      exports: ["Flags", "WithEnvPrefix"]
      contains: "func (b *ModuleBuilder) Flags"
    - path: "module_builder_test.go"
      provides: "Tests for module flags integration"
      contains: "TestModule.*Flags"
  key_links:
    - from: "app_use.go"
      to: "pflag.FlagSet"
      via: "Use() calls module flags function with command's FlagSet"
      pattern: "FlagSet|PersistentFlags"
    - from: "module_builder.go"
      to: "pflag"
      via: "Flags method accepts func(*pflag.FlagSet)"
      pattern: "pflag\\.FlagSet"
---

<objective>
Add CLI flags integration to ModuleBuilder, allowing modules to bundle their flags alongside providers.

Purpose: Modules should be self-contained units that bundle everything they need - providers, config, AND CLI flags. This allows reusable modules to define their own command-line arguments.

Output: Enhanced ModuleBuilder with Flags() method, and app.Use() that applies module flags to the cobra command when available.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-service-builder-unified-provider/21-CONTEXT.md
@.planning/phases/21-service-builder-unified-provider/21-RESEARCH.md
@.planning/phases/21-service-builder-unified-provider/21-01-SUMMARY.md

# Existing patterns - check if cobra command is accessible from App
@app.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Flags() and WithEnvPrefix() to ModuleBuilder</name>
  <files>module_builder.go</files>
  <action>
Enhance ModuleBuilder to support flags and env prefix:

1. Add fields to ModuleBuilder struct:
```go
type ModuleBuilder struct {
    name         string
    providers    []func(*Container) error
    flagsFn      func(*pflag.FlagSet)  // NEW
    envPrefix    string                 // NEW
    errs         []error
}
```

2. Add Flags() method:
```go
// Flags registers CLI flags for this module.
// The flags function receives a FlagSet to register module-specific flags.
// Flags should be namespaced by module name (e.g., "redis-host" not "host")
// to avoid collisions with other modules.
func (b *ModuleBuilder) Flags(fn func(*pflag.FlagSet)) *ModuleBuilder {
    b.flagsFn = fn
    return b
}
```

3. Add WithEnvPrefix() method:
```go
// WithEnvPrefix sets the config key prefix for this module.
// When combined with service-level env prefix:
// service prefix "MYAPP_" + module prefix "redis" = "MYAPP_REDIS_HOST"
func (b *ModuleBuilder) WithEnvPrefix(prefix string) *ModuleBuilder {
    b.envPrefix = prefix
    return b
}
```

4. Update builtModule struct to store these:
```go
type builtModule struct {
    name      string
    providers []func(*Container) error
    flagsFn   func(*pflag.FlagSet)
    envPrefix string
}

// FlagsFn returns the flags registration function, or nil if none.
func (m *builtModule) FlagsFn() func(*pflag.FlagSet) {
    return m.flagsFn
}

// EnvPrefix returns the module's environment prefix, or empty string if none.
func (m *builtModule) EnvPrefix() string {
    return m.envPrefix
}
```

5. Update Module interface if needed:
```go
type Module interface {
    Name() string
    Apply(app *App) error
    // Optional methods - check at runtime:
    // FlagsFn() func(*pflag.FlagSet)
    // EnvPrefix() string
}
```

Import: `"github.com/spf13/pflag"`
  </action>
  <verify>
```bash
go build ./...
```
  </verify>
  <done>ModuleBuilder has Flags() and WithEnvPrefix() methods</done>
</task>

<task type="auto">
  <name>Task 2: Update app.Use() to apply module flags</name>
  <files>app_use.go</files>
  <action>
Modify app.Use() to call module flags function if available:

1. First, App needs access to cobra command. Check if App already has a reference to the cobra command from WithCobra(). If not, you may need to store it.

2. In app.Use(), after checking for duplicate module:
```go
func (a *App) Use(m Module) *App {
    if a.built {
        panic("gaz: cannot add modules after Build()")
    }
    
    // Check for duplicate module
    name := m.Name()
    if a.modules[name] {
        a.buildErrors = append(a.buildErrors,
            fmt.Errorf("%w: %s", ErrDuplicateModule, name))
        return a
    }
    a.modules[name] = true
    
    // Apply module flags if module provides them AND cobra command is available
    if flagsProvider, ok := m.(interface{ FlagsFn() func(*pflag.FlagSet) }); ok {
        if fn := flagsProvider.FlagsFn(); fn != nil {
            // If app has a cobra command, apply flags to it
            if a.cobraCmd != nil {
                fn(a.cobraCmd.PersistentFlags())
            }
        }
    }
    
    // Apply module providers
    if err := m.Apply(a); err != nil {
        a.buildErrors = append(a.buildErrors, err)
    }
    
    return a
}
```

Note: Check how WithCobra() is implemented. If there's no stored reference to the cobra command, you have options:
- Store the cobra.Command reference in App struct
- Apply flags during RegisterCobraFlags() call instead
- Document that flags are applied during Use() only if WithCobra() was called first

Prefer option 1 (store reference) if it doesn't require major changes.
  </action>
  <verify>
```bash
go build ./...
```
  </verify>
  <done>app.Use() applies module flags when cobra command is available</done>
</task>

<task type="auto">
  <name>Task 3: Tests for module flags integration</name>
  <files>module_builder_test.go</files>
  <action>
Add tests for flags integration:

1. TestModuleBuilder_Flags - Flags() method stores function
2. TestModuleBuilder_WithEnvPrefix - WithEnvPrefix() stores prefix
3. TestModuleBuilder_FlagsApplied - When app has cobra command, module flags are registered

```go
func TestModuleBuilder_FlagsApplied(t *testing.T) {
    cmd := &cobra.Command{Use: "test"}
    
    module := NewModule("redis").
        Flags(func(fs *pflag.FlagSet) {
            fs.String("redis-host", "localhost", "Redis host")
            fs.Int("redis-port", 6379, "Redis port")
        }).
        Build()
    
    app := New().WithCobra(cmd).Use(module)
    
    // Verify flags were registered
    hostFlag := cmd.PersistentFlags().Lookup("redis-host")
    require.NotNil(t, hostFlag)
    assert.Equal(t, "localhost", hostFlag.DefValue)
    
    portFlag := cmd.PersistentFlags().Lookup("redis-port")
    require.NotNil(t, portFlag)
    assert.Equal(t, "6379", portFlag.DefValue)
}

func TestModuleBuilder_Flags_NoCobraCommand(t *testing.T) {
    // Should not panic when no cobra command is set
    module := NewModule("test").
        Flags(func(fs *pflag.FlagSet) {
            fs.String("test-flag", "", "Test flag")
        }).
        Build()
    
    app := New().Use(module)
    
    // Should succeed without error (flags just not applied)
    err := app.Build()
    require.NoError(t, err)
}
```
  </action>
  <verify>
```bash
go test -v -run "TestModule.*Flags" ./...
go test -cover ./...
```
  </verify>
  <done>All module flags tests pass</done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
go build ./...

# Tests pass
go test -v ./...

# Coverage check
go test -cover ./...
```
</verification>

<success_criteria>
- ModuleBuilder.Flags(fn) stores flags function
- ModuleBuilder.WithEnvPrefix(prefix) stores prefix
- app.Use(module) applies flags when cobra command is available
- No panic when cobra command is not set
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/21-service-builder-unified-provider/21-03-SUMMARY.md`
</output>
