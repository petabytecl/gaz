---
phase: 21-service-builder-unified-provider
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - service/builder.go
  - service/builder_test.go
  - service/doc.go
  - health/config_provider.go
autonomous: true

must_haves:
  truths:
    - "service.New() returns a fluent ServiceBuilder"
    - "Builder.WithCmd(cmd) sets cobra command for CLI integration"
    - "Builder.WithConfig(cfg) sets config struct for loading"
    - "Builder.WithEnvPrefix(prefix) sets global environment variable prefix"
    - "Builder.WithOptions(opts...) adds gaz.Option to underlying app"
    - "Builder.Use(module) adds module to be applied at Build()"
    - "Builder.Build() creates App with all configured components and returns (App, error)"
    - "Health check auto-registers when config implements HealthConfig() health.Config"
  artifacts:
    - path: "service/builder.go"
      provides: "ServiceBuilder implementation"
      exports: ["Builder", "New"]
      min_lines: 100
    - path: "service/builder_test.go"
      provides: "Tests for service builder"
      min_lines: 80
    - path: "service/doc.go"
      provides: "Package documentation"
      min_lines: 10
    - path: "health/config_provider.go"
      provides: "HealthConfigProvider interface for auto-detection"
      exports: ["HealthConfigProvider"]
      min_lines: 15
  key_links:
    - from: "service/builder.go"
      to: "gaz.New"
      via: "Build() creates app using gaz.New()"
      pattern: "gaz\\.New\\("
    - from: "service/builder.go"
      to: "health.Module"
      via: "Auto-registers health module when config provides HealthConfig()"
      pattern: "health\\.Module"
    - from: "service/builder.go"
      to: "config.WithEnvPrefix"
      via: "Applies env prefix to config manager"
      pattern: "config\\.WithEnvPrefix"
---

<objective>
Create the service.Builder fluent API for building production-ready gaz applications with standard wiring and health check auto-registration.

Purpose: The service builder reduces boilerplate when creating production services. It wires common components (config, CLI, health checks) based on what's provided, with sensible defaults.

Output: A `service` package with fluent Builder that creates fully-configured gaz.App instances, including auto-registration of health checks when config provides health settings.

Design Note (per CONTEXT.md locked decisions):
- API is `service.New().WithCmd(cmd).WithConfig(cfg).Build()` — fluent builder pattern
- NOT `service.New(cmd, config)` — this is intentional per user's design vision
- Returns `(*gaz.App, error)` for configuration error handling
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-service-builder-unified-provider/21-CONTEXT.md
@.planning/phases/21-service-builder-unified-provider/21-RESEARCH.md
@.planning/phases/21-service-builder-unified-provider/21-01-SUMMARY.md

# Existing patterns
@app.go
@health/module.go
@config/options.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create service package with Builder</name>
  <files>service/builder.go, service/doc.go</files>
  <action>
Create new `service` package with fluent Builder:

1. Create `service/doc.go` with package documentation explaining the service builder pattern

2. Create `service/builder.go` with:

```go
type Builder struct {
    cmd       *cobra.Command
    config    any
    envPrefix string
    opts      []gaz.Option
    modules   []gaz.Module
    errs      []error
}

func New() *Builder
func (b *Builder) WithCmd(cmd *cobra.Command) *Builder
func (b *Builder) WithConfig(cfg any) *Builder
func (b *Builder) WithEnvPrefix(prefix string) *Builder
func (b *Builder) WithOptions(opts ...gaz.Option) *Builder
func (b *Builder) Use(m gaz.Module) *Builder
func (b *Builder) Build() (*gaz.App, error)
```

Build() implementation:
- Return early if errs slice is non-empty (using errors.Join)
- Create gaz.New(b.opts...)
- If config is set, call app.WithConfig with config.WithEnvPrefix if envPrefix is set
- Apply each module via app.Use()
- If cmd is set, call app.WithCobra(cmd) (or whatever the existing pattern is)
- Auto-register health module if config implements HealthConfigProvider interface

Import path: `github.com/petabytecl/gaz/service`
  </action>
  <verify>
```bash
go build ./service/...
```
  </verify>
  <done>Service package compiles with all Builder methods</done>
</task>

<task type="auto">
  <name>Task 2: Add HealthConfigProvider interface</name>
  <files>health/config_provider.go</files>
  <action>
Create `health/config_provider.go` with:

```go
// HealthConfigProvider is implemented by config structs that provide health settings.
// When a config implementing this interface is passed to service.Builder,
// the health module is automatically registered.
type HealthConfigProvider interface {
    HealthConfig() Config
}
```

Update service/builder.go Build() to check:
```go
if hp, ok := b.config.(health.HealthConfigProvider); ok {
    cfg := hp.HealthConfig()
    // Register health.Config in container so health.Module can resolve it
    if err := gaz.For[health.Config](app.Container()).Instance(cfg); err != nil {
        return nil, fmt.Errorf("register health config: %w", err)
    }
    // Apply health module
    if err := app.Use(health.NewModule()); err != nil {
        return nil, fmt.Errorf("apply health module: %w", err)
    }
}
```

Note: You may need to create a health.NewModule() function that wraps the existing health.Module function into a gaz.Module interface. Use the pattern from Plan 01's ModuleBuilder:
```go
func NewModule() gaz.Module {
    return gaz.NewModule("health").
        Provide(Module). // existing Module function
        Build()
}
```
  </action>
  <verify>
```bash
go build ./health/... ./service/...
```
  </verify>
  <done>HealthConfigProvider interface exists and service builder auto-detects it</done>
</task>

<task type="auto">
  <name>Task 3: Tests for service builder</name>
  <files>service/builder_test.go</files>
  <action>
Create comprehensive tests:

1. TestBuilder_Basic - New().Build() returns valid App
2. TestBuilder_WithConfig - Config struct is loaded
3. TestBuilder_WithEnvPrefix - Env prefix is applied to config
4. TestBuilder_WithOptions - gaz.Options are applied to app
5. TestBuilder_Use - Modules are applied to app
6. TestBuilder_HealthAutoRegistration - Health module auto-registers when config implements HealthConfigProvider
7. TestBuilder_ChainableMethods - All methods return *Builder for chaining

For the health auto-registration test:
```go
type testConfigWithHealth struct {
    AppName string
    Health  health.Config
}

func (c *testConfigWithHealth) HealthConfig() health.Config {
    return c.Health
}

func TestBuilder_HealthAutoRegistration(t *testing.T) {
    cfg := &testConfigWithHealth{
        Health: health.Config{Enabled: true, Port: 8081},
    }
    app, err := service.New().
        WithConfig(cfg).
        Build()
    require.NoError(t, err)
    
    // Verify health module was registered
    _, err = gaz.Resolve[*health.Manager](app.Container())
    require.NoError(t, err)
}
```
  </action>
  <verify>
```bash
go test -v ./service/...
go test -cover ./service/...
```
  </verify>
  <done>All service builder tests pass with > 80% coverage</done>
</task>

</tasks>

<verification>
```bash
# Package builds
go build ./service/... ./health/...

# Tests pass
go test -v ./service/... ./health/...

# Coverage check
go test -cover ./service/...
```
</verification>

<success_criteria>
- service.New() fluent builder works
- Builder.Build() returns (*gaz.App, error)
- Health module auto-registers when config implements HealthConfigProvider
- Environment prefix is applied to config loading
- All tests pass with > 80% coverage
</success_criteria>

<output>
After completion, create `.planning/phases/21-service-builder-unified-provider/21-02-SUMMARY.md`
</output>
