---
phase: 28-testing-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - health/testing.go
  - health/testing_test.go
  - worker/testing.go
  - worker/testing_test.go
  - cron/testing.go
  - cron/testing_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "health.TestConfig() returns safe defaults for testing"
    - "worker.TestConfig() returns safe defaults for testing"
    - "Each subsystem has mock factories for testify mocking"
    - "Each subsystem has Require* assertion helpers"
  artifacts:
    - path: "health/testing.go"
      provides: "Health test helpers, mock factories, assertions"
      contains: "TestConfig"
    - path: "worker/testing.go"
      provides: "Worker test helpers, mock factories, assertions"
      contains: "MockWorker"
    - path: "cron/testing.go"
      provides: "Cron test helpers, mock factories, assertions"
      contains: "MockJob"
  key_links:
    - from: "health/testing.go"
      to: "testing.TB"
      via: "Require* helpers use TB interface"
      pattern: "testing\\.TB"
    - from: "worker/testing.go"
      to: "testify/mock"
      via: "MockWorker embeds mock.Mock"
      pattern: "mock\\.Mock"
---

<objective>
Create testing.go files for health, worker, and cron subsystems

Purpose: Provide test utilities for each subsystem: TestConfig(), mock factories, and Require* assertion helpers
Output: health/testing.go, worker/testing.go, cron/testing.go with complete test helper suites
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-testing-infrastructure/28-CONTEXT.md
@.planning/phases/28-testing-infrastructure/28-RESEARCH.md
@health/config.go
@health/types.go
@health/manager.go
@worker/worker.go
@worker/options.go
@cron/job.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health/testing.go</name>
  <files>health/testing.go, health/testing_test.go</files>
  <action>
Create health/testing.go with:

1. **TestConfig() and NewTestConfig(opts...)**
```go
// TestConfig returns a health.Config with safe defaults for testing.
// Uses port 0 for random available port.
func TestConfig() Config {
    return Config{
        Port:          0, // Random available port
        LivenessPath:  "/live",
        ReadinessPath: "/ready",
        StartupPath:   "/startup",
    }
}

// NewTestConfig returns a test config with custom options applied.
func NewTestConfig(opts ...func(*Config)) Config {
    cfg := TestConfig()
    for _, opt := range opts {
        opt(&cfg)
    }
    return cfg
}
```

2. **MockRegistrar** - Mock for health.Registrar interface
```go
// MockRegistrar is a test double for health.Registrar.
type MockRegistrar struct {
    mock.Mock
}

func (m *MockRegistrar) AddLivenessCheck(name string, check CheckFunc) {
    m.Called(name, check)
}
// ... other methods

func NewMockRegistrar() *MockRegistrar {
    m := &MockRegistrar{}
    // Set up default expectations
    m.On("AddLivenessCheck", mock.Anything, mock.Anything).Return()
    m.On("AddReadinessCheck", mock.Anything, mock.Anything).Return()
    m.On("AddStartupCheck", mock.Anything, mock.Anything).Return()
    return m
}
```

3. **TestManager()** - Factory for test Manager
```go
// TestManager creates a Manager with no checks registered, suitable for testing.
func TestManager() *Manager {
    return NewManager()
}
```

4. **Require* assertion helpers**
```go
// RequireHealthy checks that all registered checks pass.
func RequireHealthy(tb testing.TB, m *Manager) {
    tb.Helper()
    // Run readiness check and verify status is UP
}

// RequireCheckRegistered verifies a check with the given name is registered.
func RequireCheckRegistered(tb testing.TB, m *Manager, checkType, name string) {
    tb.Helper()
    // Verify check exists
}
```

Create health/testing_test.go with tests for all helpers.
  </action>
  <verify>Run `go test ./health/... -v` - tests pass</verify>
  <done>health/testing.go has TestConfig, MockRegistrar, TestManager, Require* helpers</done>
</task>

<task type="auto">
  <name>Task 2: Create worker/testing.go</name>
  <files>worker/testing.go, worker/testing_test.go</files>
  <action>
Create worker/testing.go with:

1. **MockWorker** - Mock for worker.Worker interface
```go
// MockWorker is a testify mock implementing worker.Worker.
type MockWorker struct {
    mock.Mock
}

func (m *MockWorker) Name() string {
    args := m.Called()
    return args.String(0)
}

func (m *MockWorker) OnStart(ctx context.Context) error {
    args := m.Called(ctx)
    return args.Error(0)
}

func (m *MockWorker) OnStop(ctx context.Context) error {
    args := m.Called(ctx)
    return args.Error(0)
}

// NewMockWorker creates a MockWorker with default expectations.
// Name returns "mock-worker", OnStart/OnStop return nil.
func NewMockWorker() *MockWorker {
    m := &MockWorker{}
    m.On("Name").Return("mock-worker")
    m.On("OnStart", mock.Anything).Return(nil)
    m.On("OnStop", mock.Anything).Return(nil)
    return m
}

// NewMockWorkerNamed creates a MockWorker with a custom name.
func NewMockWorkerNamed(name string) *MockWorker {
    m := &MockWorker{}
    m.On("Name").Return(name)
    m.On("OnStart", mock.Anything).Return(nil)
    m.On("OnStop", mock.Anything).Return(nil)
    return m
}
```

2. **SimpleWorker** - A simple test worker for cases where mock complexity isn't needed
```go
// SimpleWorker is a test worker that tracks OnStart/OnStop calls.
type SimpleWorker struct {
    name     string
    Started  atomic.Bool
    Stopped  atomic.Bool
    StartErr error
    StopErr  error
}

func NewSimpleWorker(name string) *SimpleWorker {
    return &SimpleWorker{name: name}
}

func (w *SimpleWorker) Name() string { return w.name }
func (w *SimpleWorker) OnStart(ctx context.Context) error {
    w.Started.Store(true)
    return w.StartErr
}
func (w *SimpleWorker) OnStop(ctx context.Context) error {
    w.Stopped.Store(true)
    return w.StopErr
}
```

3. **TestManager()** - Factory for test Manager
```go
// TestManager creates a worker.Manager suitable for testing.
func TestManager(logger *slog.Logger) *Manager {
    if logger == nil {
        logger = slog.New(slog.NewTextHandler(io.Discard, nil))
    }
    return NewManager(logger)
}
```

4. **Require* assertion helpers**
```go
// RequireWorkerStarted asserts the worker's OnStart was called.
func RequireWorkerStarted(tb testing.TB, w *SimpleWorker) {
    tb.Helper()
    if !w.Started.Load() {
        tb.Fatalf("expected worker %q to be started", w.Name())
    }
}

// RequireWorkerStopped asserts the worker's OnStop was called.
func RequireWorkerStopped(tb testing.TB, w *SimpleWorker) {
    tb.Helper()
    if !w.Stopped.Load() {
        tb.Fatalf("expected worker %q to be stopped", w.Name())
    }
}
```

Import: "github.com/stretchr/testify/mock", "testing", "sync/atomic", "context", "log/slog", "io"

Create worker/testing_test.go with tests.
  </action>
  <verify>Run `go test ./worker/... -v` - tests pass</verify>
  <done>worker/testing.go has MockWorker, SimpleWorker, TestManager, Require* helpers</done>
</task>

<task type="auto">
  <name>Task 3: Create cron/testing.go</name>
  <files>cron/testing.go, cron/testing_test.go</files>
  <action>
Create cron/testing.go with:

1. **MockJob** - Mock for cron.CronJob interface
```go
// MockJob is a testify mock implementing cron.CronJob.
type MockJob struct {
    mock.Mock
}

func (m *MockJob) Name() string {
    args := m.Called()
    return args.String(0)
}

func (m *MockJob) Schedule() string {
    args := m.Called()
    return args.String(0)
}

func (m *MockJob) Timeout() time.Duration {
    args := m.Called()
    return args.Get(0).(time.Duration)
}

func (m *MockJob) Run(ctx context.Context) error {
    args := m.Called(ctx)
    return args.Error(0)
}

// NewMockJob creates a MockJob with default expectations.
// Schedule returns "@every 1m", Timeout returns 30s, Run returns nil.
func NewMockJob(name string) *MockJob {
    m := &MockJob{}
    m.On("Name").Return(name)
    m.On("Schedule").Return("@every 1m")
    m.On("Timeout").Return(30 * time.Second)
    m.On("Run", mock.Anything).Return(nil)
    return m
}
```

2. **SimpleJob** - A simple test job for straightforward testing
```go
// SimpleJob is a test job that tracks Run calls.
type SimpleJob struct {
    name     string
    schedule string
    timeout  time.Duration
    RunCount atomic.Int32
    RunErr   error
}

func NewSimpleJob(name, schedule string) *SimpleJob {
    return &SimpleJob{
        name:     name,
        schedule: schedule,
        timeout:  30 * time.Second,
    }
}

func (j *SimpleJob) Name() string            { return j.name }
func (j *SimpleJob) Schedule() string        { return j.schedule }
func (j *SimpleJob) Timeout() time.Duration  { return j.timeout }
func (j *SimpleJob) Run(ctx context.Context) error {
    j.RunCount.Add(1)
    return j.RunErr
}
```

3. **TestScheduler()** - Factory for test Scheduler
```go
// TestScheduler creates a cron.Scheduler suitable for testing.
// Jobs can be added but scheduler should not be started in most unit tests.
func TestScheduler(c *di.Container, logger *slog.Logger) *Scheduler {
    if logger == nil {
        logger = slog.New(slog.NewTextHandler(io.Discard, nil))
    }
    if c == nil {
        c = di.New()
    }
    return NewScheduler(c, context.Background(), logger)
}
```

4. **Require* assertion helpers**
```go
// RequireJobRan asserts the job was executed at least once.
func RequireJobRan(tb testing.TB, j *SimpleJob) {
    tb.Helper()
    if j.RunCount.Load() == 0 {
        tb.Fatalf("expected job %q to have run at least once", j.Name())
    }
}

// RequireJobRunCount asserts the job ran exactly n times.
func RequireJobRunCount(tb testing.TB, j *SimpleJob, expected int32) {
    tb.Helper()
    actual := j.RunCount.Load()
    if actual != expected {
        tb.Fatalf("expected job %q to run %d times, got %d", j.Name(), expected, actual)
    }
}
```

Import: "github.com/stretchr/testify/mock", "testing", "sync/atomic", "context", "time", "log/slog", "io"
Also import di package for TestScheduler.

Create cron/testing_test.go with tests.
  </action>
  <verify>Run `go test ./cron/... -v` - tests pass</verify>
  <done>cron/testing.go has MockJob, SimpleJob, TestScheduler, Require* helpers</done>
</task>

</tasks>

<verification>
1. `go build ./health/... ./worker/... ./cron/...` succeeds
2. `go test ./health/... ./worker/... ./cron/... -v` passes
3. Each subsystem has: TestConfig or test factory, Mock type, Simple type, Require* helpers
</verification>

<success_criteria>
- health/testing.go exists with TestConfig, NewTestConfig, MockRegistrar, TestManager, Require* helpers
- worker/testing.go exists with MockWorker, SimpleWorker, TestManager, Require* helpers
- cron/testing.go exists with MockJob, SimpleJob, TestScheduler, Require* helpers
- All helpers use testing.TB and tb.Helper() for proper test reporting
- Mock types use testify/mock
</success_criteria>

<output>
After completion, create `.planning/phases/28-testing-infrastructure/28-02-SUMMARY.md`
</output>
