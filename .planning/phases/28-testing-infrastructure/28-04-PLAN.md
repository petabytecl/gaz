---
phase: 28-testing-infrastructure
plan: 04
type: execute
wave: 2
depends_on: [28-01, 28-02, 28-03]
files_modified:
  - gaztest/README.md
  - gaztest/examples_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "gaztest/README.md contains testing guide with quick reference"
    - "Guide covers unit testing vs integration testing patterns"
    - "Guide documents all v3 testing patterns (WithModules, RequireResolve, subsystem helpers)"
    - "Example tests demonstrate core v3 patterns"
  artifacts:
    - path: "gaztest/README.md"
      provides: "Testing guide documentation"
      contains: "Quick Reference"
    - path: "gaztest/examples_test.go"
      provides: "Runnable Godoc examples"
      contains: "Example_"
  key_links:
    - from: "gaztest/README.md"
      to: "subsystem testing.go files"
      via: "documents helper usage"
      pattern: "health\\.TestConfig|worker\\.MockWorker"
---

<objective>
Create testing guide documentation and comprehensive example tests

Purpose: Document testing patterns for v3 and provide runnable examples demonstrating all patterns
Output: gaztest/README.md with layered testing guide, gaztest/examples_test.go with Godoc examples
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-testing-infrastructure/28-CONTEXT.md
@.planning/phases/28-testing-infrastructure/28-RESEARCH.md
@.planning/phases/28-testing-infrastructure/28-01-SUMMARY.md
@.planning/phases/28-testing-infrastructure/28-02-SUMMARY.md
@.planning/phases/28-testing-infrastructure/28-03-SUMMARY.md
@gaztest/doc.go
@gaztest/builder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gaztest/README.md testing guide</name>
  <files>gaztest/README.md</files>
  <action>
Create gaztest/README.md with comprehensive testing guide:

```markdown
# Testing with gaz

This guide covers testing patterns for gaz applications.

## Quick Reference

```go
// Basic test app setup
app, err := gaztest.New(t).Build()
app.RequireStart()
defer app.RequireStop()

// With modules (v3 pattern)
app, err := gaztest.New(t).
    WithModules(myModule).
    Build()

// Type-safe resolution that fails on error
svc := gaztest.RequireResolve[*MyService](t, app)

// Per-subsystem helpers
cfg := health.TestConfig()
worker := worker.NewMockWorker()
job := cron.NewMockJob("my-job")
bus := eventbus.TestBus()
mgr := config.TestManager(map[string]any{"key": "value"})
```

## Testing Patterns

### Unit Testing with Mocks

When testing a single component in isolation, use mock dependencies:

```go
func TestUserService_Create(t *testing.T) {
    // Create mocks
    mockDB := &mocks.Database{}
    mockDB.On("Insert", mock.Anything).Return(nil)
    
    // Build test app with mock
    baseApp := gaz.New()
    gaz.For[Database](baseApp.Container()).Instance(mockDB)
    baseApp.Build()
    
    app, err := gaztest.New(t).
        WithApp(baseApp).
        Build()
    require.NoError(t, err)
    
    app.RequireStart()
    defer app.RequireStop()
    
    // Resolve service under test
    svc := gaztest.RequireResolve[*UserService](t, app)
    
    // Test
    err = svc.Create(ctx, user)
    require.NoError(t, err)
    mockDB.AssertExpectations(t)
}
```

### Integration Testing with Modules

When testing module interactions, use WithModules:

```go
func TestHealthModule_Integration(t *testing.T) {
    cfg := health.TestConfig()
    module := health.NewModule(health.WithConfig(cfg))
    
    app, err := gaztest.New(t).
        WithModules(module).
        Build()
    require.NoError(t, err)
    
    app.RequireStart()
    defer app.RequireStop()
    
    // Verify health endpoints are available
    mgr := gaztest.RequireResolve[*health.Manager](t, app)
    require.NotNil(t, mgr)
}
```

### Testing Workers

```go
func TestWorkerLifecycle(t *testing.T) {
    w := worker.NewSimpleWorker("test-worker")
    
    // Register and start
    mgr := worker.TestManager(nil)
    mgr.Add(w)
    
    ctx := context.Background()
    require.NoError(t, mgr.Start(ctx))
    
    // Assert
    worker.RequireWorkerStarted(t, w)
    
    // Cleanup
    require.NoError(t, mgr.Stop(ctx))
    worker.RequireWorkerStopped(t, w)
}
```

### Testing Cron Jobs

```go
func TestCronJob_Execution(t *testing.T) {
    job := cron.NewSimpleJob("test-job", "@every 1s")
    
    // Manually invoke Run to test job logic
    err := job.Run(context.Background())
    require.NoError(t, err)
    
    cron.RequireJobRan(t, job)
    cron.RequireJobRunCount(t, job, 1)
}
```

### Testing EventBus Subscribers

```go
func TestEventHandler(t *testing.T) {
    bus := eventbus.TestBus()
    defer bus.Close()
    
    // Create subscriber expecting 1 event
    sub := eventbus.NewTestSubscriber[UserCreated](1)
    eventbus.Subscribe[UserCreated](bus, sub.Handler())
    
    // Publish
    eventbus.Publish(context.Background(), bus, UserCreated{UserID: "123"}, "")
    
    // Wait for async delivery
    eventbus.RequireEventsReceived(t, sub, time.Second)
    eventbus.RequireEventCount(t, sub, 1)
    
    // Assert event content
    events := sub.Events()
    require.Equal(t, "123", events[0].UserID)
}
```

### Testing Configuration

```go
func TestConfigLoading(t *testing.T) {
    mgr := config.TestManager(map[string]any{
        "app.host": "localhost",
        "app.port": 9090,
    })
    
    var cfg config.SampleConfig
    config.RequireConfigLoaded(t, mgr, &cfg)
    
    require.Equal(t, "localhost", cfg.Host)
    require.Equal(t, 9090, cfg.Port)
}
```

## Unit vs Integration Testing

| Pattern | When to Use | Tools |
|---------|-------------|-------|
| Unit (mocks) | Testing single component logic | MockWorker, MockJob, MockRegistrar |
| Integration | Testing component interactions | WithModules, real subsystems |
| End-to-end | Testing full app behavior | WithApp, full lifecycle |

### Guidelines

1. **Prefer unit tests** for business logic
2. **Use integration tests** for module wiring verification  
3. **Mock external dependencies** (databases, APIs)
4. **Use TestConfig/TestManager** for subsystem defaults
5. **Use RequireResolve** instead of manual Resolve + error check

## Subsystem Test Helpers

Each subsystem provides test helpers in a `testing.go` file:

- `health/testing.go` - TestConfig, MockRegistrar, RequireHealthy
- `worker/testing.go` - MockWorker, SimpleWorker, RequireWorkerStarted
- `cron/testing.go` - MockJob, SimpleJob, RequireJobRan
- `config/testing.go` - MapBackend, TestManager, RequireConfigLoaded
- `eventbus/testing.go` - TestBus, TestSubscriber, RequireEventsReceived

## Best Practices

1. **Always use t.Cleanup or defer** for app shutdown
2. **Use RequireResolve** for cleaner test code
3. **TestSubscriber.WaitFor** handles async eventbus delivery
4. **Port 0** in TestConfig selects random available port
5. **SimpleWorker/SimpleJob** are easier than mocks for simple cases
```
  </action>
  <verify>File exists at gaztest/README.md with testing patterns documented</verify>
  <done>gaztest/README.md contains complete testing guide with quick reference, patterns, and examples</done>
</task>

<task type="auto">
  <name>Task 2: Update gaztest/examples_test.go with v3 examples</name>
  <files>gaztest/examples_test.go</files>
  <action>
Update gaztest/examples_test.go to add v3 pattern examples. Keep existing examples, add new ones:

1. **Example_withModules** - Demonstrates WithModules pattern
```go
func Example_withModules() {
    t := &testing.T{}
    
    // Create a simple module
    module := di.NewModuleFunc("example", func(c *di.Container) error {
        return di.For[string](c).Instance("hello from module")
    })
    
    // Build test app with module
    app, err := gaztest.New(t).
        WithModules(module).
        Build()
    if err != nil {
        fmt.Println("build failed:", err)
        return
    }
    
    app.RequireStart()
    defer app.RequireStop()
    
    // Module's service is available
    // In real code: msg := gaztest.RequireResolve[string](t, app)
}
```

2. **Example_requireResolve** - Demonstrates RequireResolve pattern
```go
func Example_requireResolve() {
    t := &testing.T{}
    
    // Register a service
    baseApp := gaz.New()
    gaz.For[*DatabaseConfig](baseApp.Container()).Instance(&DatabaseConfig{Host: "localhost"})
    baseApp.Build()
    
    app, err := gaztest.New(t).WithApp(baseApp).Build()
    if err != nil {
        fmt.Println("build failed:", err)
        return
    }
    
    app.RequireStart()
    defer app.RequireStop()
    
    // RequireResolve fails test if resolution fails
    // cfg := gaztest.RequireResolve[*DatabaseConfig](t, app)
    // cfg.Host is "localhost"
}
```

3. **Example_subsystemHelpers** - Demonstrates subsystem helper usage
```go
func Example_subsystemHelpers() {
    // Health subsystem
    healthCfg := health.TestConfig() // Port 0 for random available
    _ = healthCfg
    
    // Worker subsystem
    w := worker.NewSimpleWorker("background-task")
    _ = w
    
    // Cron subsystem
    job := cron.NewSimpleJob("daily-report", "@daily")
    _ = job
    
    // EventBus subsystem
    bus := eventbus.TestBus()
    defer bus.Close()
    
    // Config subsystem
    mgr := config.TestManager(map[string]any{
        "app.debug": true,
    })
    _ = mgr
}
```

4. **TestExample_IntegrationTest** - Full integration test example
```go
func TestExample_IntegrationTest(t *testing.T) {
    // This demonstrates a complete integration test pattern
    
    // Create module under test
    module := di.NewModuleFunc("test-module", func(c *di.Container) error {
        return di.For[*TestServiceExample](c).Provider(func(c *di.Container) (*TestServiceExample, error) {
            return &TestServiceExample{Name: "integration"}, nil
        })
    })
    
    app, err := gaztest.New(t).
        WithModules(module).
        Build()
    require.NoError(t, err)
    
    app.RequireStart()
    defer app.RequireStop()
    
    svc := gaztest.RequireResolve[*TestServiceExample](t, app)
    require.Equal(t, "integration", svc.Name)
}

type TestServiceExample struct {
    Name string
}
```

Import any needed packages: health, worker, cron, eventbus, config from gaz subsystems.
  </action>
  <verify>Run `go test ./gaztest/... -v` - examples compile and run</verify>
  <done>gaztest/examples_test.go contains v3 pattern examples: WithModules, RequireResolve, subsystem helpers</done>
</task>

<task type="auto">
  <name>Task 3: Clean up old examples and verify documentation</name>
  <files>gaztest/example_test.go, gaztest/doc.go</files>
  <action>
1. Review gaztest/example_test.go - if it exists separately from examples_test.go, consolidate into examples_test.go

2. Update gaztest/doc.go package documentation to reference new v3 patterns:
   - Mention WithModules for module testing
   - Mention RequireResolve for type-safe resolution
   - Reference README.md for full testing guide
   - Update examples in doc.go comments if they use old patterns

3. Ensure all examples use v3 patterns:
   - Use WithModules instead of manual registration when testing modules
   - Use RequireResolve instead of Resolve + error check
   - Reference subsystem testing.go helpers

4. Run `go doc ./gaztest` to verify documentation renders correctly
  </action>
  <verify>Run `go doc ./gaztest` - documentation shows v3 patterns; `go test ./gaztest/...` passes</verify>
  <done>Documentation updated with v3 patterns, examples consolidated, go doc renders correctly</done>
</task>

</tasks>

<verification>
1. gaztest/README.md exists with testing guide
2. `go test ./gaztest/... -v` passes (examples are runnable)
3. `go doc ./gaztest` shows updated package documentation
4. Guide covers: unit testing, integration testing, all subsystem helpers
</verification>

<success_criteria>
- gaztest/README.md contains layered testing guide (quick reference + detailed sections)
- Guide documents WithModules, RequireResolve, all subsystem helpers
- gaztest/examples_test.go has runnable Godoc examples for v3 patterns
- Package documentation references testing guide
- All examples compile and pass as tests
</success_criteria>

<output>
After completion, create `.planning/phases/28-testing-infrastructure/28-04-SUMMARY.md`
</output>
