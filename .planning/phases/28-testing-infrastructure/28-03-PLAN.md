---
phase: 28-testing-infrastructure
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - config/testing.go
  - config/testing_test.go
  - eventbus/testing.go
  - eventbus/testing_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "config.TestManager() returns a Manager with in-memory backend for testing"
    - "eventbus.TestBus() returns an EventBus suitable for testing"
    - "Each subsystem has mock factories for testify mocking"
    - "eventbus has synchronization helpers for async testing"
  artifacts:
    - path: "config/testing.go"
      provides: "Config test helpers, mock backend, test manager"
      contains: "TestManager"
    - path: "eventbus/testing.go"
      provides: "EventBus test helpers, mock subscriber"
      contains: "TestBus"
  key_links:
    - from: "config/testing.go"
      to: "testing.TB"
      via: "Require* helpers use TB interface"
      pattern: "testing\\.TB"
    - from: "eventbus/testing.go"
      to: "sync.WaitGroup"
      via: "TestSubscriber uses WaitGroup for sync"
      pattern: "sync\\.WaitGroup"
---

<objective>
Create testing.go files for config and eventbus subsystems

Purpose: Provide test utilities for config and eventbus: test factories, mock types, and assertion/sync helpers
Output: config/testing.go, eventbus/testing.go with complete test helper suites
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-testing-infrastructure/28-CONTEXT.md
@.planning/phases/28-testing-infrastructure/28-RESEARCH.md
@config/types.go
@config/backend.go
@config/manager.go
@eventbus/bus.go
@eventbus/event.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config/testing.go</name>
  <files>config/testing.go, config/testing_test.go</files>
  <action>
Create config/testing.go with:

1. **MapBackend** - Simple in-memory backend for testing
```go
// MapBackend is a simple in-memory config backend for testing.
// It implements Backend with Get/GetString/GetInt/GetBool using a map.
type MapBackend struct {
    values map[string]any
    mu     sync.RWMutex
}

// NewMapBackend creates a MapBackend with initial values.
func NewMapBackend(values map[string]any) *MapBackend {
    if values == nil {
        values = make(map[string]any)
    }
    return &MapBackend{values: values}
}

// Set sets a value (for test setup).
func (b *MapBackend) Set(key string, value any) {
    b.mu.Lock()
    defer b.mu.Unlock()
    b.values[key] = value
}

// Implement Backend interface methods:
// Get, GetString, GetInt, GetBool, GetFloat64, GetDuration, GetStringSlice, etc.
// Use simple type assertions from the map.
```

2. **TestManager()** - Factory for test config Manager
```go
// TestManager creates a config.Manager with an in-memory MapBackend.
// Pass initial values or nil for empty config.
func TestManager(values map[string]any) *Manager {
    backend := NewMapBackend(values)
    return New(WithBackend(backend))
}
```

3. **TestConfig struct** - Common test config pattern
```go
// SampleConfig is a sample config struct for testing config loading.
type SampleConfig struct {
    Host    string `mapstructure:"host"`
    Port    int    `mapstructure:"port"`
    Debug   bool   `mapstructure:"debug"`
}

// Default implements Defaulter.
func (c *SampleConfig) Default() {
    if c.Host == "" {
        c.Host = "localhost"
    }
    if c.Port == 0 {
        c.Port = 8080
    }
}
```

4. **Require* assertion helpers**
```go
// RequireConfigLoaded verifies config was loaded without error.
func RequireConfigLoaded(tb testing.TB, m *Manager, target any) {
    tb.Helper()
    if err := m.LoadInto(target); err != nil {
        tb.Fatalf("failed to load config: %v", err)
    }
}

// RequireConfigValue verifies a config key has expected value.
func RequireConfigValue(tb testing.TB, b Backend, key string, expected any) {
    tb.Helper()
    actual := b.Get(key)
    if actual != expected {
        tb.Fatalf("config key %q: expected %v, got %v", key, expected, actual)
    }
}
```

Import: "testing", "sync"

Create config/testing_test.go with tests for MapBackend and helpers.
  </action>
  <verify>Run `go test ./config/... -v` - tests pass</verify>
  <done>config/testing.go has MapBackend, TestManager, SampleConfig, Require* helpers</done>
</task>

<task type="auto">
  <name>Task 2: Create eventbus/testing.go</name>
  <files>eventbus/testing.go, eventbus/testing_test.go</files>
  <action>
Create eventbus/testing.go with:

1. **TestBus()** - Factory for test EventBus
```go
// TestBus creates an EventBus suitable for testing.
// Uses a discard logger to avoid log noise in tests.
func TestBus() *EventBus {
    logger := slog.New(slog.NewTextHandler(io.Discard, nil))
    return New(logger)
}
```

2. **TestSubscriber[T]** - A subscriber that collects events and supports synchronization
```go
// TestSubscriber collects events for testing and supports waiting for events.
type TestSubscriber[T Event] struct {
    events []T
    mu     sync.Mutex
    wg     sync.WaitGroup
    count  int // Expected event count for WaitFor
}

// NewTestSubscriber creates a TestSubscriber expecting n events.
// Use n=0 if you don't know how many events to expect.
func NewTestSubscriber[T Event](expectedCount int) *TestSubscriber[T] {
    ts := &TestSubscriber[T]{count: expectedCount}
    if expectedCount > 0 {
        ts.wg.Add(expectedCount)
    }
    return ts
}

// Handler returns a handler function suitable for eventbus.Subscribe.
func (ts *TestSubscriber[T]) Handler() Handler[T] {
    return func(ctx context.Context, event T) {
        ts.mu.Lock()
        ts.events = append(ts.events, event)
        if ts.count > 0 && len(ts.events) <= ts.count {
            ts.wg.Done()
        }
        ts.mu.Unlock()
    }
}

// Events returns a copy of received events.
func (ts *TestSubscriber[T]) Events() []T {
    ts.mu.Lock()
    defer ts.mu.Unlock()
    result := make([]T, len(ts.events))
    copy(result, ts.events)
    return result
}

// WaitFor waits for the expected number of events with timeout.
func (ts *TestSubscriber[T]) WaitFor(timeout time.Duration) bool {
    done := make(chan struct{})
    go func() {
        ts.wg.Wait()
        close(done)
    }()
    
    select {
    case <-done:
        return true
    case <-time.After(timeout):
        return false
    }
}

// Count returns the number of events received.
func (ts *TestSubscriber[T]) Count() int {
    ts.mu.Lock()
    defer ts.mu.Unlock()
    return len(ts.events)
}
```

3. **Require* assertion helpers**
```go
// RequireEventReceived asserts at least one event was received.
func RequireEventReceived[T Event](tb testing.TB, ts *TestSubscriber[T]) {
    tb.Helper()
    if ts.Count() == 0 {
        tb.Fatal("expected at least one event, got none")
    }
}

// RequireEventCount asserts exact number of events received.
func RequireEventCount[T Event](tb testing.TB, ts *TestSubscriber[T], expected int) {
    tb.Helper()
    actual := ts.Count()
    if actual != expected {
        tb.Fatalf("expected %d events, got %d", expected, actual)
    }
}

// RequireEventsReceived waits for events with timeout and fails if not received.
func RequireEventsReceived[T Event](tb testing.TB, ts *TestSubscriber[T], timeout time.Duration) {
    tb.Helper()
    if !ts.WaitFor(timeout) {
        tb.Fatalf("timeout waiting for events after %v, received %d", timeout, ts.Count())
    }
}
```

Import: "testing", "sync", "time", "context", "log/slog", "io"

Create eventbus/testing_test.go with tests for TestSubscriber and helpers.
  </action>
  <verify>Run `go test ./eventbus/... -v` - tests pass</verify>
  <done>eventbus/testing.go has TestBus, TestSubscriber, Require* helpers</done>
</task>

</tasks>

<verification>
1. `go build ./config/... ./eventbus/...` succeeds
2. `go test ./config/... ./eventbus/... -v` passes
3. Each subsystem has appropriate test utilities
</verification>

<success_criteria>
- config/testing.go exists with MapBackend, TestManager, SampleConfig, Require* helpers
- eventbus/testing.go exists with TestBus, TestSubscriber[T], Require* helpers
- TestSubscriber provides synchronization for async eventbus testing
- All helpers use testing.TB and tb.Helper() for proper test reporting
</success_criteria>

<output>
After completion, create `.planning/phases/28-testing-infrastructure/28-03-SUMMARY.md`
</output>
