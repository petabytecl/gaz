---
phase: 28-testing-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gaztest/builder.go
  - gaztest/resolve.go
  - gaztest/resolve_test.go
  - gaztest/builder_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "gaztest.Builder accepts di.Module via WithModules()"
    - "gaztest.Builder accepts config map via WithConfigMap()"
    - "RequireResolve[T] fails test immediately on resolution error"
  artifacts:
    - path: "gaztest/builder.go"
      provides: "WithModules and WithConfigMap builder methods"
      contains: "WithModules"
    - path: "gaztest/resolve.go"
      provides: "RequireResolve generic helper"
      contains: "RequireResolve"
  key_links:
    - from: "gaztest/builder.go"
      to: "di.Module"
      via: "WithModules accepts variadic di.Module"
      pattern: "WithModules.*di\\.Module"
    - from: "gaztest/resolve.go"
      to: "gaz.Resolve"
      via: "calls Resolve and fails test on error"
      pattern: "gaz\\.Resolve\\["
---

<objective>
Enhance gaztest Builder API with v3 module support and helper functions

Purpose: Enable testing with v3 module registration, config injection, and type-safe resolution that fails tests on error
Output: Extended gaztest.Builder with WithModules(), WithConfigMap(), and RequireResolve[T]() helper
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-testing-infrastructure/28-CONTEXT.md
@.planning/phases/28-testing-infrastructure/28-RESEARCH.md
@gaztest/builder.go
@gaztest/app.go
@di/module.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WithModules and WithConfigMap to Builder</name>
  <files>gaztest/builder.go</files>
  <action>
Add two new builder methods:

1. `WithModules(m ...di.Module) *Builder` - Accepts variadic di.Module for registering modules in the test app
   - Store modules in a `modules []di.Module` field on Builder
   - In Build(), if modules are provided and no baseApp is set, create a new gaz.App and call app.Use(module) for each
   - If baseApp is set AND modules provided, panic with error - cannot combine both patterns

2. `WithConfigMap(values map[string]any) *Builder` - Accepts raw config map for injecting test config
   - Store in `configMap map[string]any` field on Builder
   - In Build(), if configMap is set, use viper.MergeConfigMap (via config backend) to inject values
   - This requires the app to have a config manager with viper backend

Import additions needed:
- "github.com/petabytecl/gaz/di" (already imported)

Update Build() method to:
1. Check for conflicting WithApp + WithModules (panic with clear message)
2. If modules provided (without baseApp), create new gaz.App with gaz.New(), then call Use() for each module
3. Apply configMap if provided using the viper backend's MergeConfigMap
  </action>
  <verify>Run `go build ./gaztest/...` - no compilation errors</verify>
  <done>WithModules and WithConfigMap methods exist on Builder, Build() handles them correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add RequireResolve generic helper</name>
  <files>gaztest/resolve.go</files>
  <action>
Create new file gaztest/resolve.go with RequireResolve[T] helper:

```go
package gaztest

import (
    "github.com/petabytecl/gaz"
)

// RequireResolve resolves type T from the test app and fails the test if resolution fails.
// This is a convenience wrapper that calls gaz.Resolve[T] and fails with t.Fatalf on error.
//
// Example:
//
//   db := gaztest.RequireResolve[*Database](t, app)
//   // use db directly - no error check needed
//
func RequireResolve[T any](tb TB, app *App) T {
    tb.Helper()
    result, err := gaz.Resolve[T](app.Container())
    if err != nil {
        tb.Fatalf("gaztest: RequireResolve[%s]: %v", gaz.TypeName[T](), err)
    }
    return result
}
```

Key points:
- Uses TB interface (same as builder.go) for testing.T/testing.B compatibility
- Calls tb.Helper() for proper test line reporting
- Calls gaz.TypeName[T]() to get readable type name in error message
- Returns T directly, no error return (fails test on error)
  </action>
  <verify>Run `go build ./gaztest/...` - no compilation errors</verify>
  <done>RequireResolve[T] function exists in gaztest package, uses TB interface</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for new gaztest API</name>
  <files>gaztest/builder_test.go, gaztest/resolve_test.go</files>
  <action>
Add tests for the new functionality:

1. In gaztest/resolve_test.go (new file):
   - TestRequireResolve_Success: Register a service, RequireResolve returns it
   - TestRequireResolve_NotRegistered: RequireResolve fails test (use mock TB to capture Fatalf)

2. In gaztest/gaztest_test.go (add to existing):
   - TestBuilder_WithModules: Register module via WithModules, service is available
   - TestBuilder_WithModules_MultipleModules: Multiple modules work
   - TestBuilder_WithApp_AndModules_Panics: Verify panic when combining WithApp + WithModules
   - TestBuilder_WithConfigMap: Config values are accessible in app

Use existing mockTB pattern from gaztest_test.go for capturing Fatalf calls.

For WithModules tests, create a simple test module:
```go
testModule := di.NewModuleFunc("test", func(c *di.Container) error {
    return di.For[string](c).Instance("test-value")
})
```
  </action>
  <verify>Run `go test ./gaztest/... -v` - all tests pass</verify>
  <done>Tests cover WithModules, WithConfigMap, and RequireResolve functionality</done>
</task>

</tasks>

<verification>
1. `go build ./gaztest/...` succeeds
2. `go test ./gaztest/... -v` passes all tests
3. `go vet ./gaztest/...` reports no issues
</verification>

<success_criteria>
- WithModules(m ...di.Module) method exists on Builder
- WithConfigMap(map[string]any) method exists on Builder
- RequireResolve[T](tb, app) function exists in gaztest package
- All new functionality has test coverage
- No breaking changes to existing gaztest API
</success_criteria>

<output>
After completion, create `.planning/phases/28-testing-infrastructure/28-01-SUMMARY.md`
</output>
