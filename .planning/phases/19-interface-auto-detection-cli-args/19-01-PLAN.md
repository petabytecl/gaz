---
phase: 19
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified: [di/service.go, di/lifecycle_auto_test.go]
autonomous: true
must_haves:
  truths:
    - "Service implementing Starter interface has OnStart called automatically"
    - "Service implementing Stopper interface has OnStop called automatically"
    - "Explicit OnStart registration takes precedence over interface"
    - "Interface detection works for both value and pointer receivers"
  artifacts:
    - path: "di/service.go"
      provides: "Updated HasLifecycle logic"
    - path: "di/lifecycle_auto_test.go"
      provides: "Comprehensive lifecycle tests"
  key_links:
    - from: "di/service.go"
      to: "Starter interface"
      via: "Type assertion in HasLifecycle"
---

<objective>
Implement automatic detection of `Starter` and `Stopper` interfaces on services.
This removes the need for explicit `.OnStart()` registration when the service struct already implements the interface.

Purpose: Reduce boilerplate and align with "sane defaults" core value.
Output: Services with `OnStart`/`OnStop` methods just work.
</objective>

<feature>
  <name>Lifecycle Auto-Detection</name>
  <files>di/service.go, di/lifecycle_auto_test.go</files>
  <behavior>
    1. HasLifecycle() returns true if T or *T implements Starter/Stopper
    2. Start() executes OnStart() from interface if no explicit hook exists
    3. Stop() executes OnStop() from interface if no explicit hook exists
    4. Explicit hooks (WithStart/WithStop) ALWAYS override interface methods
    5. Support pointer receivers on value-type services (common Go pattern)
  </behavior>
  <implementation>
    - Update `lazySingleton[T].HasLifecycle` and `eagerSingleton[T].HasLifecycle`
    - Use `any(new(T)).(Starter)` to check pointer method sets even for value types
    - Update `baseService.runStartLifecycle` to check interface if hooks are empty
    - Ensure correct instance pointer is passed when calling interface methods
  </implementation>
</feature>
