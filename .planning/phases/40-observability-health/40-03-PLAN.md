---
phase: 40-observability-health
plan: 03
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - server/health/checks/pgx/doc.go
  - server/health/checks/pgx/check.go
  - server/health/check_test.go
  - server/health/aggregator_test.go
  - server/health/grpc_test.go
  - server/health/module_test.go
  - server/health/checks/pgx/check_test.go
  - server/otel/provider_test.go
  - server/otel/module_test.go
autonomous: true

must_haves:
  truths:
    - "PGX health check returns healthy when database is reachable"
    - "PGX health check returns error when database is unreachable"
    - "All server/health tests pass with 90%+ coverage"
    - "All server/otel tests pass with 90%+ coverage"
  artifacts:
    - path: "server/health/checks/pgx/check.go"
      provides: "Postgres health check using pgxpool.Ping"
      exports: ["Check", "NewCheck"]
    - path: "server/health/aggregator_test.go"
      provides: "Aggregator unit tests"
      min_lines: 100
    - path: "server/health/grpc_test.go"
      provides: "gRPC health server tests"
      min_lines: 50
    - path: "server/otel/provider_test.go"
      provides: "TracerProvider tests"
      min_lines: 50
  key_links:
    - from: "server/health/checks/pgx/check.go"
      to: "github.com/jackc/pgx/v5/pgxpool"
      via: "calls pool.Ping()"
      pattern: "pool\\.Ping"
    - from: "server/health/checks/pgx/check.go"
      to: "server/health/check.go"
      via: "implements HealthCheckMeta"
      pattern: "HealthCheckMeta"
---

<objective>
Implement PGX health check and comprehensive tests for health and otel packages to achieve 90%+ coverage.

Purpose: Provide production-ready Postgres health check and ensure observability infrastructure is well-tested.
Output: PGX health check package and comprehensive test suites for server/health and server/otel.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-observability-health/40-CONTEXT.md
@.planning/phases/40-observability-health/40-RESEARCH.md
@.planning/phases/40-observability-health/40-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PGX health check</name>
  <files>
    server/health/checks/pgx/doc.go
    server/health/checks/pgx/check.go
    go.mod
  </files>
  <action>
Create the server/health/checks/pgx package:

**doc.go:**
Package documentation explaining Postgres health check using pgxpool.Ping().

**check.go:**
Implement Postgres health check per RESEARCH.md Pattern 6:

```go
import (
    "context"
    "github.com/jackc/pgx/v5/pgxpool"
    "github.com/petabytecl/gaz/server/health"
)

// Check implements HealthCheckMeta for PostgreSQL connectivity.
type Check struct {
    pool     *pgxpool.Pool
    name     string
    critical bool
}

// NewCheck creates a new PostgreSQL health check.
// Parameters:
//   - pool: pgxpool.Pool to check
//   - opts: optional configuration (name, critical flag)
func NewCheck(pool *pgxpool.Pool, opts ...Option) *Check

// Option configures the Check.
type Option func(*Check)

// WithName sets the check name (default: "postgres").
func WithName(name string) Option

// WithCritical sets whether the check is critical (default: true).
func WithCritical(critical bool) Option

// Check performs the health check by pinging the database.
func (c *Check) Check(ctx context.Context) error {
    return c.pool.Ping(ctx)
}

// Name returns the check name.
func (c *Check) Name() string { return c.name }

// Critical returns whether this check is critical.
func (c *Check) Critical() bool { return c.critical }

// Compile-time interface check
var _ health.HealthCheckMeta = (*Check)(nil)
```

Add dependency:
```bash
go get github.com/jackc/pgx/v5/pgxpool@latest
```

Note: This package does NOT include a DI module. Users register the check manually in their app module because they need to provide the pgxpool.Pool.
  </action>
  <verify>
`go build ./server/health/checks/pgx/...` compiles. `go mod tidy` succeeds.
  </verify>
  <done>
PGX health check implements HealthCheckMeta using pgxpool.Ping() with configurable name and critical flag.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for health package</name>
  <files>
    server/health/check_test.go
    server/health/aggregator_test.go
    server/health/grpc_test.go
    server/health/module_test.go
    server/health/checks/pgx/check_test.go
  </files>
  <action>
Create comprehensive tests for the server/health package:

**check_test.go:**
Test Status enum and interface compile-time checks.

**aggregator_test.go:**
Test Aggregator behavior:
1. TestAggregator_AllHealthy - all checks pass -> StatusServing
2. TestAggregator_CriticalFails - critical check fails -> StatusNotServing
3. TestAggregator_OptionalFails - optional check fails -> StatusDegraded
4. TestAggregator_BackgroundRefresh - status updates on interval
5. TestAggregator_Timeout - check timeout is respected (3s limit)
6. TestAggregator_StopCleanly - context cancellation stops loop
7. TestAggregator_Results - Results() returns check error map

Use mock health checks that can be configured to pass/fail.

**grpc_test.go:**
Test gRPC health Server:
1. TestServer_Register - registers with grpc.ServiceRegistrar
2. TestServer_StatusSync - updates grpc health status when aggregator changes
3. TestServer_InitialUnknown - starts with UNKNOWN status
4. TestServer_DegradedMapsToServing - StatusDegraded -> SERVING

Use actual grpc health client to verify status:
```go
import healthpb "google.golang.org/grpc/health/grpc_health_v1"
// Create test gRPC server, register health, query with client
```

**module_test.go:**
Test module registration:
1. TestNewModule_Registers - registers Aggregator and Server
2. TestNewModule_Options - WithInterval option works
3. TestNewModule_Discovery - discovers HealthCheckMeta implementations

**checks/pgx/check_test.go:**
Test PGX check:
1. TestCheck_Implements - compile-time interface check
2. TestCheck_Defaults - default name="postgres", critical=true
3. TestCheck_Options - WithName and WithCritical work
4. TestCheck_Healthy - mock pool.Ping returns nil -> Check returns nil
5. TestCheck_Unhealthy - mock pool.Ping returns error -> Check returns error

For PGX mock, use interface abstraction or skip actual DB test (unit test only).
  </action>
  <verify>
`go test ./server/health/...` passes. Coverage: `go test -cover ./server/health/...` shows 90%+.
  </verify>
  <done>
Comprehensive tests for health package with 90%+ coverage including aggregator, gRPC server, module, and PGX check.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for otel package</name>
  <files>
    server/otel/provider_test.go
    server/otel/config_test.go
    server/otel/module_test.go
  </files>
  <action>
Create comprehensive tests for the server/otel package:

**config_test.go:**
Test Config:
1. TestDefaultConfig - defaults are sensible (endpoint empty, sample 0.1, etc.)

**provider_test.go:**
Test TracerProvider:
1. TestInitTracer_Disabled - empty endpoint returns nil (disabled)
2. TestInitTracer_Creates - valid endpoint creates TracerProvider
3. TestInitTracer_SetsGlobal - sets otel.GetTracerProvider()
4. TestInitTracer_GracefulDegradation - invalid endpoint logs warning, returns nil
5. TestShutdownTracer_Nil - nil provider returns no error
6. TestShutdownTracer_Flushes - provider shutdown is called

For testing without actual OTLP collector:
- Use invalid endpoint that fails immediately
- Or use otlptracetest package if available
- Focus on code paths, not actual trace export

**module_test.go:**
Test module:
1. TestNewModule_Registers - registers TracerProvider (or nil)
2. TestNewModule_Options - WithEndpoint, WithServiceName work
3. TestNewModule_EnvFallback - reads OTEL_EXPORTER_OTLP_ENDPOINT if set
4. TestNewModule_Stopper - TracerProvider shutdown on app stop

Use environment variable manipulation for env fallback test.
  </action>
  <verify>
`go test ./server/otel/...` passes. Coverage: `go test -cover ./server/otel/...` shows 90%+.
  </verify>
  <done>
Comprehensive tests for otel package with 90%+ coverage including provider setup, config, and module.
  </done>
</task>

</tasks>

<verification>
- [ ] `go test ./server/health/...` passes
- [ ] `go test ./server/health/checks/pgx/...` passes
- [ ] `go test ./server/otel/...` passes
- [ ] `go test -cover ./server/health/...` shows 90%+ coverage
- [ ] `go test -cover ./server/otel/...` shows 90%+ coverage
- [ ] `make test` passes (all project tests)
- [ ] `make cover` passes (90% project-wide threshold)
- [ ] `make lint` passes
</verification>

<success_criteria>
PGX health check implemented and all observability packages have comprehensive tests with 90%+ coverage. Phase 40 requirements (INF-01, INF-02, INF-03) complete.
</success_criteria>

<output>
After completion, create `.planning/phases/40-observability-health/40-03-SUMMARY.md`
</output>
