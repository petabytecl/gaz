---
phase: 40-observability-health
plan: 03
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - health/checks/pgx/doc.go
  - health/checks/pgx/pgx.go
  - health/checks/pgx/pgx_test.go
  - server/grpc/module.go
  - server/otel/provider_test.go
  - server/otel/config_test.go
  - server/otel/module_test.go
autonomous: true

must_haves:
  truths:
    - "PGX health check returns healthy when database is reachable"
    - "PGX health check returns error when database is unreachable"
    - "gRPC server automatically registers health endpoint when health.GRPCServer is available"
    - "All server/otel tests pass with 90%+ coverage"
  artifacts:
    - path: "health/checks/pgx/pgx.go"
      provides: "Postgres health check using pgxpool.Ping"
      exports: ["New", "Config"]
    - path: "health/checks/pgx/pgx_test.go"
      provides: "PGX check tests"
      min_lines: 50
    - path: "server/otel/provider_test.go"
      provides: "TracerProvider tests"
      min_lines: 50
  key_links:
    - from: "health/checks/pgx/pgx.go"
      to: "github.com/jackc/pgx/v5/pgxpool"
      via: "calls pool.Ping()"
      pattern: "pool\\.Ping"
    - from: "server/grpc/module.go"
      to: "health/grpc.go"
      via: "resolves and registers GRPCServer"
      pattern: "GRPCServer"
---

<objective>
Implement PGX health check, integrate gRPC health with server/grpc module, and add comprehensive tests for otel package.

Purpose: Complete observability infrastructure with Postgres health check and full test coverage.
Output: PGX health check in health/checks/pgx/, gRPC health integration, and comprehensive tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-observability-health/40-CONTEXT.md
@.planning/phases/40-observability-health/40-RESEARCH.md
@.planning/phases/40-observability-health/40-01-SUMMARY.md
@health/checks/sql/sql.go
@health/types.go
@server/grpc/module.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PGX health check</name>
  <files>
    health/checks/pgx/doc.go
    health/checks/pgx/pgx.go
    health/checks/pgx/pgx_test.go
    go.mod
  </files>
  <action>
Create the health/checks/pgx package following the pattern of health/checks/sql:

**doc.go:**
```go
// Package pgx provides a health check for PostgreSQL databases using pgx/v5.
package pgx
```

**pgx.go:**
```go
package pgx

import (
    "context"
    "errors"
    "fmt"

    "github.com/jackc/pgx/v5/pgxpool"
)

// ErrNilPool is returned when the pool is nil.
var ErrNilPool = errors.New("pgx: pool is nil")

// Config configures the PGX database health check.
type Config struct {
    // Pool is the pgx connection pool to check. Required.
    Pool *pgxpool.Pool
}

// New creates a new PGX database health check.
// Uses Ping which is optimized for connection testing and respects
// the context deadline.
//
// Returns nil if healthy (ping succeeds), error if unhealthy.
func New(cfg Config) func(context.Context) error {
    return func(ctx context.Context) error {
        if cfg.Pool == nil {
            return ErrNilPool
        }
        if err := cfg.Pool.Ping(ctx); err != nil {
            return fmt.Errorf("pgx: ping failed: %w", err)
        }
        return nil
    }
}
```

This follows the exact same pattern as health/checks/sql/sql.go.

**pgx_test.go:**
Test the check:
1. TestNew_NilPool - returns ErrNilPool
2. TestNew_Healthy - mock pool.Ping returns nil -> Check returns nil
3. TestNew_Unhealthy - mock pool.Ping returns error -> Check returns wrapped error

For testing without a real database, use an interface or integration test flag.

Add dependency:
```bash
go get github.com/jackc/pgx/v5/pgxpool@latest
```
  </action>
  <verify>
`go build ./health/checks/pgx/...` compiles. `go test ./health/checks/pgx/...` passes.
  </verify>
  <done>
PGX health check implemented following existing sql check pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate gRPC health with server/grpc module</name>
  <files>
    server/grpc/module.go
  </files>
  <action>
Update server/grpc/module.go to automatically register health.GRPCServer when available:

In the gRPC server provider, after creating the server, check if GRPCServer is available:

```go
// In the Server provider, after creating grpc.Server...

// Try to resolve and register gRPC health server
if grpcHealth, err := di.Resolve[*health.GRPCServer](c); err == nil && grpcHealth != nil {
    grpcHealth.Register(srv)
}
```

This pattern allows health to be optional - if the user includes `health.NewModule(health.WithGRPC())`, the gRPC health endpoint is automatically wired.

Also add import for health package:
```go
import "github.com/petabytecl/gaz/health"
```

Update module test to verify health integration works when health module is included.
  </action>
  <verify>
`go build ./server/grpc/...` compiles. `go test ./server/grpc/...` passes.
  </verify>
  <done>
server/grpc module automatically registers health.GRPCServer when available.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for otel package</name>
  <files>
    server/otel/provider_test.go
    server/otel/config_test.go
    server/otel/module_test.go
  </files>
  <action>
Create comprehensive tests for the server/otel package:

**config_test.go:**
1. TestDefaultConfig - defaults are sensible (endpoint empty, sample 0.1, etc.)

**provider_test.go:**
Test TracerProvider:
1. TestInitTracer_Disabled - empty endpoint returns nil (disabled)
2. TestInitTracer_Creates - valid endpoint creates TracerProvider (may need mock or skip in CI)
3. TestInitTracer_SetsGlobal - sets otel.GetTracerProvider()
4. TestInitTracer_GracefulDegradation - invalid/unreachable endpoint logs warning, returns nil
5. TestShutdownTracer_Nil - nil provider returns no error
6. TestShutdownTracer_Timeout - uses 5s timeout

For testing without actual OTLP collector:
- Use invalid endpoint that fails connection
- Focus on code paths, not actual trace export
- Use testify mock for logger to verify warning logged

**module_test.go:**
Test module:
1. TestNewModule_Registers - registers TracerProvider (or nil)
2. TestNewModule_Options - WithEndpoint, WithServiceName work
3. TestNewModule_EnvFallback - reads OTEL_EXPORTER_OTLP_ENDPOINT if set
4. TestNewModule_Stopper - tracerProviderStopper shutdown called on app stop

Use environment variable manipulation for env fallback test:
```go
t.Setenv("OTEL_EXPORTER_OTLP_ENDPOINT", "localhost:4317")
```
  </action>
  <verify>
`go test ./server/otel/...` passes. Coverage: `go test -cover ./server/otel/...` shows 90%+.
  </verify>
  <done>
Comprehensive tests for otel package with 90%+ coverage.
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./health/checks/pgx/...` succeeds
- [ ] `go test ./health/checks/pgx/...` passes
- [ ] `go build ./server/grpc/...` succeeds
- [ ] `go test ./server/grpc/...` passes
- [ ] `go test ./server/otel/...` passes with 90%+ coverage
- [ ] `make test` passes (all project tests)
- [ ] `make cover` passes (90% project-wide threshold)
- [ ] `make lint` passes
</verification>

<success_criteria>
PGX health check implemented, gRPC health integrated with server/grpc module, and otel package fully tested. Phase 40 requirements (INF-01, INF-02, INF-03) complete.
</success_criteria>

<output>
After completion, create `.planning/phases/40-observability-health/40-03-SUMMARY.md`
</output>
