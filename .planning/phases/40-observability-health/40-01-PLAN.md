---
phase: 40-observability-health
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - health/grpc.go
  - health/grpc_test.go
  - health/module.go
autonomous: true

must_haves:
  truths:
    - "gRPC health endpoint returns SERVING status when all readiness checks pass"
    - "gRPC health endpoint returns NOT_SERVING when any readiness check fails"
    - "gRPC health endpoint integrates with existing health.Manager"
    - "gRPC health server registers with the gRPC server via DI"
  artifacts:
    - path: "health/grpc.go"
      provides: "gRPC health server wrapper using existing Manager"
      exports: ["GRPCServer", "NewGRPCServer"]
    - path: "health/grpc_test.go"
      provides: "gRPC health server tests"
      min_lines: 80
  key_links:
    - from: "health/grpc.go"
      to: "google.golang.org/grpc/health"
      via: "wraps health.Server"
      pattern: "health\\.NewServer"
    - from: "health/grpc.go"
      to: "health/manager.go"
      via: "uses Manager.ReadinessChecker()"
      pattern: "ReadinessChecker"
    - from: "health/module.go"
      to: "health/grpc.go"
      via: "registers GRPCServer"
      pattern: "GRPCServer"
---

<objective>
Add gRPC health endpoint (`grpc.health.v1`) to the existing health package, wrapping the existing Manager's readiness checks.

Purpose: Enable standard gRPC health protocol for load balancer integration, using the existing health check infrastructure.
Output: GRPCServer in existing health/ package that syncs Manager's readiness status to grpc.health.v1.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-observability-health/40-CONTEXT.md
@.planning/phases/40-observability-health/40-RESEARCH.md
@health/types.go
@health/manager.go
@health/module.go
@health/server.go
@server/grpc/server.go
@server/grpc/module.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gRPC health server wrapper</name>
  <files>
    health/grpc.go
  </files>
  <action>
Create grpc.go in the existing health/ package that wraps google.golang.org/grpc/health:

```go
package health

import (
    "context"
    "log/slog"
    "sync"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/health"
    healthpb "google.golang.org/grpc/health/grpc_health_v1"
)

// GRPCServer wraps grpc-go's health.Server and syncs status from the Manager.
type GRPCServer struct {
    health   *health.Server
    manager  *Manager
    logger   *slog.Logger
    interval time.Duration
    
    mu         sync.Mutex
    lastStatus healthpb.HealthCheckResponse_ServingStatus
    stopCh     chan struct{}
}

// NewGRPCServer creates a new gRPC health server.
func NewGRPCServer(manager *Manager, logger *slog.Logger, opts ...GRPCServerOption) *GRPCServer

// GRPCServerOption configures the GRPCServer.
type GRPCServerOption func(*GRPCServer)

// WithCheckInterval sets the interval for checking Manager status (default 5s).
func WithCheckInterval(d time.Duration) GRPCServerOption
```

The GRPCServer should:
1. Wrap grpc-go's built-in health.Server
2. Poll Manager.ReadinessChecker() at configurable interval (default 5s)
3. Map checker status to gRPC health proto:
   - All checks pass -> SERVING
   - Any check fails -> NOT_SERVING
4. Provide Register(grpc.ServiceRegistrar) to register with gRPC server
5. Start with UNKNOWN status, update after first check
6. Log when status transitions (SERVING -> NOT_SERVING, etc.)
7. Implement di.Starter (starts polling loop) and di.Stopper (stops loop)

Use empty service name "" for overall server health (per CONTEXT.md decision).

Implementation approach:
- In OnStart, start a goroutine that polls every interval
- Each poll: call manager.ReadinessChecker().Check(ctx)
- If err == nil -> SERVING, else -> NOT_SERVING
- Only call SetServingStatus if status changed
- Log transitions at Info level

Add dependency:
```bash
go get google.golang.org/grpc/health@latest
```
  </action>
  <verify>
`go build ./health/...` compiles without errors. `go mod tidy` succeeds.
  </verify>
  <done>
GRPCServer created that wraps grpc-go health.Server and syncs status from existing Manager.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GRPCServer tests</name>
  <files>
    health/grpc_test.go
  </files>
  <action>
Create comprehensive tests for GRPCServer:

**grpc_test.go:**
1. TestGRPCServer_Register - registers with grpc.ServiceRegistrar
2. TestGRPCServer_InitialUnknown - starts with UNKNOWN status before first check
3. TestGRPCServer_Healthy - all checks pass -> SERVING
4. TestGRPCServer_Unhealthy - check fails -> NOT_SERVING
5. TestGRPCServer_StatusTransition - logs and updates on status change
6. TestGRPCServer_StopCleanly - OnStop stops polling loop

Use testify suite pattern consistent with existing health tests.

For testing gRPC health status, create a test gRPC server and use healthpb client:
```go
import (
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    healthpb "google.golang.org/grpc/health/grpc_health_v1"
)

// Create in-memory gRPC server, register health, query with client
lis := bufconn.Listen(1024 * 1024)
srv := grpc.NewServer()
grpcServer.Register(srv)
go srv.Serve(lis)

// Create client
conn, _ := grpc.Dial("bufnet", grpc.WithContextDialer(...), grpc.WithTransportCredentials(insecure.NewCredentials()))
client := healthpb.NewHealthClient(conn)
resp, _ := client.Check(ctx, &healthpb.HealthCheckRequest{})
```
  </action>
  <verify>
`go test ./health/...` passes. Coverage for grpc.go is 90%+.
  </verify>
  <done>
Comprehensive tests for GRPCServer with grpc.health.v1 client verification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update health module to optionally register GRPCServer</name>
  <files>
    health/module.go
  </files>
  <action>
Update the existing health/module.go to optionally register GRPCServer:

Add new ModuleOption:
```go
// WithGRPC enables the gRPC health server.
// When enabled, GRPCServer is registered and can be resolved by the gRPC server module.
func WithGRPC() ModuleOption
```

Update moduleConfig to track grpc enablement:
```go
type moduleConfig struct {
    // ... existing fields
    enableGRPC    bool
    grpcInterval  time.Duration
}
```

In NewModule/Module, if enableGRPC is true:
```go
// Register GRPCServer (implements di.Starter and di.Stopper)
if cfg.enableGRPC {
    if err := di.For[*GRPCServer](c).
        Eager().
        Provider(func(c *di.Container) (*GRPCServer, error) {
            manager, err := di.Resolve[*Manager](c)
            if err != nil {
                return nil, err
            }
            // Logger is optional
            logger := slog.Default()
            if l, err := di.Resolve[*slog.Logger](c); err == nil {
                logger = l
            }
            return NewGRPCServer(manager, logger, WithCheckInterval(cfg.grpcInterval)), nil
        }); err != nil {
        return fmt.Errorf("register grpc health server: %w", err)
    }
}
```

The GRPCServer is NOT automatically registered with the gRPC server here.
Instead, the server/grpc module will resolve *health.GRPCServer and call Register().

Add option:
```go
// WithGRPCInterval sets the gRPC health check polling interval (default 5s).
func WithGRPCInterval(d time.Duration) ModuleOption
```
  </action>
  <verify>
`go build ./health/...` compiles. `go test ./health/...` passes. `make lint` passes.
  </verify>
  <done>
Health module updated with WithGRPC() option to enable gRPC health server registration.
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./health/...` succeeds
- [ ] `go test ./health/...` passes
- [ ] GRPCServer wraps grpc-go health.Server
- [ ] GRPCServer syncs status from Manager.ReadinessChecker()
- [ ] GRPCServer implements di.Starter and di.Stopper
- [ ] GRPCServer provides Register(grpc.ServiceRegistrar) method
- [ ] Module has WithGRPC() option to enable gRPC health
- [ ] `make lint` passes (may need depguard update for google.golang.org/grpc/health)
</verification>

<success_criteria>
gRPC health endpoint implemented in existing health/ package, using Manager's readiness checks. Ready for integration with server/grpc module.
</success_criteria>

<output>
After completion, create `.planning/phases/40-observability-health/40-01-SUMMARY.md`
</output>
