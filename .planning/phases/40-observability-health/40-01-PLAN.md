---
phase: 40-observability-health
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/health/doc.go
  - server/health/check.go
  - server/health/aggregator.go
  - server/health/grpc.go
  - server/health/module.go
autonomous: true

must_haves:
  truths:
    - "gRPC health endpoint returns SERVING status when all critical checks pass"
    - "gRPC health endpoint returns NOT_SERVING when any critical check fails"
    - "Health checks run in background with configurable interval"
    - "Health results are cached to prevent thundering herd"
  artifacts:
    - path: "server/health/check.go"
      provides: "HealthCheck and HealthCheckMeta interfaces"
      exports: ["HealthCheck", "HealthCheckMeta"]
    - path: "server/health/aggregator.go"
      provides: "Background check runner with caching"
      exports: ["Aggregator", "NewAggregator", "Status"]
    - path: "server/health/grpc.go"
      provides: "gRPC health server wrapper"
      exports: ["Server", "NewServer"]
    - path: "server/health/module.go"
      provides: "DI module for health subsystem"
      exports: ["NewModule", "ModuleOption"]
  key_links:
    - from: "server/health/grpc.go"
      to: "google.golang.org/grpc/health"
      via: "wraps health.Server"
      pattern: "health\\.NewServer"
    - from: "server/health/aggregator.go"
      to: "server/health/check.go"
      via: "runs HealthCheckMeta checks"
      pattern: "HealthCheckMeta"
    - from: "server/health/module.go"
      to: "di.ResolveAll[HealthCheckMeta]"
      via: "auto-discovers checks"
      pattern: "ResolveAll\\[HealthCheckMeta\\]"
---

<objective>
Implement gRPC health check infrastructure with extensible check interface, background aggregator, and standard grpc.health.v1 endpoint.

Purpose: Enable production health monitoring via standard gRPC health protocol with auto-discovered checks.
Output: server/health package with check interface, aggregator, gRPC server wrapper, and DI module.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-observability-health/40-CONTEXT.md
@.planning/phases/40-observability-health/40-RESEARCH.md
@server/grpc/server.go
@server/grpc/module.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health check interface and aggregator</name>
  <files>
    server/health/doc.go
    server/health/check.go
    server/health/aggregator.go
  </files>
  <action>
Create the server/health package with the following files:

**doc.go:**
Package documentation explaining the gRPC health system with auto-discovery via di.ResolveAll[HealthCheckMeta].

**check.go:**
Define health check interfaces:

```go
// HealthCheck performs a health check.
type HealthCheck interface {
    Check(ctx context.Context) error
}

// HealthCheckMeta extends HealthCheck with metadata.
type HealthCheckMeta interface {
    HealthCheck
    Name() string     // Check name (e.g., "postgres", "redis")
    Critical() bool   // True = NOT_SERVING on failure, False = degraded only
}
```

Also define Status type:
- StatusServing = all checks pass
- StatusDegraded = only optional checks fail
- StatusNotServing = any critical check fails

**aggregator.go:**
Implement Aggregator that:
1. Runs checks in background on configurable interval (default 10s)
2. Caches results to prevent thundering herd
3. Uses 3s timeout per individual check
4. Provides Status() method returning current aggregated status
5. Provides Results() method returning map[string]error for check details
6. Implements di.Starter (starts background loop) and di.Stopper (stops loop)

Key implementation details:
- Use sync.RWMutex for thread-safe result access
- Initial check runs synchronously on Start to have immediate status
- Background goroutine uses time.Ticker for periodic checks
- Context cancellation stops background loop cleanly
  </action>
  <verify>
`go build ./server/health/...` compiles without errors
  </verify>
  <done>
HealthCheck, HealthCheckMeta interfaces defined with Status enum. Aggregator runs checks in background with caching.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create gRPC health server wrapper</name>
  <files>
    server/health/grpc.go
  </files>
  <action>
Create grpc.go that wraps google.golang.org/grpc/health:

```go
type Server struct {
    health     *health.Server
    aggregator *Aggregator
    logger     *slog.Logger
}

func NewServer(aggregator *Aggregator, logger *slog.Logger) *Server
```

The Server should:
1. Wrap grpc-go's built-in health.Server
2. Subscribe to Aggregator status changes via polling or callback
3. Map Status values to gRPC health proto:
   - StatusServing -> SERVING
   - StatusDegraded -> SERVING (still functional, log degraded state)
   - StatusNotServing -> NOT_SERVING
4. Provide Register(grpc.ServiceRegistrar) to register with gRPC server
5. Start with UNKNOWN status, update after first check completes
6. Log when status transitions (SERVING -> NOT_SERVING, etc.)

Use empty service name "" for overall server health (per CONTEXT.md decision).

Important: The Server must listen for Aggregator status updates. Options:
- Poll Aggregator.Status() on a ticker and call SetServingStatus when changed
- Have Aggregator call a callback/channel when status changes
  </action>
  <verify>
`go build ./server/health/...` compiles without errors
  </verify>
  <done>
gRPC health Server wrapper created that syncs Aggregator status to grpc.health.v1 serving status.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DI module for health subsystem</name>
  <files>
    server/health/module.go
  </files>
  <action>
Create module.go with DI registration:

```go
func NewModule(opts ...ModuleOption) di.Module
```

ModuleOptions:
- WithInterval(time.Duration) - background check interval (default 10s)

The module should:
1. Register Aggregator as singleton
2. Register Server as singleton
3. Use di.ResolveAll[HealthCheckMeta] to discover all health checks
4. Wire Aggregator to Server
5. Both Aggregator and Server implement Starter/Stopper for lifecycle

Registration order:
1. Aggregator (discovers checks, runs background loop)
2. Server (wraps grpc health, syncs status)

The Aggregator needs access to discovered checks. Pattern:
- In provider callback, call di.ResolveAll[HealthCheckMeta] to get checks
- Pass checks slice to NewAggregator

Follow existing module patterns from server/grpc/module.go.
  </action>
  <verify>
`go build ./server/health/...` compiles. `go test ./server/health/...` runs (may have no tests yet).
  </verify>
  <done>
Health module registers Aggregator and Server with auto-discovery of HealthCheckMeta implementations.
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./server/health/...` succeeds
- [ ] Package exports HealthCheck, HealthCheckMeta, Status, Aggregator, Server, NewModule
- [ ] Aggregator implements di.Starter and di.Stopper
- [ ] Server provides Register(grpc.ServiceRegistrar) method
- [ ] Module uses di.ResolveAll[HealthCheckMeta] for auto-discovery
- [ ] `make lint` passes (may need depguard updates for google.golang.org/grpc/health)
</verification>

<success_criteria>
gRPC health subsystem compiles with interface, aggregator, server wrapper, and DI module. Ready for integration with gRPC server and health check implementations.
</success_criteria>

<output>
After completion, create `.planning/phases/40-observability-health/40-01-SUMMARY.md`
</output>
