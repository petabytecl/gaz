---
phase: 40-observability-health
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - server/otel/doc.go
  - server/otel/config.go
  - server/otel/provider.go
  - server/otel/module.go
  - server/grpc/server.go
  - server/grpc/module.go
  - server/gateway/gateway.go
  - server/gateway/module.go
autonomous: true

must_haves:
  truths:
    - "Traces are generated for gRPC requests when OTEL endpoint is configured"
    - "Traces are generated for Gateway HTTP requests when OTEL endpoint is configured"
    - "Trace context propagates from Gateway HTTP to gRPC via W3C headers"
    - "Application starts gracefully if OTEL collector is unreachable"
    - "Health check endpoints are excluded from tracing"
  artifacts:
    - path: "server/otel/provider.go"
      provides: "TracerProvider setup with OTLP exporter"
      exports: ["InitTracer", "ShutdownTracer"]
    - path: "server/otel/config.go"
      provides: "OTEL configuration struct"
      exports: ["Config"]
    - path: "server/otel/module.go"
      provides: "DI module for OTEL"
      exports: ["NewModule", "ModuleOption"]
    - path: "server/grpc/server.go"
      provides: "gRPC server with OTEL stats handler"
      contains: "otelgrpc.NewServerHandler"
    - path: "server/gateway/gateway.go"
      provides: "Gateway with OTEL HTTP instrumentation"
      contains: "otelhttp.NewHandler"
  key_links:
    - from: "server/otel/provider.go"
      to: "go.opentelemetry.io/otel"
      via: "sets global tracer provider"
      pattern: "otel\\.SetTracerProvider"
    - from: "server/grpc/server.go"
      to: "server/otel"
      via: "uses otelgrpc stats handler when enabled"
      pattern: "grpc\\.StatsHandler"
    - from: "server/gateway/gateway.go"
      to: "server/otel"
      via: "wraps handler with otelhttp"
      pattern: "otelhttp\\.NewHandler"
---

<objective>
Implement OpenTelemetry tracing infrastructure with OTLP export and instrument gRPC/HTTP servers for distributed tracing.

Purpose: Enable production observability with distributed tracing across Gateway -> gRPC request flows.
Output: server/otel package with TracerProvider setup, plus instrumentation of existing gRPC and Gateway servers.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-observability-health/40-CONTEXT.md
@.planning/phases/40-observability-health/40-RESEARCH.md
@server/grpc/server.go
@server/grpc/module.go
@server/gateway/gateway.go
@server/gateway/module.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OTEL TracerProvider package</name>
  <files>
    server/otel/doc.go
    server/otel/config.go
    server/otel/provider.go
    server/otel/module.go
    go.mod
  </files>
  <action>
Create the server/otel package:

**doc.go:**
Package documentation explaining OpenTelemetry integration with auto-enable when OTEL endpoint is set.

**config.go:**
```go
type Config struct {
    Endpoint    string  // OTLP endpoint (e.g., "localhost:4317")
    ServiceName string  // Service name for traces (default: "gaz")
    SampleRatio float64 // Root span sampling ratio 0.0-1.0 (default: 0.1)
    Insecure    bool    // Use insecure connection (default: true for dev)
}

func DefaultConfig() Config
```

**provider.go:**
Implement TracerProvider initialization per RESEARCH.md Pattern 2:

```go
func InitTracer(ctx context.Context, cfg Config, logger *slog.Logger) (*sdktrace.TracerProvider, error)
func ShutdownTracer(ctx context.Context, tp *sdktrace.TracerProvider) error
```

Key requirements:
1. If cfg.Endpoint is empty, return nil (OTEL disabled)
2. Create OTLP gRPC exporter with endpoint
3. Create resource with service.name attribute
4. Use ParentBased(TraceIDRatioBased) sampler per CONTEXT.md
5. Set global TracerProvider and TextMapPropagator
6. On exporter creation failure, log warning and return nil (graceful degradation)
7. ShutdownTracer uses 5s timeout for flush

Add dependencies:
```bash
go get go.opentelemetry.io/otel@latest
go get go.opentelemetry.io/otel/sdk/trace@latest
go get go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc@latest
go get go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc@latest
go get go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp@latest
```

**module.go:**
```go
func NewModule(opts ...ModuleOption) di.Module
```

ModuleOptions:
- WithEndpoint(string) - OTLP endpoint
- WithServiceName(string) - service name
- WithSampleRatio(float64) - sampling ratio
- WithInsecure(bool) - insecure connection

The module should:
1. Register *sdktrace.TracerProvider as singleton (may be nil if disabled)
2. TracerProvider implements di.Stopper for shutdown
3. Read OTEL_EXPORTER_OTLP_ENDPOINT env var as fallback

Note: TracerProvider doesn't implement di.Stopper directly. Create a wrapper:
```go
type tracerProviderStopper struct {
    tp *sdktrace.TracerProvider
}

func (t *tracerProviderStopper) OnStop(ctx context.Context) error {
    return ShutdownTracer(ctx, t.tp)
}
```
  </action>
  <verify>
`go build ./server/otel/...` compiles without errors. `go mod tidy` succeeds.
  </verify>
  <done>
OTEL package created with TracerProvider, OTLP exporter, and DI module with graceful degradation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument gRPC server with otelgrpc</name>
  <files>
    server/grpc/server.go
    server/grpc/module.go
  </files>
  <action>
Modify the gRPC server to optionally use OpenTelemetry instrumentation:

**server.go:**
Add otelEnabled field to Server struct. In NewServer:
1. Accept optional `*sdktrace.TracerProvider` parameter (can be nil)
2. If TracerProvider is not nil, add `grpc.StatsHandler(otelgrpc.NewServerHandler())` to server options
3. Filter health check endpoint from tracing per RESEARCH.md Pattern 3:

```go
if tp != nil {
    opts = append(opts, grpc.StatsHandler(otelgrpc.NewServerHandler(
        otelgrpc.WithFilter(func(info *otelgrpc.InterceptorInfo) bool {
            // Skip tracing health checks
            return info.Method != "/grpc.health.v1.Health/Check" &&
                   info.Method != "/grpc.health.v1.Health/Watch"
        }),
    )))
}
```

**module.go:**
Update module to resolve optional TracerProvider:
1. Try di.Resolve[*sdktrace.TracerProvider] - if not found or nil, OTEL is disabled
2. Pass TracerProvider to NewServer

Add new ModuleOption:
- WithOTEL(bool) - explicitly enable/disable OTEL (default: auto-detect from TracerProvider availability)

Update NewServer signature to accept TracerProvider:
```go
func NewServer(cfg Config, logger *slog.Logger, container *di.Container, devMode bool, tp *sdktrace.TracerProvider) *Server
```
  </action>
  <verify>
`go build ./server/grpc/...` compiles. Existing tests pass: `go test ./server/grpc/...`
  </verify>
  <done>
gRPC server instrumented with otelgrpc stats handler when TracerProvider is available. Health checks excluded from tracing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Instrument Gateway with otelhttp</name>
  <files>
    server/gateway/gateway.go
    server/gateway/module.go
  </files>
  <action>
Modify the Gateway to optionally use OpenTelemetry instrumentation:

**gateway.go:**
In OnStart, after building CORS handler:
1. Accept optional `*sdktrace.TracerProvider` in constructor (can be nil)
2. If TracerProvider is not nil, wrap handler with otelhttp per RESEARCH.md Pattern 4:

```go
if g.tp != nil {
    g.handler = otelhttp.NewHandler(g.handler, "gateway",
        otelhttp.WithFilter(func(r *http.Request) bool {
            // Skip health check endpoints
            return r.URL.Path != "/health" && r.URL.Path != "/healthz"
        }),
    )
}
```

Note: Wrap AFTER CORS handler (order: mux -> CORS -> otelhttp).

**module.go:**
Update module to resolve optional TracerProvider:
1. Try di.Resolve[*sdktrace.TracerProvider] - if not found or nil, OTEL is disabled
2. Pass TracerProvider to NewGateway

Update NewGateway signature:
```go
func NewGateway(cfg Config, logger *slog.Logger, container *di.Container, devMode bool, tp *sdktrace.TracerProvider) *Gateway
```
  </action>
  <verify>
`go build ./server/gateway/...` compiles. Existing tests pass: `go test ./server/gateway/...`
  </verify>
  <done>
Gateway instrumented with otelhttp wrapper when TracerProvider is available. Health endpoints excluded from tracing.
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./server/otel/...` succeeds
- [ ] `go build ./server/grpc/...` succeeds
- [ ] `go build ./server/gateway/...` succeeds
- [ ] `go test ./server/grpc/...` passes (existing tests)
- [ ] `go test ./server/gateway/...` passes (existing tests)
- [ ] `make lint` passes (may need depguard updates for OTEL packages)
- [ ] TracerProvider gracefully handles missing collector (logs warning, continues)
</verification>

<success_criteria>
OpenTelemetry infrastructure in place with TracerProvider, OTLP export, and instrumentation of gRPC server and Gateway. Traces propagate across HTTP -> gRPC boundary via W3C headers.
</success_criteria>

<output>
After completion, create `.planning/phases/40-observability-health/40-02-SUMMARY.md`
</output>
