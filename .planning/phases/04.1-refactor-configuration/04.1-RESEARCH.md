# Phase 04.1: Refactor configuration - Research

**Researched:** 2026-01-26
**Domain:** Configuration Management / Software Architecture
**Confidence:** HIGH

## Summary

The current configuration system in `gaz`, while functional, exhibits tight coupling between the core `App` struct and the `spf13/viper` library. The `App` struct currently acts as a "God struct," managing lifecycle, dependency injection, and configuration loading. This violates the Single Responsibility Principle and makes the `App` difficult to test or extend.

This research identifies specific refactorings to decouple configuration logic into a dedicated `ConfigManager` (or similar abstraction), implement the Functional Options pattern for configuration settings, and properly encapsulate complex logic like environment variable binding.

**Primary recommendation:** Extract all configuration logic into a `ConfigManager` struct, decoupling `App` from `viper`, and use Functional Options for configuration.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `spf13/viper` | v1.21.0 | Configuration loading | Locked by Phase 4 decision. Industry standard for Go. |
| `spf13/pflag` | v1.0.10 | POSIX flag parsing | Standard dependency of Cobra/Viper. |

## Architecture Patterns

### 1. Dedicated Config Manager
Move `loadConfig`, `bindStructEnv`, and `configHooks` logic out of `App` and into a new struct.

**Proposed Structure:**
```go
// config_manager.go
package gaz

type ConfigManager struct {
    v      *viper.Viper
    target any
    opts   ConfigOptions
}

func NewConfigManager(target any, opts ...ConfigOption) *ConfigManager {
    // ...
}

func (cm *ConfigManager) Load() error {
    // ... logic from App.loadConfig ...
}

func (cm *ConfigManager) BindFlags(fs *pflag.FlagSet) error {
    return cm.v.BindPFlags(fs)
}
```

### 2. Functional Options
Replace `ConfigOptions` struct with Functional Options pattern for better extensibility and readability.

**Example:**
```go
type ConfigOption func(*ConfigOptions)

func WithName(name string) ConfigOption {
    return func(o *ConfigOptions) {
        o.Name = name
    }
}

// Usage
app.WithConfig(&cfg, gaz.WithName("app"), gaz.WithEnvPrefix("GAZ"))
```

### 3. Encapsulation of Bindings
Hide the complexity of `bindStructEnv` (reflection-based environment binding) within the `ConfigManager`. The `App` should not need to know about `mapstructure` tags or recursive reflection.

## Refactoring Plan (Refactorings)

### 1. Extract `ConfigManager`
**Problem:** `App` directly imports `viper` and manages `viper.Viper` instance.
**Solution:** Create `ConfigManager` which wraps `viper`. `App` holds `*ConfigManager`.

### 2. Isolate Flag Binding
**Problem:** `App.configHooks` exposes `*viper.Viper` in its function signature.
**Solution:** `ConfigManager` exposes `BindFlags(*pflag.FlagSet)`. `App` delegates to this.
**Impact:** `gaz.WithCobra` will call `app.Config().BindFlags(cmd.Flags())` instead of registering a raw hook.

### 3. Simplify `App` API
**Problem:** `WithConfig` takes a struct `ConfigOptions`.
**Solution:** Change `WithConfig` to accept `...ConfigOption`. This aligns with `New(opts ...Option)`.

## Common Pitfalls

### 1. Viper Global State
**Risk:** Using `viper.Get` or `viper.Set` (global) instead of the instance methods.
**Prevention:** Ensure `ConfigManager` uses `viper.New()` and only methods on that instance. (Current code is good, ensure refactor maintains this).

### 2. Flag Binding Timing
**Risk:** Binding flags *after* reading config file but *before* access.
**Constraint:** `BindPFlags` must be called before `Unmarshal` if we want flags to override file/env in the final struct.
**Verification:** Ensure `WithCobra` hook runs before `ConfigManager.Load()`.

### 3. Environment Variable Visibility
**Risk:** `Unmarshal` not seeing env vars because keys are missing in config file.
**Solution:** Keep `bindStructEnv` logic. It explicitly binds env vars for every struct field, ensuring `Unmarshal` picks them up even if the file is empty.

## Code Examples

### Refactored App.WithConfig
```go
func (a *App) WithConfig(target any, opts ...ConfigOption) *App {
    // Initialize ConfigManager
    cm := NewConfigManager(target, opts...)
    a.configManager = cm
    
    // Register target as singleton
    a.ProvideInstance(target)
    
    return a
}
```

### Refactored WithCobra Hook
```go
// In cobra.go
cmd.PersistentPreRunE = func(c *cobra.Command, args []string) error {
    // ...
    // Bind flags
    if a.configManager != nil {
        if err := a.configManager.BindFlags(c.Flags()); err != nil {
            return err
        }
    }
    // ...
    return a.Build()
}
```

## State of the Art

| Old Approach (Phase 4) | New Approach (Phase 4.1) | Benefit |
|------------------------|--------------------------|---------|
| `App` manages `viper` | `ConfigManager` manages `viper` | Decoupling, SRP |
| `ConfigOptions` struct | `ConfigOption` functions | Extensibility |
| `func(*viper.Viper)` hooks | `BindFlags(*pflag.FlagSet)` | Type safety, encapsulation |

## Sources

### Primary (HIGH confidence)
- **Code Analysis:** Analyzed `app.go`, `config.go`, `cobra.go` in current codebase.
- **Phase 4 Decisions:** "Use spf13/viper in instance mode" (Locked).

### Secondary (MEDIUM confidence)
- **Context7:** Verified Viper's `Unmarshal` behavior regarding environment variables (requires explicit binding for missing keys).

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH (Locked by previous phase)
- Architecture: HIGH (Standard Go patterns)
- Pitfalls: HIGH (Known Viper behaviors)

**Research date:** 2026-01-26
**Valid until:** 2026-06-26
