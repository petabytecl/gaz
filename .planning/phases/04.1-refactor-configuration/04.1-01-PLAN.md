---
phase: 04.1-refactor-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config_manager.go
  - options.go
  - config_manager_test.go
autonomous: true
must_haves:
  truths:
    - "ConfigManager struct exists and wraps viper instance"
    - "Functional options pattern replaces ConfigOptions struct"
    - "Environment binding logic (bindStructEnv) is encapsulated in ConfigManager"
  artifacts:
    - path: "config_manager.go"
      provides: "ConfigManager struct and methods"
    - path: "options.go"
      provides: "ConfigOption type and With* functions"
  key_links:
    - from: "ConfigManager.Load"
      to: "viper.ReadInConfig"
      via: "wrapper method"
---

<objective>
Extract configuration logic into a dedicated `ConfigManager` and implement Functional Options pattern.

Purpose: Decouple configuration complexity from the main App struct and enable extensible configuration options.
Output: New `ConfigManager` and `options.go` files with unit tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-config-system/04-01-SUMMARY.md
@app.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Functional Options</name>
  <files>options.go</files>
  <action>
    Create `options.go` in the root package.
    Define `ConfigOption` as `func(*ConfigManager)`.
    Implement standard options:
    - `WithName(name string)`
    - `WithEnvPrefix(prefix string)`
    - `WithSearchPaths(paths ...string)`
    - `WithDefaults(defaults map[string]any)`
    
    Note: These replace the `ConfigOptions` struct currently in `types.go` (or implicit in `app.go`).
  </action>
  <verify>go build options.go</verify>
  <done>ConfigOption type and helper functions exist</done>
</task>

<task type="auto">
  <name>Task 2: Create ConfigManager</name>
  <files>config_manager.go</files>
  <action>
    Create `config_manager.go`.
    Define `ConfigManager` struct holding `*viper.Viper` and target struct.
    Implement `NewConfigManager(target any, opts ...ConfigOption)`.
    
    Migrate logic from `app.go` (refer to Phase 4 implementation):
    - `Load() error`: Handles reading config, binding envs, unmarshalling.
    - `BindFlags(fs *pflag.FlagSet) error`: Wraps `viper.BindPFlags`.
    - `bindStructEnv`: Move the recursive reflection logic here as a private method.
    
    Ensure `viper` instance is local (`viper.New()`), not global.
  </action>
  <verify>go build config_manager.go</verify>
  <done>ConfigManager encapsulates all config loading and binding logic</done>
</task>

<task type="auto">
  <name>Task 3: Unit Test ConfigManager</name>
  <files>config_manager_test.go</files>
  <action>
    Create `config_manager_test.go`.
    Test `ConfigManager` in isolation:
    1. Test `Load()` with defaults.
    2. Test `Load()` with environment variables (mocking env).
    3. Test `BindFlags()` (using pflag).
    
    Ensure it works correctly without the `App` struct.
  </action>
  <verify>go test -v config_manager_test.go config_manager.go options.go</verify>
  <done>Tests pass demonstrating functional ConfigManager</done>
</task>

</tasks>

<verification>
Run the new tests to ensure the isolated logic works as expected.
</verification>

<success_criteria>
- [ ] ConfigManager struct exists
- [ ] Functional options are implemented
- [ ] Reflection-based env binding works within ConfigManager
- [ ] Unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-refactor-configuration/04.1-01-SUMMARY.md`
</output>
