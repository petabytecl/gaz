---
phase: 07-validation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - validation.go
  - config_manager.go
autonomous: true

must_haves:
  truths:
    - "validate tags on config struct fields are enforced at load time"
    - "ConfigManager.Load() returns error if validation fails"
    - "Error messages show field paths using config keys (not Go field names)"
    - "Nested struct validation works recursively"
  artifacts:
    - path: "validation.go"
      provides: "Singleton validator, formatValidationErrors, humanizeTag"
      exports: ["validateConfigTags"]
      contains: "validator.New"
    - path: "config_manager.go"
      provides: "Validation integration in Load()"
      contains: "validateConfigTags"
  key_links:
    - from: "config_manager.go"
      to: "validation.go"
      via: "validateConfigTags call in Load()"
      pattern: "validateConfigTags\\(cm\\.target\\)"
    - from: "validation.go"
      to: "go-playground/validator"
      via: "singleton validator instance"
      pattern: "validator\\.New"
---

<objective>
Create the validation engine core: add go-playground/validator dependency, create validation.go with singleton validator and error formatting, and integrate into ConfigManager.Load().

Purpose: Enable struct tag-based validation (`validate:"required"`) that prevents application startup with clear, actionable error messages.

Output: Working validation that enforces tags on config load, returning formatted errors when validation fails.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-validation-engine/07-RESEARCH.md

@config_manager.go
@config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validator dependency and create validation.go</name>
  <files>go.mod, go.sum, validation.go</files>
  <action>
1. Add go-playground/validator v10 dependency:
   ```bash
   go get github.com/go-playground/validator/v10
   ```

2. Create `validation.go` with:

   a) Package-level singleton validator with `WithRequiredStructEnabled()`:
   ```go
   var validate = validator.New(validator.WithRequiredStructEnabled())
   ```

   b) In `init()`, register TagNameFunc to extract field names from `mapstructure` tags (falling back to `json` then Go field name):
   ```go
   validate.RegisterTagNameFunc(func(fld reflect.StructField) string {
       name := strings.SplitN(fld.Tag.Get("mapstructure"), ",", 2)[0]
       if name != "-" && name != "" {
           return name
       }
       name = strings.SplitN(fld.Tag.Get("json"), ",", 2)[0]
       if name != "-" && name != "" {
           return name
       }
       return fld.Name
   })
   ```

   c) `validateConfigTags(cfg any) error` function that:
   - Calls `validate.Struct(cfg)`
   - If no error, return nil
   - If `validator.InvalidValidationError`, return wrapped error
   - If `validator.ValidationErrors`, format and return as `ErrConfigValidation`

   d) `formatValidationErrors(errs validator.ValidationErrors) error` that:
   - Iterates all errors
   - Builds message: `{namespace}: {humanized_message} (validate:"{tag}")`
   - Joins with newlines
   - Returns as wrapped `ErrConfigValidation`

   e) `humanizeTag(tag, param string) string` helper with cases:
   - "required" → "required field cannot be empty"
   - "min" → "must be at least {param}"
   - "max" → "must be at most {param}"
   - "oneof" → "must be one of: {param}"
   - "required_if" → "required when {param}"
   - default → "failed {tag} validation"

3. Add `ErrConfigValidation` sentinel error to errors.go if it doesn't exist, or use `fmt.Errorf` with clear prefix like "config validation failed:"

4. Run `go mod tidy` to clean up dependencies.
  </action>
  <verify>
- `go build ./...` succeeds
- `grep -r "validator/v10" go.mod` shows dependency added
- `grep "validateConfigTags" validation.go` shows function exists
- `grep "humanizeTag" validation.go` shows helper function exists
  </verify>
  <done>
- validation.go exists with singleton validator, validateConfigTags, formatValidationErrors, humanizeTag
- go-playground/validator v10 is in go.mod
- Code compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation into ConfigManager.Load()</name>
  <files>config_manager.go</files>
  <action>
1. In `ConfigManager.Load()`, add call to `validateConfigTags` AFTER the `Defaulter` check and BEFORE the `Validator` check:

   Current flow (lines 86-94):
   ```go
   if d, ok := cm.target.(Defaulter); ok {
       d.Default()
   }

   if val, ok := cm.target.(Validator); ok {
       if err := val.Validate(); err != nil {
           return fmt.Errorf("config validation failed: %w", err)
       }
   }
   ```

   New flow:
   ```go
   if d, ok := cm.target.(Defaulter); ok {
       d.Default()
   }

   // Validate struct tags (required, min, max, etc.)
   if err := validateConfigTags(cm.target); err != nil {
       return err  // Already formatted with "config validation failed:" prefix
   }

   if val, ok := cm.target.(Validator); ok {
       if err := val.Validate(); err != nil {
           return fmt.Errorf("config validation failed: %w", err)
       }
   }
   ```

2. Ensure the error message from `validateConfigTags` is clear and actionable. The function should return error with format:
   ```
   config validation failed:
   database.host: required field cannot be empty (validate:"required")
   database.port: must be at least 1 (validate:"min")
   ```

3. Run existing tests to ensure no regressions.
  </action>
  <verify>
- `go test ./... -count=1` passes (existing tests still work)
- `grep -A5 "Default()" config_manager.go` shows validateConfigTags call added after Default
- Manual verification: existing tests in config_test.go still pass
  </verify>
  <done>
- ConfigManager.Load() calls validateConfigTags after Default() and before Validate()
- Existing tests pass (no regressions)
- Validation errors return formatted messages with field paths
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. All existing tests pass:
   ```bash
   go test ./... -count=1
   ```

2. Build succeeds:
   ```bash
   go build ./...
   ```

3. Validation integration visible in code:
   ```bash
   grep -n "validateConfigTags" config_manager.go validation.go
   ```
</verification>

<success_criteria>
1. go-playground/validator v10 added as dependency
2. validation.go created with validateConfigTags, formatValidationErrors, humanizeTag
3. ConfigManager.Load() calls validateConfigTags after defaults are applied
4. Error messages use config keys (mapstructure tags), not Go field names
5. All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-validation-engine/07-01-SUMMARY.md`
</output>
