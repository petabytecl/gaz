---
phase: 01-core-di-container
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - registration.go
  - container.go
  - registration_test.go
autonomous: true

must_haves:
  truths:
    - "Developer registers with gaz.For[T](c).Provider(fn) fluent chain"
    - "Duplicate registration returns ErrDuplicate"
    - "Replace() allows intentional override"
    - "Named() creates separate registration from default"
  artifacts:
    - path: "registration.go"
      provides: "Fluent registration builder"
      exports: ["For", "RegistrationBuilder"]
    - path: "registration_test.go"
      provides: "Registration behavior tests"
      contains: "TestFor_Provider"
  key_links:
    - from: "registration.go"
      to: "container.go"
      via: "register method"
      pattern: "c\\.register"
    - from: "registration.go"
      to: "service.go"
      via: "creates service wrappers"
      pattern: "newLazySingleton|newTransient|newEagerSingleton"
---

<objective>
Create the fluent registration API with For[T]() and RegistrationBuilder[T].

Purpose: This is the primary developer-facing registration interface. The fluent builder pattern guides developers through options (Named, Transient, Eager, Replace) and ends with Provider() or Instance().
Output: registration.go with the fluent API, integration with Container, and tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-core-di-container/01-CONTEXT.md
@.planning/phases/01-core-di-container/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create registration.go with fluent builder</name>
  <files>registration.go</files>
  <action>
Create registration.go with the fluent registration API:

1. **For[T any](c *Container) *RegistrationBuilder[T]** - entry point:
```go
func For[T any](c *Container) *RegistrationBuilder[T] {
    return &RegistrationBuilder[T]{
        container:    c,
        name:         TypeName[T](),  // Default name from type
        typeName:     TypeName[T](),
        scope:        scopeSingleton,
        lazy:         true,
        allowReplace: false,
    }
}
```

2. **RegistrationBuilder[T]** struct:
```go
type RegistrationBuilder[T any] struct {
    container    *Container
    name         string       // Registration key (default: type name)
    typeName     string       // Type name for errors
    scope        serviceScope // singleton or transient
    lazy         bool         // lazy (default) or eager
    allowReplace bool         // allow overwriting existing
}

type serviceScope int
const (
    scopeSingleton serviceScope = iota
    scopeTransient
)
```

3. **Builder methods** (all return `*RegistrationBuilder[T]` for chaining):
- `Named(name string)` - set custom registration name
- `Transient()` - set scope to transient (new instance per resolve)
- `Eager()` - set lazy to false (instantiate at Build)
- `Replace()` - set allowReplace to true

4. **Terminal methods** (end the chain, return error):
```go
func (b *RegistrationBuilder[T]) Provider(fn func(*Container) (T, error)) error
func (b *RegistrationBuilder[T]) Instance(val T) error
```

Provider() implementation:
- Check if name already exists in container (unless allowReplace)
- If exists and !allowReplace, return ErrDuplicate
- Create appropriate service wrapper based on scope/lazy:
  - transient scope → newTransient
  - singleton + eager → newEagerSingleton
  - singleton + lazy → newLazySingleton
- Call container.register(name, wrapper)

Instance() implementation:
- Same duplicate check
- Create newInstanceService with the value
- Call container.register(name, wrapper)

5. **Support simple providers** (no error return):
Add a second Provider signature that accepts `func(*Container) T`:
```go
func (b *RegistrationBuilder[T]) ProviderFunc(fn func(*Container) T) error {
    return b.Provider(func(c *Container) (T, error) {
        return fn(c), nil
    })
}
```
  </action>
  <verify>`go build ./...` compiles without errors</verify>
  <done>For[T]() returns builder with Named, Transient, Eager, Replace, Provider, Instance methods</done>
</task>

<task type="auto">
  <name>Task 2: Add register method to Container and create tests</name>
  <files>container.go, registration_test.go</files>
  <action>
**Update container.go:**

Add internal register method:
```go
// register adds a service to the container. Internal use only.
func (c *Container) register(name string, svc serviceWrapper) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.services[name] = svc
}

// hasService checks if a service is registered. Internal use only.
func (c *Container) hasService(name string) bool {
    c.mu.RLock()
    defer c.mu.RUnlock()
    _, ok := c.services[name]
    return ok
}
```

**Create registration_test.go:**

1. **TestFor_Provider_RegistersService**:
   - Create container
   - Register with `For[*testService](c).Provider(...)`
   - Assert no error returned
   - Assert container has the service (via internal check or later resolve)

2. **TestFor_Instance_RegistersValue**:
   - Create container
   - Register with `For[*Config](c).Instance(&Config{...})`
   - Assert no error

3. **TestFor_Duplicate_ReturnsError**:
   - Register a service
   - Try to register same type again
   - Assert error is ErrDuplicate

4. **TestFor_Replace_AllowsOverwrite**:
   - Register a service
   - Register same type with `.Replace()`
   - Assert no error

5. **TestFor_Named_CreatesSeparateEntry**:
   - Register `For[*DB](c).Named("primary").Provider(...)`
   - Register `For[*DB](c).Named("replica").Provider(...)`
   - Assert both succeed (different names)

6. **TestFor_Transient_CreatesTransientService**:
   - Register with `.Transient()`
   - (Verification of transient behavior tested in resolution tests)

7. **TestFor_Eager_CreatesEagerService**:
   - Register with `.Eager()`
   - (Verification of eager behavior tested in Build tests)

Use test helpers like:
```go
type testService struct{ id int }
type testConfig struct{ value string }
```
  </action>
  <verify>`go test -v ./...` passes all registration tests</verify>
  <done>Registration API complete with duplicate detection, replace support, and naming</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test -v ./...` passes all tests
3. `For[T](c).Provider(fn)` registers lazy singleton by default
4. Duplicate registration returns ErrDuplicate
5. `.Replace()` allows override
6. `.Named()` creates distinct registration
</verification>

<success_criteria>
- [ ] For[T]() exported and returns RegistrationBuilder[T]
- [ ] Named(), Transient(), Eager(), Replace() chainable methods work
- [ ] Provider() and Instance() terminal methods return error
- [ ] Duplicate registration returns ErrDuplicate
- [ ] Replace() allows intentional override
- [ ] Named services with same type don't conflict
- [ ] All registration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-di-container/01-03-SUMMARY.md`
</output>
