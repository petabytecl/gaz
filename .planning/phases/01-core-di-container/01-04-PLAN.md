---
phase: 01-core-di-container
plan: 04
type: execute
wave: 4
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - resolution.go
  - options.go
  - container.go
  - resolution_test.go
autonomous: true

must_haves:
  truths:
    - "Developer resolves with gaz.Resolve[T](c) returning (T, error)"
    - "Missing service returns ErrNotFound"
    - "Circular dependency returns ErrCycle with full chain"
    - "Named resolution works with gaz.Resolve[T](c, gaz.Named(name))"
    - "Provider errors propagate with dependency chain context"
  artifacts:
    - path: "resolution.go"
      provides: "Resolve function and cycle detection"
      exports: ["Resolve"]
    - path: "options.go"
      provides: "Resolution options like Named"
      exports: ["Named", "ResolveOption"]
    - path: "resolution_test.go"
      provides: "Resolution behavior tests"
      contains: "TestResolve_CycleDetection"
  key_links:
    - from: "resolution.go"
      to: "service.go"
      via: "calls getInstance"
      pattern: "getInstance\\(c, chain\\)"
    - from: "resolution.go"
      to: "errors.go"
      via: "returns sentinel errors"
      pattern: "ErrNotFound|ErrCycle"
---

<objective>
Create the resolution API with Resolve[T]() and implement circular dependency detection.

Purpose: Resolution is the other half of the DI contract. Developers resolve dependencies by type or name. Cycle detection prevents infinite loops and provides clear error messages showing the dependency chain.
Output: resolution.go with Resolve[T](), options.go with Named(), cycle detection, and tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-core-di-container/01-CONTEXT.md
@.planning/phases/01-core-di-container/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create options.go with resolution options</name>
  <files>options.go</files>
  <action>
Create options.go with the functional options pattern for resolution:

```go
// ResolveOption modifies resolution behavior.
type ResolveOption func(*resolveOptions)

// resolveOptions holds resolution configuration.
type resolveOptions struct {
    name string // Custom name to resolve (empty = use type name)
}

// Named resolves a service by its registered name instead of type.
func Named(name string) ResolveOption {
    return func(o *resolveOptions) {
        o.name = name
    }
}

// applyOptions creates resolveOptions from variadic options.
func applyOptions(opts []ResolveOption) *resolveOptions {
    o := &resolveOptions{}
    for _, opt := range opts {
        opt(o)
    }
    return o
}
```

This pattern allows future options without breaking the API.
  </action>
  <verify>`go build ./...` compiles without errors</verify>
  <done>Named() option exported, ResolveOption type defined</done>
</task>

<task type="auto">
  <name>Task 2: Create resolution.go with Resolve[T]() and cycle detection</name>
  <files>resolution.go, container.go</files>
  <action>
**Create resolution.go:**

1. **Resolve[T any](c *Container, opts ...ResolveOption) (T, error)** - main entry point:
```go
func Resolve[T any](c *Container, opts ...ResolveOption) (T, error) {
    options := applyOptions(opts)
    
    name := options.name
    if name == "" {
        name = TypeName[T]()
    }
    
    // Start resolution with empty chain
    instance, err := c.resolveByName(name, nil)
    if err != nil {
        var zero T
        return zero, err
    }
    
    // Type assertion
    result, ok := instance.(T)
    if !ok {
        var zero T
        return zero, fmt.Errorf("%w: expected %s, got %T", ErrTypeMismatch, TypeName[T](), instance)
    }
    
    return result, nil
}
```

**Update container.go with resolveByName:**

```go
// resolveByName resolves a service by name, tracking the chain for cycle detection.
// This is the internal resolution method called by Resolve[T] and struct injection.
func (c *Container) resolveByName(name string, chain []string) (any, error) {
    // Cycle detection
    for _, seen := range chain {
        if seen == name {
            cycle := append(chain, name)
            return nil, fmt.Errorf("%w: %s", ErrCycle, strings.Join(cycle, " -> "))
        }
    }
    
    // Look up service
    c.mu.RLock()
    svc, ok := c.services[name]
    c.mu.RUnlock()
    
    if !ok {
        return nil, fmt.Errorf("%w: %s", ErrNotFound, name)
    }
    
    wrapper := svc.(serviceWrapper)
    
    // Add current service to chain before getting instance
    newChain := append(chain, name)
    
    // Get instance (may resolve dependencies via provider)
    instance, err := wrapper.getInstance(c, newChain)
    if err != nil {
        // Wrap error with resolution context
        if len(chain) > 0 {
            return nil, fmt.Errorf("resolving %s -> %s: %w", 
                strings.Join(chain, " -> "), name, err)
        }
        return nil, fmt.Errorf("resolving %s: %w", name, err)
    }
    
    return instance, nil
}
```

Add `strings` and `fmt` imports to container.go.

**Key behaviors:**
- Chain passed to getInstance so providers can resolve dependencies
- Cycle detected by checking if name already in chain
- Error messages include full dependency chain
- ErrNotFound for missing services
- ErrCycle for circular dependencies
  </action>
  <verify>`go build ./...` compiles without errors</verify>
  <done>Resolve[T]() with cycle detection and chain-aware error messages</done>
</task>

<task type="auto">
  <name>Task 3: Create resolution_test.go with comprehensive tests</name>
  <files>resolution_test.go</files>
  <action>
Create resolution_test.go with tests covering all resolution behaviors:

1. **TestResolve_BasicResolution**:
   - Register a simple service
   - Resolve it
   - Assert correct instance returned

2. **TestResolve_NotFound**:
   - Try to resolve unregistered type
   - Assert error is ErrNotFound

3. **TestResolve_Named**:
   - Register two services with same type, different names
   - Resolve each by name
   - Assert different instances

4. **TestResolve_CycleDetection**:
   - Register A that depends on B
   - Register B that depends on A
   - Resolve A
   - Assert error is ErrCycle
   - Assert error message contains "A -> B -> A" chain

```go
func TestResolve_CycleDetection(t *testing.T) {
    c := New()
    
    // A depends on B
    For[*ServiceA](c).Provider(func(c *Container) (*ServiceA, error) {
        b, err := Resolve[*ServiceB](c)
        if err != nil {
            return nil, err
        }
        return &ServiceA{b: b}, nil
    })
    
    // B depends on A (creates cycle)
    For[*ServiceB](c).Provider(func(c *Container) (*ServiceB, error) {
        a, err := Resolve[*ServiceA](c)
        if err != nil {
            return nil, err
        }
        return &ServiceB{a: a}, nil
    })
    
    _, err := Resolve[*ServiceA](c)
    if !errors.Is(err, ErrCycle) {
        t.Fatalf("expected ErrCycle, got: %v", err)
    }
    
    // Verify chain is in error message
    if !strings.Contains(err.Error(), "->") {
        t.Errorf("error should contain dependency chain: %v", err)
    }
}
```

5. **TestResolve_ProviderError_Propagates**:
   - Register service with provider that returns error
   - Resolve it
   - Assert error is wrapped with context

6. **TestResolve_DependencyChain**:
   - Register A that depends on B that depends on C
   - Resolve A
   - Assert all three instantiated correctly

7. **TestResolve_Transient_NewInstanceEachTime**:
   - Register transient service
   - Resolve twice
   - Assert different instances (pointer comparison)

8. **TestResolve_Singleton_SameInstance**:
   - Register singleton service
   - Resolve twice
   - Assert same instance (pointer comparison)
  </action>
  <verify>`go test -v ./...` passes all resolution tests</verify>
  <done>Resolution tests pass including cycle detection and error propagation</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test -v ./...` passes all tests
3. `Resolve[T](c)` returns (T, error)
4. Missing service returns ErrNotFound with type name
5. Circular dependency returns ErrCycle with full chain
6. Provider errors wrapped with dependency context
7. Named resolution works with `gaz.Named("name")`
</verification>

<success_criteria>
- [ ] Resolve[T]() exported and returns (T, error)
- [ ] Named() option works for named resolution
- [ ] ErrNotFound returned for missing services
- [ ] ErrCycle returned for circular dependencies with chain
- [ ] Provider errors propagate with context
- [ ] Transient services return new instances
- [ ] Singleton services return same instance
- [ ] All resolution tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-di-container/01-04-SUMMARY.md`
</output>
