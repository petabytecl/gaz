---
phase: 01-core-di-container
plan: 06
type: execute
wave: 6
depends_on: ["01-01", "01-02", "01-03", "01-04", "01-05"]
files_modified:
  - container.go
  - container_test.go
autonomous: true

must_haves:
  truths:
    - "Build() instantiates all eager services"
    - "Build() returns error if any eager service fails"
    - "Resolve after Build returns cached eager services"
    - "All 9 DI requirements are satisfied"
  artifacts:
    - path: "container.go"
      provides: "Build method for eager instantiation"
      exports: ["Build"]
    - path: "container_test.go"
      provides: "Integration tests covering all requirements"
      contains: "TestIntegration_AllRequirements"
  key_links:
    - from: "container.go"
      to: "service.go"
      via: "iterates eager services"
      pattern: "isEager\\(\\)"
---

<objective>
Add Build() for eager service instantiation and create comprehensive integration tests.

Purpose: Build() provides a clear startup phase where eager services are instantiated. This is the final piece of the container API, enabling deterministic startup. Integration tests verify all 9 DI requirements are met.
Output: Build() method in container.go, container_test.go with full test coverage.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-di-container/01-CONTEXT.md
@.planning/phases/01-core-di-container/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Build() method to Container</name>
  <files>container.go</files>
  <action>
Add the Build() method to Container for eager service instantiation:

```go
// Build instantiates all eager services and validates the container.
// Call this after all registrations and before any resolves.
// Returns an error if any eager service fails to instantiate.
func (c *Container) Build() error {
    c.mu.Lock()
    if c.built {
        c.mu.Unlock()
        return nil // Already built, idempotent
    }
    c.mu.Unlock()
    
    // Collect eager services
    var eagerServices []serviceWrapper
    c.mu.RLock()
    for _, svc := range c.services {
        wrapper := svc.(serviceWrapper)
        if wrapper.isEager() {
            eagerServices = append(eagerServices, wrapper)
        }
    }
    c.mu.RUnlock()
    
    // Instantiate each eager service
    for _, svc := range eagerServices {
        _, err := svc.getInstance(c, nil)
        if err != nil {
            return fmt.Errorf("building eager service %s: %w", svc.name(), err)
        }
    }
    
    c.mu.Lock()
    c.built = true
    c.mu.Unlock()
    
    return nil
}
```

**Key behaviors:**
- Idempotent: calling Build() twice is safe
- Instantiates ALL eager services (not just one)
- First error stops the build and returns
- Error includes service name for debugging
- Sets `built` flag (could be used for validation later)

Note: Build() doesn't prevent resolving before build - that's a design choice. Lazy services work without Build(), only eager services require it.
  </action>
  <verify>`go build ./...` compiles; Build() can be called on container</verify>
  <done>Build() method instantiates eager services and handles errors</done>
</task>

<task type="auto">
  <name>Task 2: Create container_test.go with integration tests</name>
  <files>container_test.go</files>
  <action>
Create container_test.go with comprehensive tests covering all 9 DI requirements:

**DI-01: Register with generics**
```go
func TestDI01_RegisterWithGenerics(t *testing.T) {
    c := New()
    err := For[*Database](c).Provider(func(c *Container) (*Database, error) {
        return &Database{}, nil
    })
    if err != nil {
        t.Fatalf("registration failed: %v", err)
    }
}
```

**DI-02: Lazy instantiation by default**
```go
func TestDI02_LazyInstantiation(t *testing.T) {
    c := New()
    instantiated := false
    For[*Service](c).Provider(func(c *Container) (*Service, error) {
        instantiated = true
        return &Service{}, nil
    })
    
    if instantiated {
        t.Error("should not instantiate before resolve")
    }
    
    Resolve[*Service](c)
    if !instantiated {
        t.Error("should instantiate on first resolve")
    }
}
```

**DI-03: Error propagation with chain context**
```go
func TestDI03_ErrorPropagation(t *testing.T) {
    c := New()
    For[*DB](c).Provider(func(c *Container) (*DB, error) {
        return nil, errors.New("connection failed")
    })
    For[*Repo](c).Provider(func(c *Container) (*Repo, error) {
        db, err := Resolve[*DB](c)
        if err != nil {
            return nil, err
        }
        return &Repo{db: db}, nil
    })
    
    _, err := Resolve[*Repo](c)
    if err == nil {
        t.Fatal("expected error")
    }
    // Error should contain chain context
    if !strings.Contains(err.Error(), "Repo") || !strings.Contains(err.Error(), "DB") {
        t.Errorf("error should contain dependency context: %v", err)
    }
}
```

**DI-04: Named implementations**
```go
func TestDI04_NamedImplementations(t *testing.T) {
    c := New()
    For[*sql.DB](c).Named("primary").Instance(&sql.DB{})
    For[*sql.DB](c).Named("replica").Instance(&sql.DB{})
    
    primary, _ := Resolve[*sql.DB](c, Named("primary"))
    replica, _ := Resolve[*sql.DB](c, Named("replica"))
    
    if primary == replica {
        t.Error("should be different instances")
    }
}
```

**DI-05: Struct field injection**
```go
func TestDI05_StructFieldInjection(t *testing.T) {
    type Handler struct {
        DB *Database `gaz:"inject"`
    }
    
    c := New()
    For[*Database](c).Instance(&Database{})
    For[*Handler](c).Provider(func(c *Container) (*Handler, error) {
        return &Handler{}, nil
    })
    
    h, err := Resolve[*Handler](c)
    if err != nil {
        t.Fatal(err)
    }
    if h.DB == nil {
        t.Error("DB should be injected")
    }
}
```

**DI-06: Override for testing**
```go
func TestDI06_Override(t *testing.T) {
    c := New()
    For[*Service](c).Instance(&Service{name: "original"})
    For[*Service](c).Replace().Instance(&Service{name: "mock"})
    
    s, _ := Resolve[*Service](c)
    if s.name != "mock" {
        t.Error("should be mock service")
    }
}
```

**DI-07: Transient services**
```go
func TestDI07_TransientServices(t *testing.T) {
    c := New()
    counter := 0
    For[*Request](c).Transient().Provider(func(c *Container) (*Request, error) {
        counter++
        return &Request{id: counter}, nil
    })
    
    r1, _ := Resolve[*Request](c)
    r2, _ := Resolve[*Request](c)
    
    if r1.id == r2.id {
        t.Error("should be different instances")
    }
}
```

**DI-08: Eager services**
```go
func TestDI08_EagerServices(t *testing.T) {
    c := New()
    instantiated := false
    For[*Pool](c).Eager().Provider(func(c *Container) (*Pool, error) {
        instantiated = true
        return &Pool{}, nil
    })
    
    if instantiated {
        t.Error("should not instantiate before Build")
    }
    
    c.Build()
    
    if !instantiated {
        t.Error("should instantiate at Build")
    }
}
```

**DI-09: Circular dependency detection**
```go
func TestDI09_CycleDetection(t *testing.T) {
    c := New()
    For[*A](c).Provider(func(c *Container) (*A, error) {
        b, _ := Resolve[*B](c)
        return &A{b: b}, nil
    })
    For[*B](c).Provider(func(c *Container) (*B, error) {
        a, _ := Resolve[*A](c)
        return &B{a: a}, nil
    })
    
    _, err := Resolve[*A](c)
    if !errors.Is(err, ErrCycle) {
        t.Errorf("expected ErrCycle, got: %v", err)
    }
}
```

**Build error handling test**
```go
func TestBuild_EagerError_PropagatesWithContext(t *testing.T) {
    c := New()
    For[*FailingService](c).Eager().Provider(func(c *Container) (*FailingService, error) {
        return nil, errors.New("startup failed")
    })
    
    err := c.Build()
    if err == nil {
        t.Fatal("expected error")
    }
    if !strings.Contains(err.Error(), "FailingService") {
        t.Errorf("error should contain service name: %v", err)
    }
}
```

Create test helper types at the top of the file.
  </action>
  <verify>`go test -v ./...` passes all tests; `go test -cover` shows good coverage</verify>
  <done>All 9 DI requirements verified with tests, Build() works correctly</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test -v ./...` passes all tests
3. `go test -cover ./...` shows coverage for all main code paths
4. Build() instantiates eager services
5. Build() returns error with context if eager service fails
6. All 9 DI requirements demonstrated working
</verification>

<success_criteria>
- [ ] Build() exported and instantiates eager services
- [ ] Build() error includes service name
- [ ] Build() is idempotent
- [ ] DI-01 through DI-09 all have passing tests
- [ ] Integration test demonstrates real-world usage pattern
- [ ] Test coverage is reasonable (>70%)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-di-container/01-06-SUMMARY.md`
</output>
