---
phase: 01-core-di-container
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - service.go
  - service_test.go
autonomous: true

must_haves:
  truths:
    - "Lazy singletons instantiate only on first getInstance call"
    - "Transient services return new instance on each getInstance call"
    - "Eager services can be marked for Build() instantiation"
    - "Service wrappers track type name for error messages"
  artifacts:
    - path: "service.go"
      provides: "Internal service wrapper interface and implementations"
      exports: []
      contains: "type serviceWrapper interface"
    - path: "service_test.go"
      provides: "Tests for service wrapper behavior"
      contains: "TestLazySingleton"
  key_links:
    - from: "service.go"
      to: "sync.Mutex"
      via: "thread-safe lazy initialization"
      pattern: "sync\\.Mutex"
    - from: "service.go"
      to: "Container"
      via: "provider receives container"
      pattern: "func\\(\\*Container\\)"
---

<objective>
Create the internal service wrapper types that hold providers and manage instance lifecycle.

Purpose: Service wrappers encapsulate the differences between lazy singletons, transient services, and eager singletons. They're internal to the package but critical for the container's behavior.
Output: service.go with interface and implementations, service_test.go with behavior tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-core-di-container/01-CONTEXT.md
@.planning/phases/01-core-di-container/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create service.go with serviceWrapper interface and implementations</name>
  <files>service.go</files>
  <action>
Create service.go with the internal serviceWrapper interface and three implementations:

1. **serviceWrapper interface** (unexported):
```go
type serviceWrapper interface {
    name() string                                           // Service registration name
    typeName() string                                       // Full type name for errors
    isEager() bool                                          // Should instantiate at Build()
    getInstance(c *Container, chain []string) (any, error)  // Get or create instance
}
```

2. **lazySingleton[T any]** - default behavior:
- Holds `provider func(*Container) (T, error)`, `serviceName string`, `serviceTypeName string`
- Holds `instance T`, `built bool`, `mu sync.Mutex`
- `getInstance`: Lock mutex, check if built, call provider once, cache result
- Thread-safe: only one goroutine builds, others wait
- Pattern from RESEARCH.md:
```go
func (s *lazySingleton[T]) getInstance(c *Container, chain []string) (any, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    if s.built {
        return s.instance, nil
    }
    
    instance, err := s.provider(c)
    if err != nil {
        return nil, err
    }
    
    s.instance = instance
    s.built = true
    return instance, nil
}
```

3. **transientService[T any]** - new instance per resolve:
- Holds `provider func(*Container) (T, error)`, `serviceName string`, `serviceTypeName string`
- `getInstance`: Always call provider, no caching
- No mutex needed (no shared state beyond provider)

4. **eagerSingleton[T any]** - like lazy but `isEager()` returns true:
- Same implementation as lazySingleton
- `isEager()` returns `true` so Build() knows to instantiate

5. **instanceService[T any]** - pre-built value:
- Holds `value T`, `serviceName string`, `serviceTypeName string`
- `getInstance`: Return value directly, no provider call
- Used by `.Instance(val)` registration

**Constructor functions** (unexported):
```go
func newLazySingleton[T any](name, typeName string, provider func(*Container) (T, error)) *lazySingleton[T]
func newTransient[T any](name, typeName string, provider func(*Container) (T, error)) *transientService[T]
func newEagerSingleton[T any](name, typeName string, provider func(*Container) (T, error)) *eagerSingleton[T]
func newInstanceService[T any](name, typeName string, value T) *instanceService[T]
```

Import `sync` from stdlib.
  </action>
  <verify>`go build ./...` compiles without errors</verify>
  <done>serviceWrapper interface with 4 implementations (lazy, transient, eager, instance)</done>
</task>

<task type="auto">
  <name>Task 2: Create service_test.go with behavior tests</name>
  <files>service_test.go</files>
  <action>
Create service_test.go with tests verifying service wrapper behavior:

1. **TestLazySingleton_InstantiatesOnce**:
   - Create lazy singleton with provider that increments counter
   - Call getInstance twice
   - Assert provider called exactly once
   - Assert both calls return same instance

2. **TestLazySingleton_ConcurrentAccess**:
   - Create lazy singleton with provider that has small delay (time.Sleep)
   - Launch 10 goroutines calling getInstance concurrently
   - Assert provider called exactly once (use atomic counter)
   - Assert all goroutines get same instance

3. **TestTransientService_NewInstanceEachTime**:
   - Create transient service with provider
   - Call getInstance twice
   - Assert provider called twice
   - Assert instances are different (use pointer comparison or counter)

4. **TestEagerSingleton_IsEagerTrue**:
   - Create eager singleton
   - Assert isEager() returns true
   - (Actual Build() instantiation tested in later plan)

5. **TestInstanceService_ReturnsValue**:
   - Create instance service with pre-built value
   - Call getInstance
   - Assert returns the exact value (pointer equality)

Use standard testing package. Create a minimal mock Container for tests (just `New()`).

Pattern for test:
```go
func TestLazySingleton_InstantiatesOnce(t *testing.T) {
    callCount := 0
    provider := func(c *Container) (*testService, error) {
        callCount++
        return &testService{id: callCount}, nil
    }
    
    svc := newLazySingleton("test", "testService", provider)
    c := New()
    
    instance1, err := svc.getInstance(c, nil)
    if err != nil {
        t.Fatalf("getInstance 1: %v", err)
    }
    
    instance2, err := svc.getInstance(c, nil)
    if err != nil {
        t.Fatalf("getInstance 2: %v", err)
    }
    
    if callCount != 1 {
        t.Errorf("provider called %d times, want 1", callCount)
    }
    
    if instance1 != instance2 {
        t.Error("instances should be identical")
    }
}
```
  </action>
  <verify>`go test -v ./...` passes all 5 tests</verify>
  <done>All service wrapper tests pass, verifying lazy/transient/eager/instance behavior</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test -v ./...` passes all tests
3. Service wrappers correctly implement singleton, transient, and instance patterns
4. Concurrent access to lazy singletons is safe
</verification>

<success_criteria>
- [ ] serviceWrapper interface defined with name(), typeName(), isEager(), getInstance()
- [ ] lazySingleton[T] caches instance after first call
- [ ] transientService[T] creates new instance each call
- [ ] eagerSingleton[T] returns isEager() = true
- [ ] instanceService[T] returns pre-built value
- [ ] All tests pass including concurrent access test
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-di-container/01-02-SUMMARY.md`
</output>
