---
phase: 01-core-di-container
plan: 05
type: execute
wave: 5
depends_on: ["01-01", "01-02", "01-03", "01-04"]
files_modified:
  - inject.go
  - inject_test.go
autonomous: true

must_haves:
  truths:
    - "Struct fields tagged gaz:\"inject\" are auto-populated on resolve"
    - "Named injection works with gaz:\"inject,name=foo\""
    - "Optional fields are nil when service not registered"
    - "Unexported fields with tag return ErrNotSettable"
  artifacts:
    - path: "inject.go"
      provides: "Struct tag parsing and field injection"
      contains: "func injectStruct"
    - path: "inject_test.go"
      provides: "Injection behavior tests"
      contains: "TestInject_Optional"
  key_links:
    - from: "inject.go"
      to: "reflect"
      via: "struct field iteration"
      pattern: "reflect\\.StructTag"
    - from: "inject.go"
      to: "resolution.go"
      via: "resolves field dependencies"
      pattern: "resolveByName"
---

<objective>
Implement struct tag injection for automatic dependency resolution into struct fields.

Purpose: Struct injection provides a convenient alternative to manual resolution in providers. Fields tagged with `gaz:"inject"` are automatically populated when the containing struct is resolved.
Output: inject.go with tag parsing and field injection, inject_test.go with tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-core-di-container/01-CONTEXT.md
@.planning/phases/01-core-di-container/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create inject.go with tag parsing and field injection</name>
  <files>inject.go</files>
  <action>
Create inject.go with struct tag injection implementation:

1. **Tag format from CONTEXT.md:**
   - `gaz:"inject"` - inject by type
   - `gaz:"inject,name=primary"` - inject by name
   - `gaz:"inject,optional"` - nil if not registered

2. **tagOptions struct and parser:**
```go
type tagOptions struct {
    inject   bool   // Has "inject" keyword
    name     string // Custom name (from name=xxx)
    optional bool   // Allow missing service
}

func parseTag(tag string) tagOptions {
    opts := tagOptions{}
    parts := strings.Split(tag, ",")
    for _, part := range parts {
        part = strings.TrimSpace(part)
        if part == "inject" {
            opts.inject = true
        } else if part == "optional" {
            opts.optional = true
        } else if strings.HasPrefix(part, "name=") {
            opts.name = strings.TrimPrefix(part, "name=")
        }
    }
    return opts
}
```

3. **injectStruct function:**
```go
// injectStruct populates tagged fields of a struct with resolved services.
// target must be a pointer to a struct.
// chain is the current resolution chain for cycle detection.
func injectStruct(c *Container, target any, chain []string) error {
    val := reflect.ValueOf(target)
    if val.Kind() != reflect.Pointer || val.Elem().Kind() != reflect.Struct {
        return nil // Not a struct pointer, skip injection
    }
    
    structVal := val.Elem()
    structType := structVal.Type()
    
    for i := 0; i < structVal.NumField(); i++ {
        field := structType.Field(i)
        fieldVal := structVal.Field(i)
        
        tagValue, hasTag := field.Tag.Lookup("gaz")
        if !hasTag {
            continue
        }
        
        opts := parseTag(tagValue)
        if !opts.inject {
            continue
        }
        
        // Check if field is settable (exported)
        if !fieldVal.CanSet() {
            return fmt.Errorf("%w: field %s.%s is unexported", 
                ErrNotSettable, structType.Name(), field.Name)
        }
        
        // Determine service name
        serviceName := opts.name
        if serviceName == "" {
            serviceName = typeName(field.Type)
        }
        
        // Resolve the dependency
        instance, err := c.resolveByName(serviceName, chain)
        if err != nil {
            if opts.optional && errors.Is(err, ErrNotFound) {
                continue // Leave as zero value
            }
            return fmt.Errorf("injecting field %s.%s: %w", 
                structType.Name(), field.Name, err)
        }
        
        // Type check and assign
        instanceVal := reflect.ValueOf(instance)
        if !instanceVal.Type().AssignableTo(fieldVal.Type()) {
            return fmt.Errorf("%w: cannot assign %s to field %s.%s (%s)",
                ErrTypeMismatch, instanceVal.Type(), structType.Name(), 
                field.Name, fieldVal.Type())
        }
        
        fieldVal.Set(instanceVal)
    }
    
    return nil
}
```

4. **Update service wrappers to call injection:**

The injection should happen after the provider returns but before returning to caller. Modify service.go's getInstance implementations to call injectStruct on the result.

Update lazySingleton.getInstance:
```go
func (s *lazySingleton[T]) getInstance(c *Container, chain []string) (any, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    if s.built {
        return s.instance, nil
    }
    
    instance, err := s.provider(c)
    if err != nil {
        return nil, err
    }
    
    // Auto-inject struct fields
    if err := injectStruct(c, instance, chain); err != nil {
        return nil, err
    }
    
    s.instance = instance
    s.built = true
    return instance, nil
}
```

Apply same pattern to transientService and eagerSingleton (but NOT instanceService - pre-built values already have their dependencies).

Import `reflect`, `strings`, `errors`, `fmt`.
  </action>
  <verify>`go build ./...` compiles without errors</verify>
  <done>Struct tag injection with inject, name=, and optional modifiers</done>
</task>

<task type="auto">
  <name>Task 2: Create inject_test.go with injection tests</name>
  <files>inject_test.go</files>
  <action>
Create inject_test.go with tests for all injection scenarios:

1. **TestInject_BasicInjection**:
```go
type Handler struct {
    DB     *Database `gaz:"inject"`
    Logger *Logger   `gaz:"inject"`
}

func TestInject_BasicInjection(t *testing.T) {
    c := New()
    For[*Database](c).Instance(&Database{connStr: "test"})
    For[*Logger](c).Instance(&Logger{level: "debug"})
    For[*Handler](c).Provider(func(c *Container) (*Handler, error) {
        return &Handler{}, nil  // Fields auto-injected
    })
    
    h, err := Resolve[*Handler](c)
    if err != nil {
        t.Fatal(err)
    }
    
    if h.DB == nil || h.Logger == nil {
        t.Error("fields should be injected")
    }
}
```

2. **TestInject_Named**:
```go
type Service struct {
    Primary *DB `gaz:"inject,name=primary"`
    Replica *DB `gaz:"inject,name=replica"`
}
```
- Register two DBs with different names
- Resolve Service
- Assert correct DBs in each field

3. **TestInject_Optional_NotRegistered**:
```go
type Handler struct {
    Cache *Cache `gaz:"inject,optional"`
}
```
- Don't register Cache
- Resolve Handler
- Assert Cache is nil (not error)

4. **TestInject_Optional_Registered**:
- Same struct but register Cache
- Assert Cache is populated

5. **TestInject_UnexportedField_ReturnsError**:
```go
type BadHandler struct {
    db *Database `gaz:"inject"` // unexported!
}
```
- Try to resolve
- Assert ErrNotSettable

6. **TestInject_MissingDependency_ReturnsError**:
```go
type Handler struct {
    DB *Database `gaz:"inject"` // not registered, not optional
}
```
- Try to resolve
- Assert ErrNotFound wrapped in injection error

7. **TestInject_CycleViaInjection**:
- A has `B gaz:"inject"`
- B has `A gaz:"inject"`
- Resolve A
- Assert ErrCycle

8. **TestInject_NonStructPointer_Skipped**:
- Resolve a non-struct type (e.g., string)
- Assert no error, no injection attempted
  </action>
  <verify>`go test -v ./...` passes all injection tests</verify>
  <done>All struct injection tests pass including optional, named, and error cases</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test -v ./...` passes all tests
3. `gaz:"inject"` populates fields by type
4. `gaz:"inject,name=foo"` populates by registered name
5. `gaz:"inject,optional"` allows nil for missing services
6. Unexported fields return ErrNotSettable
7. Cycles via injection are detected
</verification>

<success_criteria>
- [ ] parseTag correctly handles inject, name=, optional modifiers
- [ ] injectStruct auto-populates tagged fields
- [ ] Named injection resolves correct service
- [ ] Optional fields are nil when not registered
- [ ] Unexported fields return ErrNotSettable
- [ ] Cycles via injection return ErrCycle
- [ ] All injection tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-di-container/01-05-SUMMARY.md`
</output>
