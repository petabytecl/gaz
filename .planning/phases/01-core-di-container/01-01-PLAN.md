---
phase: 01-core-di-container
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - errors.go
  - types.go
  - container.go
autonomous: true

must_haves:
  truths:
    - "Sentinel errors exist for all DI failure modes"
    - "TypeName[T]() returns fully-qualified type names with package path"
    - "Container struct can store services by name"
  artifacts:
    - path: "errors.go"
      provides: "Sentinel errors for DI operations"
      exports: ["ErrNotFound", "ErrCycle", "ErrDuplicate", "ErrNotSettable", "ErrTypeMismatch"]
    - path: "types.go"
      provides: "Type name generation from generics"
      exports: ["TypeName"]
    - path: "container.go"
      provides: "Container struct and constructor"
      exports: ["Container", "New"]
  key_links:
    - from: "container.go"
      to: "sync.RWMutex"
      via: "thread-safe service map"
      pattern: "sync\\.RWMutex"
    - from: "types.go"
      to: "reflect"
      via: "type introspection"
      pattern: "reflect\\.TypeOf"
---

<objective>
Establish the foundation for the gaz DI container: sentinel errors, type name utilities, and the core Container struct.

Purpose: All subsequent plans depend on these foundational types. Errors enable `errors.Is()` checks, TypeName enables consistent service keying, and Container provides the coordination point.
Output: Three source files that compile and can be imported.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-di-container/01-CONTEXT.md
@.planning/phases/01-core-di-container/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create errors.go with sentinel errors</name>
  <files>errors.go</files>
  <action>
Create errors.go with package gaz declaration and the following sentinel errors:

```go
var (
    ErrNotFound     = errors.New("gaz: service not found")
    ErrCycle        = errors.New("gaz: circular dependency detected")
    ErrDuplicate    = errors.New("gaz: service already registered")
    ErrNotSettable  = errors.New("gaz: field is not settable")
    ErrTypeMismatch = errors.New("gaz: type mismatch")
)
```

These must be package-level variables (not constants) so `errors.Is()` works correctly.

Import only `errors` from stdlib.
  </action>
  <verify>`go build ./...` compiles without errors</verify>
  <done>Five sentinel errors exported from errors.go</done>
</task>

<task type="auto">
  <name>Task 2: Create types.go with TypeName utility</name>
  <files>types.go</files>
  <action>
Create types.go with the TypeName[T]() function that returns fully-qualified type names:

1. Generic function `TypeName[T any]() string` that:
   - Creates a zero value of T
   - Uses `reflect.TypeOf(&zero).Elem()` to get the type (handles interface types correctly)
   - Calls internal `typeName(t reflect.Type) string` helper

2. Internal `typeName(t reflect.Type) string` function that handles:
   - Named types: return `pkg.Name` (e.g., `github.com/user/app.Config`)
   - Pointer types: return `*` + elem type name
   - Slice types: return `[]` + elem type name
   - Map types: return `map[key]value`
   - Interface types: use `t.String()` fallback
   - Unnamed types: use `t.String()` fallback

Pattern from RESEARCH.md:
```go
func TypeName[T any]() string {
    var zero T
    return typeName(reflect.TypeOf(&zero).Elem())
}

func typeName(t reflect.Type) string {
    if t == nil {
        return "nil"
    }
    if name := t.Name(); name != "" {
        if pkg := t.PkgPath(); pkg != "" {
            return pkg + "." + name
        }
        return name
    }
    switch t.Kind() {
    case reflect.Pointer:
        return "*" + typeName(t.Elem())
    case reflect.Slice:
        return "[]" + typeName(t.Elem())
    case reflect.Map:
        return "map[" + typeName(t.Key()) + "]" + typeName(t.Elem())
    default:
        return t.String()
    }
}
```

Import only `reflect` from stdlib.
  </action>
  <verify>`go build ./...` compiles; create a simple test that TypeName[string]() returns "string"</verify>
  <done>TypeName[T]() returns consistent type names for basic types, pointers, slices</done>
</task>

<task type="auto">
  <name>Task 3: Create container.go with Container struct</name>
  <files>container.go</files>
  <action>
Create container.go with the Container struct and New() constructor:

1. Container struct with:
   - `services map[string]any` - internal service storage (will hold serviceWrapper later)
   - `mu sync.RWMutex` - protects services map
   - `built bool` - tracks if Build() has been called

2. New() constructor:
   - Returns `*Container`
   - Initializes empty services map

Pattern:
```go
// Container is the dependency injection container.
// Use New() to create a new container, register services with For[T](),
// and resolve with Resolve[T]().
type Container struct {
    services map[string]any
    mu       sync.RWMutex
    built    bool
}

// New creates a new empty Container.
func New() *Container {
    return &Container{
        services: make(map[string]any),
    }
}
```

Do NOT add register/resolve methods yet â€” those come in later plans.

Import `sync` from stdlib.
  </action>
  <verify>`go build ./...` compiles; `c := gaz.New()` creates a container</verify>
  <done>Container struct with internal service map and New() constructor</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds with no errors
2. `go vet ./...` reports no issues
3. Package exports: ErrNotFound, ErrCycle, ErrDuplicate, ErrNotSettable, ErrTypeMismatch, TypeName, Container, New
</verification>

<success_criteria>
- [ ] errors.go exports 5 sentinel errors as `var` declarations
- [ ] types.go exports TypeName[T any]() string function
- [ ] container.go exports Container struct and New() constructor
- [ ] All files compile with `go build ./...`
- [ ] No external dependencies (pure stdlib)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-di-container/01-01-SUMMARY.md`
</output>
