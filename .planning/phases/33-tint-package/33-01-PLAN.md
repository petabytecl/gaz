---
phase: 33-tint-package
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - logger/tint/handler.go
  - logger/tint/options.go
  - logger/tint/buffer.go
  - logger/tint/doc.go
autonomous: true

must_haves:
  truths:
    - "Handler struct implements slog.Handler interface (4 methods)"
    - "Options.Level filters logs by slog.Leveler"
    - "WithAttrs returns NEW handler instance with preserved attributes"
    - "WithGroup returns NEW handler instance with group prefix"
    - "TTY detection auto-disables colors for non-terminal output"
    - "Options.NoColor explicitly disables color output"
  artifacts:
    - path: "logger/tint/handler.go"
      provides: "Handler struct with Enabled, WithAttrs, WithGroup, placeholder Handle"
      exports: ["Handler", "NewHandler"]
    - path: "logger/tint/options.go"
      provides: "Options struct with Level, AddSource, TimeFormat, NoColor"
      exports: ["Options"]
    - path: "logger/tint/buffer.go"
      provides: "Buffer pool for efficient allocation"
      exports: ["newBuffer", "buffer"]
    - path: "logger/tint/doc.go"
      provides: "Package documentation"
  key_links:
    - from: "logger/tint/handler.go"
      to: "golang.org/x/term"
      via: "term.IsTerminal() in NewHandler"
      pattern: "term\\.IsTerminal"
    - from: "logger/tint/handler.go"
      to: "logger/tint/buffer.go"
      via: "newBuffer() in WithAttrs"
      pattern: "newBuffer\\(\\)"
---

<objective>
Create the core logger/tint package structure with Handler type, Options configuration, and buffer pool. Implement all slog.Handler methods except Handle() (which will be completed in Plan 02).

Purpose: Establish the foundation for colored console logging that will replace lmittmann/tint
Output: Working Handler skeleton that can be instantiated and cloned correctly
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-tint-package/33-RESEARCH.md
@logger/provider.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logger/tint package structure with Options, buffer pool, and ANSI constants</name>
  <files>logger/tint/options.go, logger/tint/buffer.go, logger/tint/doc.go</files>
  <action>
Create the logger/tint/ package directory and foundation files:

**logger/tint/doc.go:**
```go
// Package logger/tint provides a colored console handler for slog.
// It is an internal replacement for lmittmann/tint with TTY detection
// and configurable color output.
package logger/tint
```

**logger/tint/options.go:**
```go
package logger/tint

import "log/slog"

// Options configure the Handler behavior.
type Options struct {
    // Level is the minimum level to log. Uses slog.Leveler interface.
    // Default: slog.LevelInfo
    Level slog.Leveler

    // AddSource includes file:line in output when true.
    AddSource bool

    // TimeFormat is the time.Layout format string for timestamps.
    // Default: "15:04:05.000" (matches current logger usage)
    TimeFormat string

    // NoColor disables ANSI color output.
    // Auto-detected based on TTY when not explicitly set.
    NoColor bool
}
```

**logger/tint/buffer.go:**
Use sync.Pool for buffer allocation efficiency:
```go
package logger/tint

import "sync"

type buffer []byte

var bufPool = sync.Pool{
    New: func() any {
        b := make(buffer, 0, 1024)
        return &b
    },
}

func newBuffer() *buffer {
    return bufPool.Get().(*buffer)
}

func (b *buffer) Free() {
    // Reset length, keep capacity
    *b = (*b)[:0]
    bufPool.Put(b)
}

func (b *buffer) Write(p []byte) (int, error) {
    *b = append(*b, p...)
    return len(p), nil
}

func (b *buffer) WriteString(s string) (int, error) {
    *b = append(*b, s...)
    return len(s), nil
}

func (b *buffer) WriteByte(c byte) error {
    *b = append(*b, c)
    return nil
}
```

Add ANSI color constants at the top of options.go or in a separate file within handler.go:
```go
const (
    ansiBrightRed    = "\x1b[91m" // ERROR
    ansiBrightYellow = "\x1b[93m" // WARN
    ansiBrightGreen  = "\x1b[92m" // INFO
    ansiBrightBlue   = "\x1b[94m" // DEBUG
    ansiReset        = "\x1b[0m"
    ansiFaint        = "\x1b[2m"
)
```
  </action>
  <verify>
Files exist:
- `ls logger/tint/doc.go logger/tint/options.go logger/tint/buffer.go`
- `go build ./logger/tint/...` compiles without errors
  </verify>
  <done>
Package compiles with Options struct, buffer pool, and ANSI constants defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Handler with Enabled, NewHandler, clone, WithAttrs, WithGroup</name>
  <files>logger/tint/handler.go</files>
  <action>
Create logger/tint/handler.go with the Handler struct and all slog.Handler methods except Handle (stub it for now):

**Handler struct:**
```go
package logger/tint

import (
    "context"
    "io"
    "log/slog"
    "os"
    "sync"

    "golang.org/x/term"
)

// Handler implements slog.Handler for colored console output.
type Handler struct {
    attrsPrefix string      // pre-formatted attributes from WithAttrs
    groupPrefix string      // "group1.group2." prefix for keys
    groups      []string    // group names for tracking

    mu   *sync.Mutex        // POINTER - shared across all clones
    w    io.Writer
    opts Options
}

var _ slog.Handler = (*Handler)(nil)  // Compile-time interface check
```

**NewHandler with TTY detection:**
```go
// NewHandler creates a new colored console handler.
// TTY detection auto-disables colors unless NoColor is explicitly set.
func NewHandler(w io.Writer, opts *Options) *Handler {
    h := &Handler{
        w:  w,
        mu: &sync.Mutex{},
    }
    if opts != nil {
        h.opts = *opts
    }

    // Auto-detect TTY unless NoColor explicitly set via constructor
    // We only auto-detect if the caller didn't set NoColor
    if !h.opts.NoColor {
        if f, ok := w.(*os.File); ok {
            h.opts.NoColor = !term.IsTerminal(int(f.Fd()))
        } else {
            h.opts.NoColor = true // Not a file, assume no TTY
        }
    }

    // Set default time format if not specified
    if h.opts.TimeFormat == "" {
        h.opts.TimeFormat = "15:04:05.000"
    }

    return h
}
```

**Enabled method (TNT-03):**
```go
// Enabled reports whether the handler handles records at the given level.
func (h *Handler) Enabled(_ context.Context, level slog.Level) bool {
    minLevel := slog.LevelInfo
    if h.opts.Level != nil {
        minLevel = h.opts.Level.Level()
    }
    return level >= minLevel
}
```

**clone method (shared mutex pattern from research):**
```go
// clone creates a copy of the handler, sharing the mutex.
func (h *Handler) clone() *Handler {
    return &Handler{
        attrsPrefix: h.attrsPrefix,
        groupPrefix: h.groupPrefix,
        groups:      h.groups,
        mu:          h.mu, // CRITICAL: shared across clones
        w:           h.w,
        opts:        h.opts,
    }
}
```

**WithAttrs (TNT-06) - returns NEW instance:**
```go
// WithAttrs returns a new Handler with the given attributes pre-formatted.
func (h *Handler) WithAttrs(attrs []slog.Attr) slog.Handler {
    if len(attrs) == 0 {
        return h
    }
    h2 := h.clone()

    buf := newBuffer()
    defer buf.Free()

    // Pre-format attributes with current group context
    for _, attr := range attrs {
        h.appendAttr(buf, attr, h.groupPrefix, h.groups)
    }
    h2.attrsPrefix = h.attrsPrefix + string(*buf)
    return h2
}
```

**WithGroup (TNT-07) - returns NEW instance:**
```go
// WithGroup returns a new Handler with the given group name.
func (h *Handler) WithGroup(name string) slog.Handler {
    if name == "" {
        return h
    }
    h2 := h.clone()
    h2.groupPrefix += name + "."
    h2.groups = append(h2.groups, name)
    return h2
}
```

**Handle stub (to be completed in Plan 02):**
```go
// Handle outputs the log record. Implemented in Plan 02.
func (h *Handler) Handle(_ context.Context, r slog.Record) error {
    // TODO: Implement in Plan 02
    return nil
}
```

**appendAttr stub (to be completed in Plan 02):**
```go
// appendAttr formats an attribute. Stub for WithAttrs to compile.
func (h *Handler) appendAttr(buf *buffer, a slog.Attr, groupPrefix string, groups []string) {
    // TODO: Implement in Plan 02
    a.Value = a.Value.Resolve()
    if a.Equal(slog.Attr{}) {
        return
    }
    buf.WriteString(groupPrefix)
    buf.WriteString(a.Key)
    buf.WriteByte('=')
    buf.WriteString(a.Value.String())
    buf.WriteByte(' ')
}
```

**Run `go get golang.org/x/term`** to add the dependency.
  </action>
  <verify>
```bash
go build ./logger/tint/...
go test ./logger/tint/... -run=NONE  # Just compile tests if any
```
Verify Handler implements slog.Handler (compile-time check via var _ line).
  </verify>
  <done>
Handler struct with Enabled, NewHandler (TTY detection), clone, WithAttrs, WithGroup all implemented. Package compiles and Handler satisfies slog.Handler interface.
  </done>
</task>

</tasks>

<verification>
```bash
# Package compiles
go build ./logger/tint/...

# Verify TTY detection dependency added
grep "golang.org/x/term" go.mod

# Quick verification that Handler can be instantiated
go run -e 'import "github.com/petabytecl/gaz/logger/tint"; _ = tint.NewHandler(nil, nil)'
```
</verification>

<success_criteria>
- [ ] logger/tint/ package directory created with 4 files (doc.go, options.go, buffer.go, handler.go)
- [ ] Handler struct implements slog.Handler interface (compiles with var _ check)
- [ ] NewHandler performs TTY detection via golang.org/x/term
- [ ] WithAttrs returns new handler instance (not self)
- [ ] WithGroup returns new handler instance with group prefix
- [ ] Options struct has Level, AddSource, TimeFormat, NoColor fields
- [ ] Buffer pool uses sync.Pool for efficiency
- [ ] golang.org/x/term added to go.mod
</success_criteria>

<output>
After completion, create `.planning/phases/33-tint-package/33-01-SUMMARY.md`
</output>
