---
phase: 33-tint-package
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - logger/tint/handler.go
  - logger/tint/handler_test.go
autonomous: true

must_haves:
  truths:
    - "Log levels display in correct ANSI colors (DEBUG=blue, INFO=green, WARN=yellow, ERROR=red)"
    - "Options.AddSource includes file:line in output"
    - "Options.TimeFormat customizes timestamp format"
    - "Attribute values are resolved before output (LogValuer types expanded)"
    - "Groups prefix attribute keys correctly"
  artifacts:
    - path: "logger/tint/handler.go"
      provides: "Complete Handle method with colorized output"
      contains: "func (h *Handler) Handle"
    - path: "logger/tint/handler_test.go"
      provides: "Comprehensive tests including slogtest"
      contains: "TestHandler"
  key_links:
    - from: "logger/tint/handler.go"
      to: "slog.Record"
      via: "r.Attrs() iteration in Handle"
      pattern: "r\\.Attrs\\("
    - from: "logger/tint/handler.go"
      to: "runtime.CallersFrames"
      via: "source location extraction"
      pattern: "runtime\\.CallersFrames"
---

<objective>
Implement the Handle() method with colorized level output, timestamp formatting, source location, and attribute formatting. Add comprehensive tests using testing/slogtest to verify slog.Handler contract compliance.

Purpose: Complete the logger/tint Handler with full logging functionality and verified correctness
Output: Fully functional colored console handler with passing tests
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-tint-package/33-RESEARCH.md
@.planning/phases/33-tint-package/33-01-SUMMARY.md
@logger/tint/handler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Handle method with colorized output and attribute formatting</name>
  <files>logger/tint/handler.go</files>
  <action>
Replace the Handle stub and appendAttr stub with full implementations:

**appendLevel with colors (TNT-02):**
```go
// appendLevel writes the colorized log level.
func (h *Handler) appendLevel(buf *buffer, level slog.Level) {
    if !h.opts.NoColor {
        switch {
        case level < slog.LevelInfo:
            buf.WriteString(ansiBrightBlue) // DEBUG
        case level < slog.LevelWarn:
            buf.WriteString(ansiBrightGreen) // INFO
        case level < slog.LevelError:
            buf.WriteString(ansiBrightYellow) // WARN
        default:
            buf.WriteString(ansiBrightRed) // ERROR
        }
    }

    // Write level string (padded for alignment)
    switch {
    case level < slog.LevelInfo:
        buf.WriteString("DBG")
    case level < slog.LevelWarn:
        buf.WriteString("INF")
    case level < slog.LevelError:
        buf.WriteString("WRN")
    default:
        buf.WriteString("ERR")
    }

    if !h.opts.NoColor {
        buf.WriteString(ansiReset)
    }
}
```

**appendTime (TNT-05):**
```go
// appendTime writes the formatted timestamp.
func (h *Handler) appendTime(buf *buffer, t time.Time) {
    if !h.opts.NoColor {
        buf.WriteString(ansiFaint)
    }
    *buf = t.AppendFormat(*buf, h.opts.TimeFormat)
    if !h.opts.NoColor {
        buf.WriteString(ansiReset)
    }
}
```

**appendSource (TNT-04):**
```go
import (
    "path/filepath"
    "runtime"
)

// appendSource writes the source file:line.
func (h *Handler) appendSource(buf *buffer, pc uintptr) {
    fs := runtime.CallersFrames([]uintptr{pc})
    f, _ := fs.Next()
    if f.File == "" {
        return
    }

    if !h.opts.NoColor {
        buf.WriteString(ansiFaint)
    }

    // Write dir/file.go:line format
    dir := filepath.Base(filepath.Dir(f.File))
    file := filepath.Base(f.File)
    buf.WriteString(dir)
    buf.WriteByte('/')
    buf.WriteString(file)
    buf.WriteByte(':')

    // Use strconv for zero-allocation int formatting
    *buf = strconv.AppendInt(*buf, int64(f.Line), 10)

    if !h.opts.NoColor {
        buf.WriteString(ansiReset)
    }
}
```

**appendAttr (full implementation with value resolution):**
```go
// appendAttr formats an attribute with proper value resolution.
func (h *Handler) appendAttr(buf *buffer, a slog.Attr, groupPrefix string, groups []string) {
    // Resolve LogValuer types
    a.Value = a.Value.Resolve()

    // Skip empty attributes
    if a.Equal(slog.Attr{}) {
        return
    }

    // Handle group type recursively
    if a.Value.Kind() == slog.KindGroup {
        attrs := a.Value.Group()
        // Empty group with name should be ignored
        if len(attrs) == 0 {
            return
        }

        // Update prefix for nested group
        prefix := groupPrefix
        if a.Key != "" {
            prefix += a.Key + "."
        }

        for _, ga := range attrs {
            h.appendAttr(buf, ga, prefix, groups)
        }
        return
    }

    // Key with group prefix
    if !h.opts.NoColor {
        buf.WriteString(ansiFaint)
    }
    buf.WriteString(groupPrefix)
    buf.WriteString(a.Key)
    buf.WriteByte('=')
    if !h.opts.NoColor {
        buf.WriteString(ansiReset)
    }

    // Value formatting
    h.appendValue(buf, a.Value)
    buf.WriteByte(' ')
}

// appendValue formats the value based on kind.
func (h *Handler) appendValue(buf *buffer, v slog.Value) {
    switch v.Kind() {
    case slog.KindString:
        buf.WriteString(v.String())
    case slog.KindInt64:
        *buf = strconv.AppendInt(*buf, v.Int64(), 10)
    case slog.KindUint64:
        *buf = strconv.AppendUint(*buf, v.Uint64(), 10)
    case slog.KindFloat64:
        *buf = strconv.AppendFloat(*buf, v.Float64(), 'f', -1, 64)
    case slog.KindBool:
        *buf = strconv.AppendBool(*buf, v.Bool())
    case slog.KindDuration:
        buf.WriteString(v.Duration().String())
    case slog.KindTime:
        *buf = v.Time().AppendFormat(*buf, time.RFC3339)
    case slog.KindAny:
        buf.WriteString(fmt.Sprint(v.Any()))
    default:
        buf.WriteString(v.String())
    }
}
```

**Handle method (complete):**
```go
import (
    "context"
    "fmt"
    "strconv"
    "time"
)

// Handle outputs the log record with colorized formatting.
func (h *Handler) Handle(_ context.Context, r slog.Record) error {
    buf := newBuffer()
    defer buf.Free()

    // 1. Time (if not zero)
    if !r.Time.IsZero() {
        h.appendTime(buf, r.Time)
        buf.WriteByte(' ')
    }

    // 2. Level (colorized)
    h.appendLevel(buf, r.Level)
    buf.WriteByte(' ')

    // 3. Source (if AddSource enabled and PC available)
    if h.opts.AddSource && r.PC != 0 {
        h.appendSource(buf, r.PC)
        buf.WriteByte(' ')
    }

    // 4. Message
    buf.WriteString(r.Message)

    // 5. Pre-formatted attrs from WithAttrs (if any)
    if len(h.attrsPrefix) > 0 {
        buf.WriteByte(' ')
        buf.WriteString(h.attrsPrefix)
    }

    // 6. Record attrs
    if r.NumAttrs() > 0 {
        buf.WriteByte(' ')
        r.Attrs(func(a slog.Attr) bool {
            h.appendAttr(buf, a, h.groupPrefix, h.groups)
            return true
        })
    }

    // Remove trailing space if present, add newline
    if len(*buf) > 0 && (*buf)[len(*buf)-1] == ' ' {
        (*buf)[len(*buf)-1] = '\n'
    } else {
        buf.WriteByte('\n')
    }

    // Thread-safe write
    h.mu.Lock()
    defer h.mu.Unlock()
    _, err := h.w.Write(*buf)
    return err
}
```

Add required imports: `"fmt"`, `"strconv"`, `"time"`, `"path/filepath"`, `"runtime"`.
  </action>
  <verify>
```bash
go build ./logger/tint/...
# Quick manual test
go run -exec '' cmd/test-logger/tint/main.go  # (create simple test program if needed)
```
  </verify>
  <done>
Handle method fully implemented with colorized levels, time formatting, source location, and proper attribute handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests including slogtest verification</name>
  <files>logger/tint/handler_test.go</files>
  <action>
Create comprehensive tests for the logger/tint Handler:

**logger/tint/handler_test.go:**
```go
package logger/tint

import (
    "bytes"
    "log/slog"
    "strings"
    "testing"
)

func TestNewHandler_DefaultOptions(t *testing.T) {
    var buf bytes.Buffer
    h := NewHandler(&buf, nil)

    // Non-file writers should default to NoColor
    if !h.opts.NoColor {
        t.Error("expected NoColor=true for non-file writer")
    }

    // Default time format
    if h.opts.TimeFormat != "15:04:05.000" {
        t.Errorf("expected default TimeFormat '15:04:05.000', got %q", h.opts.TimeFormat)
    }
}

func TestHandler_Enabled(t *testing.T) {
    var buf bytes.Buffer

    tests := []struct {
        name    string
        level   slog.Leveler
        check   slog.Level
        want    bool
    }{
        {"default enables INFO", nil, slog.LevelInfo, true},
        {"default enables WARN", nil, slog.LevelWarn, true},
        {"default disables DEBUG", nil, slog.LevelDebug, false},
        {"debug level enables DEBUG", slog.LevelDebug, slog.LevelDebug, true},
        {"warn level disables INFO", slog.LevelWarn, slog.LevelInfo, false},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            h := NewHandler(&buf, &Options{Level: tt.level})
            if got := h.Enabled(nil, tt.check); got != tt.want {
                t.Errorf("Enabled(%v) = %v, want %v", tt.check, got, tt.want)
            }
        })
    }
}

func TestHandler_WithAttrs_ReturnsNewInstance(t *testing.T) {
    var buf bytes.Buffer
    h1 := NewHandler(&buf, &Options{NoColor: true})

    h2 := h1.WithAttrs([]slog.Attr{slog.String("key", "value")})

    // Must return new instance
    if h1 == h2 {
        t.Error("WithAttrs returned same instance")
    }

    // Original should not have attrs
    if h1.(*Handler).attrsPrefix != "" {
        t.Error("original handler modified by WithAttrs")
    }

    // New handler should have attrs
    if h2.(*Handler).attrsPrefix == "" {
        t.Error("new handler missing attrs")
    }
}

func TestHandler_WithGroup_ReturnsNewInstance(t *testing.T) {
    var buf bytes.Buffer
    h1 := NewHandler(&buf, &Options{NoColor: true})

    h2 := h1.WithGroup("mygroup")

    // Must return new instance
    if h1 == h2 {
        t.Error("WithGroup returned same instance")
    }

    // Original should not have group
    if h1.(*Handler).groupPrefix != "" {
        t.Error("original handler modified by WithGroup")
    }

    // New handler should have group prefix
    if h2.(*Handler).groupPrefix != "mygroup." {
        t.Errorf("expected groupPrefix 'mygroup.', got %q", h2.(*Handler).groupPrefix)
    }
}

func TestHandler_LevelColors(t *testing.T) {
    var buf bytes.Buffer
    h := NewHandler(&buf, &Options{NoColor: false})
    // Force colors on for test (normally auto-detected)
    h.opts.NoColor = false

    logger := slog.New(h)

    tests := []struct {
        level slog.Level
        color string
        label string
    }{
        {slog.LevelDebug, ansiBrightBlue, "DBG"},
        {slog.LevelInfo, ansiBrightGreen, "INF"},
        {slog.LevelWarn, ansiBrightYellow, "WRN"},
        {slog.LevelError, ansiBrightRed, "ERR"},
    }

    for _, tt := range tests {
        t.Run(tt.label, func(t *testing.T) {
            buf.Reset()
            h.opts.Level = slog.LevelDebug // Enable all levels

            logger.Log(nil, tt.level, "test message")

            output := buf.String()
            if !strings.Contains(output, tt.color) {
                t.Errorf("expected color %q in output, got: %s", tt.color, output)
            }
            if !strings.Contains(output, tt.label) {
                t.Errorf("expected label %q in output, got: %s", tt.label, output)
            }
        })
    }
}

func TestHandler_NoColor(t *testing.T) {
    var buf bytes.Buffer
    h := NewHandler(&buf, &Options{NoColor: true})
    logger := slog.New(h)

    logger.Info("test message")

    output := buf.String()
    if strings.Contains(output, "\x1b[") {
        t.Errorf("expected no ANSI codes with NoColor=true, got: %s", output)
    }
}

func TestHandler_GroupedAttrs(t *testing.T) {
    var buf bytes.Buffer
    h := NewHandler(&buf, &Options{NoColor: true})
    logger := slog.New(h)

    logger.WithGroup("request").With("method", "GET").Info("handled")

    output := buf.String()
    if !strings.Contains(output, "request.method=GET") {
        t.Errorf("expected grouped attr 'request.method=GET', got: %s", output)
    }
}

func TestHandler_AddSource(t *testing.T) {
    var buf bytes.Buffer
    h := NewHandler(&buf, &Options{NoColor: true, AddSource: true})
    logger := slog.New(h)

    logger.Info("test with source")

    output := buf.String()
    // Should contain file:line pattern
    if !strings.Contains(output, "handler_test.go:") {
        t.Errorf("expected source location, got: %s", output)
    }
}

func TestHandler_TimeFormat(t *testing.T) {
    var buf bytes.Buffer
    h := NewHandler(&buf, &Options{NoColor: true, TimeFormat: "2006-01-02"})
    logger := slog.New(h)

    logger.Info("test")

    output := buf.String()
    // Should contain date format
    if !strings.Contains(output, "2026-") { // Adjust for actual date
        // More flexible check - just ensure no time component
        if strings.Contains(output, "15:04") {
            t.Errorf("expected custom time format, got: %s", output)
        }
    }
}

func TestHandler_ConcurrentWrites(t *testing.T) {
    var buf bytes.Buffer
    h := NewHandler(&buf, &Options{NoColor: true})
    logger := slog.New(h)

    done := make(chan bool)
    for i := 0; i < 10; i++ {
        go func(n int) {
            for j := 0; j < 100; j++ {
                logger.Info("concurrent", "goroutine", n, "iteration", j)
            }
            done <- true
        }(i)
    }

    for i := 0; i < 10; i++ {
        <-done
    }

    // Count newlines to verify all messages written
    lines := strings.Count(buf.String(), "\n")
    if lines != 1000 {
        t.Errorf("expected 1000 log lines, got %d", lines)
    }
}
```

Run all tests to verify correctness:
```bash
go test ./logger/tint/... -v
```
  </action>
  <verify>
```bash
go test ./logger/tint/... -v
go test ./logger/tint/... -race  # Race detector for concurrent safety
```
All tests pass, including concurrent write test with race detector.
  </verify>
  <done>
Comprehensive test suite passes with race detector, verifying:
- Enabled() respects Options.Level
- WithAttrs/WithGroup return new instances
- Level colors match requirements (DBG=blue, INF=green, WRN=yellow, ERR=red)
- NoColor disables ANSI codes
- Groups prefix attributes correctly
- AddSource includes file:line
- TimeFormat is customizable
- Concurrent writes are thread-safe
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
go test ./logger/tint/... -v

# Race detector clean
go test ./logger/tint/... -race

# Package builds
go build ./logger/tint/...
```
</verification>

<success_criteria>
- [ ] Handle() method writes colorized output with correct level colors
- [ ] DEBUG uses bright blue, INFO uses bright green, WARN uses bright yellow, ERROR uses bright red
- [ ] Options.AddSource includes dir/file.go:line in output
- [ ] Options.TimeFormat controls timestamp format
- [ ] Attribute values are resolved (LogValuer expanded)
- [ ] Groups prefix attribute keys (e.g., "group.key=value")
- [ ] All tests pass including concurrent write test
- [ ] Race detector finds no issues
</success_criteria>

<output>
After completion, create `.planning/phases/33-tint-package/33-02-SUMMARY.md`
</output>
