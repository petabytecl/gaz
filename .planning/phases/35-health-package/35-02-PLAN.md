---
phase: 35-health-package
plan: 02
type: execute
wave: 2
depends_on: ["35-01"]
files_modified:
  - healthx/writer.go
  - healthx/writer_test.go
  - healthx/handler.go
  - healthx/handler_test.go
autonomous: true

must_haves:
  truths:
    - "HTTP handler calls checker and writes response with correct status code"
    - "Handler returns 200 when all critical checks pass (configurable via WithStatusCodeUp)"
    - "Handler returns 503 when any critical check fails (configurable via WithStatusCodeDown)"
    - "ResultWriter interface allows custom response formats"
    - "IETF health+json response format works correctly (pass/fail/warn status)"
    - "Liveness-style handler can return 200 even on failure (both status codes set to 200)"
  artifacts:
    - path: "healthx/writer.go"
      provides: "ResultWriter interface and IETFResultWriter implementation"
      exports: ["ResultWriter", "IETFResultWriter", "NewIETFResultWriter", "WithShowDetails", "WithShowErrors"]
    - path: "healthx/handler.go"
      provides: "NewHandler with functional options"
      exports: ["HandlerOption", "NewHandler", "WithResultWriter", "WithStatusCodeUp", "WithStatusCodeDown"]
  key_links:
    - from: "healthx/handler.go"
      to: "healthx/checker.go"
      via: "Handler calls Checker.Check()"
      pattern: "checker\\.Check\\("
    - from: "healthx/handler.go"
      to: "healthx/writer.go"
      via: "Handler uses ResultWriter to write response"
      pattern: "resultWriter\\.Write\\("
    - from: "healthx/writer.go"
      to: "healthx/status.go"
      via: "Maps AvailabilityStatus to IETF status strings"
      pattern: "StatusUp|StatusDown|StatusUnknown"
---

<objective>
Create the HTTP handler and IETF result writer for health check endpoints.

Purpose: Provide HTTP handlers that execute health checks and return properly formatted responses with configurable status codes, enabling both health and liveness endpoint patterns.

Output:
- healthx/writer.go - ResultWriter interface and IETFResultWriter (HLT-09, HLT-11)
- healthx/handler.go - NewHandler with options (HLT-04, HLT-05, HLT-06, HLT-10)
- Comprehensive tests for handler and writer behavior
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-health-package/35-CONTEXT.md
@.planning/phases/35-health-package/35-RESEARCH.md
@.planning/phases/35-health-package/35-01-SUMMARY.md

Existing writer for reference:
@health/writer.go
@health/handlers.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ResultWriter interface and IETF implementation</name>
  <files>
    - healthx/writer.go
    - healthx/writer_test.go
  </files>
  <action>
Implement the ResultWriter interface and IETF health+json format per RESEARCH.md:

1. **healthx/writer.go** - ResultWriter interface and IETF implementation (HLT-09, HLT-11):
   ```go
   // ResultWriter writes health check results to an HTTP response.
   type ResultWriter interface {
       Write(result *CheckerResult, statusCode int, w http.ResponseWriter, r *http.Request) error
   }

   // IETFResultWriter implements ResultWriter using IETF health+json format.
   // See: https://tools.ietf.org/id/draft-inadarei-api-health-check-06.html
   type IETFResultWriter struct {
       showDetails bool  // Include per-check details (default false per CONTEXT.md)
       showErrors  bool  // Include error messages (default false per CONTEXT.md)
   }

   // IETFWriterOption configures the IETFResultWriter.
   type IETFWriterOption func(*IETFResultWriter)

   // NewIETFResultWriter creates a new IETFResultWriter.
   func NewIETFResultWriter(opts ...IETFWriterOption) *IETFResultWriter

   // WithShowDetails enables per-check details in response.
   func WithShowDetails(show bool) IETFWriterOption

   // WithShowErrors enables error messages in response.
   func WithShowErrors(show bool) IETFWriterOption
   ```

   IETF response format from RESEARCH.md:
   ```go
   type ietfResponse struct {
       Status string                 `json:"status"`           // "pass", "fail", "warn"
       Checks map[string][]ietfCheck `json:"checks,omitempty"` // Per-component checks
   }

   type ietfCheck struct {
       Status string `json:"status"`           // "pass", "fail", "warn"
       Time   string `json:"time,omitempty"`   // ISO8601 timestamp
       Output string `json:"output,omitempty"` // Error message (omit for pass)
   }
   ```

   Status mapping:
   - StatusUp -> "pass"
   - StatusDown -> "fail"  
   - StatusUnknown -> "warn"

   Security defaults per CONTEXT.md:
   - showDetails = false (hide per-check details by default)
   - showErrors = false (hide error messages by default)

2. **healthx/writer_test.go** - Writer tests:
   - Test basic response with status only
   - Test response with details enabled
   - Test response with errors enabled
   - Test all status mappings (pass/fail/warn)
   - Test Content-Type header (application/health+json)
   - Test JSON encoding correctness
  </action>
  <verify>
```bash
# Package compiles
go build ./healthx/...

# Writer tests pass
go test ./healthx/... -v -run "TestWriter|TestIETF"
```
  </verify>
  <done>
- healthx/writer.go exports ResultWriter interface
- healthx/writer.go exports IETFResultWriter, NewIETFResultWriter
- healthx/writer.go exports WithShowDetails, WithShowErrors options
- IETF health+json format implemented correctly
- Details hidden by default (security)
- Error messages hidden by default (security)
- All writer tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP handler with configurable status codes</name>
  <files>
    - healthx/handler.go
    - healthx/handler_test.go
  </files>
  <action>
Implement the HTTP handler per RESEARCH.md:

1. **healthx/handler.go** - Handler implementation (HLT-04, HLT-05, HLT-06):
   ```go
   // HandlerOption configures the health handler.
   type HandlerOption func(*handlerConfig)

   // NewHandler creates an HTTP handler for health checks.
   func NewHandler(checker Checker, opts ...HandlerOption) http.Handler

   // WithResultWriter sets the response writer (default: IETFResultWriter).
   func WithResultWriter(w ResultWriter) HandlerOption

   // WithStatusCodeUp sets status code when all checks pass (default: 200).
   func WithStatusCodeUp(code int) HandlerOption

   // WithStatusCodeDown sets status code when any check fails (default: 503).
   func WithStatusCodeDown(code int) HandlerOption
   ```

   Handler logic:
   ```go
   return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
       result := checker.Check(r.Context())
       statusCode := cfg.statusCodeUp
       if result.Status == StatusDown || result.Status == StatusUnknown {
           statusCode = cfg.statusCodeDown
       }
       cfg.resultWriter.Write(&result, statusCode, w, r)
   })
   ```

   Liveness pattern (HLT-10):
   - Liveness handlers should return 200 even on failure
   - Achieved by setting both WithStatusCodeUp(200) and WithStatusCodeDown(200)
   - The body still contains the actual status for logging/debugging

2. **healthx/handler_test.go** - Handler tests:
   - Test handler returns 200 when all checks pass
   - Test handler returns 503 when check fails
   - Test WithStatusCodeUp option
   - Test WithStatusCodeDown option
   - Test liveness pattern (200 on failure when configured)
   - Test WithResultWriter option
   - Test context propagation from request to checker
   - Test handler integration with real checker
  </action>
  <verify>
```bash
# Package compiles
go build ./healthx/...

# All handler tests pass
go test ./healthx/... -v -run "TestHandler|TestNewHandler"

# Full package tests
go test ./healthx/... -v -cover -race
```
  </verify>
  <done>
- healthx/handler.go exports NewHandler function
- healthx/handler.go exports WithResultWriter, WithStatusCodeUp, WithStatusCodeDown options
- Handler uses checker.Check(r.Context()) for proper context propagation
- Default status codes: 200 up, 503 down
- Liveness pattern works (200 on failure when both codes set to 200)
- All handler tests pass with race detector
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
# Full package test with coverage
go test ./healthx/... -v -cover -race

# Verify handler returns correct Content-Type
go test ./healthx/... -v -run "TestHandler" 2>&1 | grep -i content-type

# Verify exports
go doc ./healthx | grep -E "(NewHandler|NewIETFResultWriter|WithResult|WithStatus)"
```
</verification>

<success_criteria>
- [ ] healthx/writer.go exports ResultWriter interface
- [ ] healthx/writer.go exports IETFResultWriter with NewIETFResultWriter
- [ ] healthx/writer.go exports WithShowDetails, WithShowErrors options
- [ ] IETF health+json format correct (pass/fail/warn status values)
- [ ] Content-Type set to "application/health+json"
- [ ] Details and errors hidden by default (security per CONTEXT.md)
- [ ] healthx/handler.go exports NewHandler
- [ ] healthx/handler.go exports WithResultWriter, WithStatusCodeUp, WithStatusCodeDown
- [ ] Handler returns 200 when checks pass, 503 when checks fail (defaults)
- [ ] Liveness pattern works (200 on failure with both codes set to 200)
- [ ] Context propagates from HTTP request to checker
- [ ] All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/35-health-package/35-02-SUMMARY.md`
</output>
