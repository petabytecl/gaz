---
phase: 35-health-package
plan: 03
type: execute
wave: 3
depends_on: ["35-02"]
files_modified:
  - health/manager.go
  - health/handlers.go
  - health/writer.go
  - health/manager_test.go
  - health/handlers_test.go
  - health/writer_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "health/manager.go imports healthx/ instead of alexliesenfeld/health"
    - "health/handlers.go uses healthx.NewHandler with healthx options"
    - "health/writer.go uses healthx types (or is removed if IETFResultWriter moved to healthx)"
    - "All existing health package tests pass without modification"
    - "alexliesenfeld/health is removed from go.mod"
    - "No import cycles exist between health/ and healthx/ (INT-03)"
    - "Overall test coverage maintained at 90%+"
  artifacts:
    - path: "health/manager.go"
      provides: "Manager using healthx.Check and healthx.NewChecker"
      contains: "healthx.Check"
    - path: "health/handlers.go"
      provides: "Handlers using healthx.NewHandler"
      contains: "healthx.NewHandler"
    - path: "go.mod"
      provides: "Dependencies without alexliesenfeld/health"
      pattern: "^(?!.*alexliesenfeld/health)"
  key_links:
    - from: "health/manager.go"
      to: "healthx/checker.go"
      via: "Manager creates healthx.Checker"
      pattern: "healthx\\.NewChecker"
    - from: "health/handlers.go"
      to: "healthx/handler.go"
      via: "Handlers use healthx.NewHandler"
      pattern: "healthx\\.NewHandler"
    - from: "health/manager.go"
      to: "healthx/check.go"
      via: "Manager stores healthx.Check"
      pattern: "healthx\\.Check"
---

<objective>
Migrate health package to use internal healthx and remove alexliesenfeld/health dependency.

Purpose: Complete the v4.0 dependency reduction by replacing the external health library with the internal implementation, ensuring all tests pass and coverage is maintained.

Output:
- Updated health/manager.go using healthx types (HLT-12)
- Updated health/handlers.go using healthx.NewHandler
- Updated health/writer.go using healthx types (or delegate to healthx)
- alexliesenfeld/health removed from go.mod (HLT-13)
- All tests passing (INT-01) with coverage maintained (INT-02)
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-health-package/35-CONTEXT.md
@.planning/phases/35-health-package/35-RESEARCH.md
@.planning/phases/35-health-package/35-01-SUMMARY.md
@.planning/phases/35-health-package/35-02-SUMMARY.md

Files to migrate:
@health/manager.go
@health/handlers.go
@health/writer.go
@health/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate health/manager.go to use healthx</name>
  <files>
    - health/manager.go
    - health/manager_test.go
  </files>
  <action>
Update health/manager.go to use internal healthx package instead of alexliesenfeld/health (HLT-12):

1. **Update imports**:
   - Remove: `"github.com/alexliesenfeld/health"`
   - Add: `"github.com/petabytecl/gaz/healthx"`

2. **Update Manager struct**:
   ```go
   type Manager struct {
       mu sync.Mutex

       livenessChecks  []healthx.Check  // was health.Check
       readinessChecks []healthx.Check
       startupChecks   []healthx.Check
   }
   ```

3. **Update check registration methods**:
   - AddLivenessCheck: store `healthx.Check{Name: name, Check: check, Critical: true}`
   - AddReadinessCheck: store `healthx.Check{Name: name, Check: check, Critical: true}`
   - AddStartupCheck: store `healthx.Check{Name: name, Check: check, Critical: true}`
   - Set Critical: true for all checks (default behavior matches current)

4. **Update checker builder methods**:
   - LivenessChecker: return `healthx.NewChecker(opts...)` using `healthx.WithCheck(c)` for each check
   - ReadinessChecker: same pattern
   - StartupChecker: same pattern
   - Change return type from `health.Checker` to `healthx.Checker`
   - Change options type from `health.CheckerOption` to `healthx.CheckerOption`

5. **Update manager_test.go**:
   - Update any imports or type references
   - Tests should pass without logic changes (API compatible)

Key pattern change:
```go
// Before
m.livenessChecks = append(m.livenessChecks, health.Check{
    Name:  name,
    Check: check,
})

// After
m.livenessChecks = append(m.livenessChecks, healthx.Check{
    Name:     name,
    Check:    check,
    Critical: true,  // Matches existing behavior
})
```

Note: The healthx.Check struct has a Critical field that defaults to false in Go, so explicitly set it to true to match the current behavior where all checks affect overall status.
  </action>
  <verify>
```bash
# Package compiles
go build ./health/...

# Manager tests pass
go test ./health/... -v -run "TestManager"

# No import of alexliesenfeld/health in manager.go
grep -r "alexliesenfeld" health/manager.go || echo "OK: No alexliesenfeld import"
```
  </verify>
  <done>
- health/manager.go imports healthx instead of alexliesenfeld/health
- Manager stores healthx.Check slices
- Checker builder methods return healthx.Checker
- All manager tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate health/handlers.go and health/writer.go to use healthx</name>
  <files>
    - health/handlers.go
    - health/handlers_test.go
    - health/writer.go
    - health/writer_test.go
  </files>
  <action>
Update handlers and writer to use healthx:

1. **health/handlers.go** - Update to use healthx.NewHandler:
   ```go
   // Update imports
   // Remove: "github.com/alexliesenfeld/health"
   // Add: "github.com/petabytecl/gaz/healthx"

   // NewLivenessHandler creates an http.Handler for liveness probes.
   // It returns 200 OK even on failure (liveness pattern).
   func (m *Manager) NewLivenessHandler() http.Handler {
       checker := m.LivenessChecker()
       return healthx.NewHandler(checker,
           healthx.WithResultWriter(healthx.NewIETFResultWriter()),
           healthx.WithStatusCodeUp(http.StatusOK),
           healthx.WithStatusCodeDown(http.StatusOK),  // 200 on failure per HLT-10
       )
   }

   // NewReadinessHandler creates an http.Handler for readiness probes.
   func (m *Manager) NewReadinessHandler() http.Handler {
       checker := m.ReadinessChecker()
       return healthx.NewHandler(checker,
           healthx.WithResultWriter(healthx.NewIETFResultWriter()),
           healthx.WithStatusCodeUp(http.StatusOK),
           healthx.WithStatusCodeDown(http.StatusServiceUnavailable),
       )
   }

   // NewStartupHandler creates an http.Handler for startup probes.
   func (m *Manager) NewStartupHandler() http.Handler {
       checker := m.StartupChecker()
       return healthx.NewHandler(checker,
           healthx.WithResultWriter(healthx.NewIETFResultWriter()),
           healthx.WithStatusCodeUp(http.StatusOK),
           healthx.WithStatusCodeDown(http.StatusServiceUnavailable),
       )
   }
   ```

2. **health/writer.go** - Two options:
   
   Option A (Preferred): Keep as thin wrapper that delegates to healthx
   ```go
   // IETFResultWriter delegates to healthx.IETFResultWriter.
   // Kept for backward compatibility.
   type IETFResultWriter = healthx.IETFResultWriter

   // NewIETFResultWriter creates a new IETFResultWriter.
   func NewIETFResultWriter() *healthx.IETFResultWriter {
       return healthx.NewIETFResultWriter()
   }
   ```

   Option B: Remove health/writer.go entirely if not used externally
   - Check if IETFResultWriter is exported and used outside the package
   - If only used internally by handlers, can use healthx directly

   Choose Option A for backward compatibility (existing code may reference health.IETFResultWriter).

3. **Update test files**:
   - health/handlers_test.go: Update imports, tests should pass
   - health/writer_test.go: Update to use healthx types or test the wrapper
  </action>
  <verify>
```bash
# Package compiles
go build ./health/...

# Handler tests pass
go test ./health/... -v -run "TestHandler"

# Writer tests pass
go test ./health/... -v -run "TestWriter|TestIETF"

# No import of alexliesenfeld/health in handlers.go
grep -r "alexliesenfeld" health/handlers.go || echo "OK: No alexliesenfeld import"

# No import of alexliesenfeld/health in writer.go
grep -r "alexliesenfeld" health/writer.go || echo "OK: No alexliesenfeld import"
```
  </verify>
  <done>
- health/handlers.go uses healthx.NewHandler
- health/writer.go uses healthx types (wrapper or alias)
- All handler and writer tests pass
- No alexliesenfeld/health imports remain
  </done>
</task>

<task type="auto">
  <name>Task 3: Remove alexliesenfeld/health dependency and final verification</name>
  <files>
    - go.mod
    - go.sum
  </files>
  <action>
Remove the external dependency and verify everything works (HLT-13, INT-01, INT-02, INT-03):

1. **Verify no remaining imports**:
   ```bash
   # Should return nothing
   grep -r "alexliesenfeld" --include="*.go" .
   ```

2. **Remove dependency from go.mod**:
   ```bash
   go mod tidy
   ```
   This will automatically remove alexliesenfeld/health if it's no longer imported.

3. **Verify dependency removed**:
   ```bash
   # Should not find alexliesenfeld
   grep "alexliesenfeld" go.mod || echo "OK: Dependency removed"
   cat go.mod | grep -v "//" | grep alexliesenfeld || echo "OK: Not in go.mod"
   ```

4. **Run full test suite (INT-01)**:
   ```bash
   go test ./... -race
   ```

5. **Check test coverage (INT-02)**:
   ```bash
   go test ./... -coverprofile=coverage.out
   go tool cover -func=coverage.out | tail -1
   # Should show >= 90% coverage
   ```

6. **Verify no import cycles (INT-03)**:
   ```bash
   go build ./...
   # If this succeeds, no import cycles exist
   ```

7. **Verify healthx is independent**:
   ```bash
   # healthx should have no internal gaz dependencies (except stdlib)
   go list -f '{{.Imports}}' ./healthx/... | grep -v "github.com/petabytecl/gaz" || echo "OK: healthx is independent"
   ```
  </action>
  <verify>
```bash
# Full test suite passes
go test ./... -race -v

# Coverage check
go test ./... -coverprofile=coverage.out
go tool cover -func=coverage.out | tail -1

# No alexliesenfeld dependency
grep "alexliesenfeld" go.mod && exit 1 || echo "OK: Dependency removed"

# No import cycles
go build ./...
```
  </verify>
  <done>
- alexliesenfeld/health removed from go.mod
- All tests pass (go test ./... succeeds)
- Test coverage >= 90%
- No import cycles (go build ./... succeeds)
- healthx/ has no internal gaz dependencies
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full test suite with coverage
go test ./... -cover -race

# Verify alexliesenfeld/health is gone
grep -r "alexliesenfeld" --include="*.go" . && exit 1 || echo "OK: No alexliesenfeld imports"
grep "alexliesenfeld" go.mod && exit 1 || echo "OK: Not in go.mod"

# Verify coverage
go test ./... -coverprofile=coverage.out
go tool cover -func=coverage.out | tail -1
# Must show >= 90%

# Verify no import cycles
go build ./...

# List dependencies - should show one fewer external dep
go list -m all | wc -l
```
</verification>

<success_criteria>
- [ ] health/manager.go imports healthx instead of alexliesenfeld/health (HLT-12)
- [ ] health/handlers.go uses healthx.NewHandler
- [ ] health/writer.go uses healthx types
- [ ] No remaining alexliesenfeld/health imports in any .go file
- [ ] alexliesenfeld/health removed from go.mod (HLT-13)
- [ ] All existing tests pass (INT-01): `go test ./...` succeeds
- [ ] Test coverage maintained at 90%+ (INT-02)
- [ ] No import cycles (INT-03): `go build ./...` succeeds
- [ ] healthx/ package has no internal gaz dependencies (independent)
</success_criteria>

<output>
After completion, create `.planning/phases/35-health-package/35-03-SUMMARY.md`
</output>
