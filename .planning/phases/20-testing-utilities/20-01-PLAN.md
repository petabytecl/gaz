---
phase: 20-testing-utilities
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - gaztest/doc.go
  - gaztest/builder.go
  - gaztest/app.go
  - gaztest/gaztest_test.go
autonomous: true

must_haves:
  truths:
    - "gaztest.New(t) creates a Builder with 5s default timeout"
    - "Builder.WithTimeout(d) overrides the default timeout"
    - "Builder.Replace(instance) queues a mock for type replacement"
    - "Builder.Build() returns (*App, error) with t.Cleanup() registered"
    - "App.RequireStart() starts app or calls t.Fatal()"
    - "App.RequireStop() stops app or calls t.Fatal()"
  artifacts:
    - path: "gaztest/doc.go"
      provides: "Package documentation"
      contains: "Package gaztest"
    - path: "gaztest/builder.go"
      provides: "TB interface, Builder struct, New, WithTimeout, Replace, Build"
      exports: ["TB", "Builder", "New"]
    - path: "gaztest/app.go"
      provides: "App wrapper with RequireStart, RequireStop"
      exports: ["App"]
    - path: "gaztest/gaztest_test.go"
      provides: "TDD tests for all requirements"
      contains: "func Test"
  key_links:
    - from: "gaztest/builder.go"
      to: "gaz.New()"
      via: "Build() creates gaz.App with test timeouts"
      pattern: "gaz\\.New\\("
    - from: "gaztest/builder.go"
      to: "di.TypeNameReflect()"
      via: "Replace() uses reflection for type inference"
      pattern: "di\\.TypeNameReflect"
    - from: "gaztest/app.go"
      to: "t.Cleanup()"
      via: "Build() registers automatic cleanup"
      pattern: "tb\\.Cleanup"
---

<objective>
Implement the `gaztest` package using TDD, providing test-friendly utilities for gaz applications.

Purpose: Enable easy testing of DI applications with automatic cleanup, mock injection, and assertion methods.
Output: Complete `gaztest` package with Builder API, App wrapper, and comprehensive tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-testing-utilities/20-CONTEXT.md
@.planning/phases/20-testing-utilities/20-RESEARCH.md

# Existing code patterns
@app.go (gaz.New, WithShutdownTimeout, WithPerHookTimeout)
@di/types.go (TypeNameReflect)
@di/service.go (NewInstanceServiceAny)
@di/container.go (Container, HasService, Register)
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for gaztest package</name>
  <files>gaztest/gaztest_test.go</files>
  <action>
Create `gaztest/gaztest_test.go` with tests that exercise all requirements (TEST-01 through TEST-05).

Tests should cover:

1. **TestNew_DefaultTimeout** - Verify `New(t)` creates Builder with 5s timeout
2. **TestBuilder_WithTimeout** - Verify timeout override works
3. **TestBuilder_Replace** - Verify Replace queues mock for type replacement
4. **TestBuilder_Build** - Verify Build returns (*App, error) and registers cleanup
5. **TestApp_RequireStart** - Verify RequireStart starts app or fails test
6. **TestApp_RequireStop** - Verify RequireStop stops app or fails test
7. **TestApp_AutoCleanup** - Verify t.Cleanup() stops app even if test doesn't
8. **TestBuilder_ReplaceTypeNotRegistered** - Verify Replace with unregistered type errors on Build()

Test structure pattern:
```go
package gaztest_test

import (
    "testing"
    "time"
    
    "github.com/petabytecl/gaz"
    "github.com/petabytecl/gaz/di"
    "github.com/petabytecl/gaz/gaztest"
    "github.com/stretchr/testify/require"
)

// Mock types for testing
type Database interface {
    Query() string
}

type MockDatabase struct{}
func (m *MockDatabase) Query() string { return "mock" }

func TestNew_DefaultTimeout(t *testing.T) {
    // Test that New(t) creates a builder
    builder := gaztest.New(t)
    require.NotNil(t, builder)
}
```

Run tests - they should fail because the package doesn't exist yet.
  </action>
  <verify>`go test ./gaztest/...` fails with "package not found" or similar (expected - RED phase)</verify>
  <done>Test file exists with comprehensive tests for all 5 requirements; tests fail because implementation doesn't exist</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement gaztest package</name>
  <files>gaztest/doc.go, gaztest/builder.go, gaztest/app.go</files>
  <action>
Implement the gaztest package to make all tests pass.

**gaztest/doc.go:**
```go
// Package gaztest provides test utilities for gaz applications.
// It enables easy testing with automatic cleanup, mock injection,
// and assertion methods that fail tests on error.
//
// Basic usage:
//
//	func TestMyService(t *testing.T) {
//	    app, err := gaztest.New(t).Build()
//	    require.NoError(t, err)
//	    
//	    app.RequireStart()
//	    defer app.RequireStop()
//	    
//	    // ... test logic
//	}
//
// With mock replacement:
//
//	func TestWithMock(t *testing.T) {
//	    mock := &MockDatabase{}
//	    app, err := gaztest.New(t).
//	        Replace(mock).
//	        Build()
//	    require.NoError(t, err)
//	    
//	    app.RequireStart()
//	    // ... test logic using mock
//	}
package gaztest
```

**gaztest/builder.go:**

Key implementation details:
- `TB` interface: subset of `testing.TB` (Logf, Errorf, Fatalf, FailNow, Cleanup, Helper)
- `Builder` struct: stores tb, timeout (default 5s), replacements slice, errors slice
- `New(tb TB) *Builder`: creates builder with default timeout
- `WithTimeout(d time.Duration) *Builder`: sets custom timeout
- `Replace(instance any) *Builder`: queues replacement using `di.TypeNameReflect(reflect.TypeOf(instance))`
- `Build() (*App, error)`: creates gaz.App with test timeouts, applies replacements, registers t.Cleanup()

Replacement logic in Build():
1. Create `gaz.New(gaz.WithShutdownTimeout(timeout), gaz.WithPerHookTimeout(timeout))`
2. For each replacement, check if type is registered: if not, return error
3. Use `di.NewInstanceServiceAny()` to create replacement service and `container.Register()` to override
4. Call `app.Build()` to validate
5. Register `tb.Cleanup()` to stop app automatically
6. Return wrapped App

**gaztest/app.go:**

Key implementation details:
- `App` struct: embeds `*gaz.App`, stores tb, timeout, stopped bool (for idempotency)
- `RequireStart() *App`: calls `tb.Helper()`, creates context with timeout, calls `app.Start(ctx)`, on error calls `tb.Fatalf()`
- `RequireStop()`: calls `tb.Helper()`, if already stopped return, creates context with timeout, calls `app.Stop(ctx)`, on error calls `tb.Fatalf()`, sets stopped=true

Use `context.WithTimeout(context.Background(), timeout)` for both start and stop operations.
  </action>
  <verify>`go test ./gaztest/...` passes all tests (GREEN phase)</verify>
  <done>All tests pass; gaztest package complete with Builder API and App wrapper</done>
</task>

<task type="auto">
  <name>Task 3: Verify and commit</name>
  <files>gaztest/</files>
  <action>
1. Run full test suite to ensure no regressions: `go test ./...`
2. Run linter: `make lint` or `golangci-lint run ./gaztest/...`
3. Fix any linter issues
4. Verify the package compiles and exports are correct

If any issues found, fix them and re-run tests.

Commit with message:
```
feat(gaztest): add test utilities package [TDD]

Implements TEST-01 through TEST-05:
- gaztest.New(t) creates test app builder with automatic cleanup
- Builder.WithTimeout() for custom timeout (default 5s)
- Builder.Replace() for mock injection with type inference
- App.RequireStart()/RequireStop() with t.Fatal() on error
- Automatic cleanup via t.Cleanup() registered at Build()
```
  </action>
  <verify>`go test ./...` passes; `make lint` passes; commit created</verify>
  <done>Package complete, tested, linted, and committed</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go test ./gaztest/...` - all tests pass
2. `go build ./gaztest/...` - package compiles
3. `make lint` - no linter errors
4. Git log shows TDD commit with proper message
</verification>

<success_criteria>
- [ ] TEST-01: `gaztest.New(t)` creates test app with automatic cleanup via `t.Cleanup()`
- [ ] TEST-02: `app.RequireStart()` starts app or fails test with `t.Fatal()`
- [ ] TEST-03: `app.RequireStop()` stops app or fails test with `t.Fatal()`
- [ ] TEST-04: Test apps use shorter timeouts (5s default)
- [ ] TEST-05: `app.Replace(instance)` swaps dependency for testing
- [ ] All tests pass
- [ ] Package properly documented
</success_criteria>

<output>
After completion, create `.planning/phases/20-testing-utilities/20-01-SUMMARY.md`
</output>
