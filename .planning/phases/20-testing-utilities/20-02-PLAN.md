---
phase: 20-testing-utilities
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - gaztest/gaztest_test.go
  - gaztest/example_test.go
autonomous: true

must_haves:
  truths:
    - "Replace() with registered service type swaps the implementation"
    - "Replaced mock is resolved when container resolves the type"
    - "Double-stop is safe (idempotent)"
    - "Cleanup runs even if test panics"
    - "Example tests document common usage patterns"
  artifacts:
    - path: "gaztest/gaztest_test.go"
      provides: "Integration tests for Replace with real services"
      contains: "TestReplace_SwapsImplementation"
    - path: "gaztest/example_test.go"
      provides: "Runnable example tests for documentation"
      contains: "func Example"
  key_links:
    - from: "gaztest/gaztest_test.go"
      to: "gaz.For[T]().Provider()"
      via: "Integration tests register real services"
      pattern: "gaz\\.For\\["
    - from: "gaztest/gaztest_test.go"
      to: "di.Resolve[T]()"
      via: "Tests verify mock is resolved"
      pattern: "di\\.Resolve\\["
---

<objective>
Add integration tests and examples to verify gaztest works with real gaz.App service registration.

Purpose: Ensure Replace() correctly swaps implementations and document usage patterns.
Output: Comprehensive integration tests and example tests for godoc.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-testing-utilities/20-01-SUMMARY.md

# Existing code patterns
@app.go
@di/registration.go
@di/resolution.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add integration tests for Replace with real services</name>
  <files>gaztest/gaztest_test.go</files>
  <action>
Add integration tests to `gaztest/gaztest_test.go` that verify Replace() works with actual gaz.App service registration.

Test scenarios to add:

1. **TestReplace_SwapsImplementation**
   - Register a real service: `gaz.For[Database](app.Container()).Provider(NewRealDatabase)`
   - Replace with mock: `builder.Replace(&MockDatabase{})`
   - Build and start app
   - Resolve the type: `di.Resolve[Database](app.Container())`
   - Assert the mock is returned, not the real implementation

2. **TestReplace_MultipleServices**
   - Register multiple services
   - Replace some but not all
   - Verify replaced ones use mocks, others use real implementations

3. **TestApp_DoubleStop_Idempotent**
   - Build and start app
   - Call RequireStop() twice
   - Verify no panic or error (idempotent)

4. **TestCleanup_RunsOnPanic** (if feasible)
   - Create a test that tracks cleanup execution
   - Verify cleanup runs even if test would panic (using recover)

5. **TestBuilder_Options** (optional)
   - Test that gaz.Options can be passed through if API supports it

Example test structure:
```go
func TestReplace_SwapsImplementation(t *testing.T) {
    // Create a real provider that would be used in production
    realDB := &RealDatabase{connected: true}
    mockDB := &MockDatabase{}
    
    // Build test app with replacement
    app, err := gaztest.New(t).
        // First, we need services registered - use a helper
        Replace(mockDB).
        Build()
    
    // Note: Replace only works for types already in container
    // Need to adjust test to register service first via app.Container()
    // before calling Build() on builder
}
```

**Important:** The Replace() API works by swapping a type that's already registered. The test needs to:
1. Get the underlying gaz.App from the builder (or builder needs to accept options/providers)
2. Or: Use a WithProvider/WithOptions method on builder if we add one

If builder doesn't support registering providers, adjust tests to work within current API constraints. Check 20-01-SUMMARY.md to see actual implementation.

Alternative approach if Replace requires pre-registered services:
- Document that services must be registered on the underlying container before Build()
- Test using app.Container() access after Build()
  </action>
  <verify>`go test ./gaztest/...` passes including new integration tests</verify>
  <done>Integration tests verify Replace() swaps real implementations with mocks</done>
</task>

<task type="auto">
  <name>Task 2: Add example tests for godoc documentation</name>
  <files>gaztest/example_test.go</files>
  <action>
Create `gaztest/example_test.go` with runnable example tests that appear in godoc.

Examples to create:

1. **Example** (basic usage)
   - Simple New(t).Build(), RequireStart, RequireStop pattern

2. **Example_withTimeout**
   - Show WithTimeout() usage

3. **Example_withMock** (if Replace supports it)
   - Show mock injection pattern

Example structure:
```go
package gaztest_test

import (
    "testing"
    "time"
    
    "github.com/petabytecl/gaz/gaztest"
)

func Example() {
    // In a real test, use testing.T from the test function
    // This example shows the pattern
    
    // Create test app with automatic cleanup
    // app, err := gaztest.New(t).Build()
    // if err != nil {
    //     t.Fatal(err)
    // }
    
    // Start the app
    // app.RequireStart()
    
    // ... run test assertions ...
    
    // Stop is optional - cleanup will run automatically
    // app.RequireStop()
    
    // Output:
}

func Example_withTimeout() {
    // Override default 5s timeout for slow services
    // app, err := gaztest.New(t).
    //     WithTimeout(10 * time.Second).
    //     Build()
    
    // Output:
}
```

Note: Example tests that use testing.T can't be truly runnable examples. Instead, create examples that compile and document the API, even if Output: is empty.

Alternative: Create a helper test function that demonstrates usage:
```go
func TestExample_BasicUsage(t *testing.T) {
    app, err := gaztest.New(t).Build()
    if err != nil {
        t.Fatal(err)
    }
    
    app.RequireStart()
    defer app.RequireStop()
    
    // Your test logic here
    t.Log("App started successfully")
}
```
  </action>
  <verify>`go test ./gaztest/... -v` shows example tests passing</verify>
  <done>Example tests exist and pass; godoc shows usage patterns</done>
</task>

<task type="auto">
  <name>Task 3: Final verification and commit</name>
  <files>gaztest/</files>
  <action>
1. Run full test suite: `go test ./...`
2. Run linter: `make lint`
3. Generate godoc preview (optional): `go doc -all ./gaztest`
4. Verify all exports are properly documented

Commit with message:
```
test(gaztest): add integration tests and examples

- Integration tests for Replace() with real service swapping
- Double-stop idempotency verification
- Example tests for godoc documentation
- Complete test coverage for gaztest package
```
  </action>
  <verify>`go test ./...` passes; `make lint` passes; commit created</verify>
  <done>Integration tests and examples complete; package fully tested</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go test ./gaztest/... -v` - all tests pass with verbose output
2. `go test -cover ./gaztest/...` - reasonable coverage (>80%)
3. `make lint` - no linter errors
4. Git log shows integration test commit
</verification>

<success_criteria>
- [ ] Integration tests verify Replace() works with real services
- [ ] Double-stop is tested and works (idempotent)
- [ ] Example tests document common usage patterns
- [ ] All tests pass
- [ ] Good test coverage
</success_criteria>

<output>
After completion, create `.planning/phases/20-testing-utilities/20-02-SUMMARY.md`
</output>
