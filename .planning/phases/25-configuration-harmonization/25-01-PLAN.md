---
phase: 25-configuration-harmonization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config/errors.go
  - config/viper/backend.go
  - provider_config.go
autonomous: true

must_haves:
  truths:
    - "pv.UnmarshalKey('redis', &cfg) populates cfg struct from redis.* config keys"
    - "pv.Unmarshal(&cfg) populates cfg struct from all config keys"
    - "Struct fields use gaz tag for key mapping (not mapstructure tag)"
    - "Missing namespace returns config.ErrKeyNotFound sentinel error"
  artifacts:
    - path: "config/errors.go"
      provides: "ErrKeyNotFound sentinel error"
      contains: "ErrKeyNotFound"
    - path: "config/viper/backend.go"
      provides: "UnmarshalWithGazTag and UnmarshalKeyWithGazTag methods"
      exports: ["UnmarshalWithGazTag", "UnmarshalKeyWithGazTag"]
    - path: "provider_config.go"
      provides: "ProviderValues.Unmarshal and UnmarshalKey methods"
      contains: "func (pv *ProviderValues) UnmarshalKey"
  key_links:
    - from: "provider_config.go"
      to: "config/viper/backend.go"
      via: "type assertion for UnmarshalWithGazTag interface"
      pattern: "UnmarshalWithGazTag|UnmarshalKeyWithGazTag"
    - from: "provider_config.go"
      to: "config/errors.go"
      via: "returning wrapped ErrKeyNotFound"
      pattern: "ErrKeyNotFound"
---

<objective>
Add struct-based config unmarshaling to ProviderValues with custom `gaz` tag support.

Purpose: Enable type-safe, module-isolated configuration access via struct unmarshaling. Users can now do `pv.UnmarshalKey("redis", &cfg)` to populate a config struct from namespaced config keys.

Output: Working Unmarshal and UnmarshalKey methods on ProviderValues that use `gaz` struct tags for field mapping.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-configuration-harmonization/25-CONTEXT.md
@.planning/phases/25-configuration-harmonization/25-RESEARCH.md

@config/errors.go
@config/backend.go
@config/viper/backend.go
@provider_config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ErrKeyNotFound sentinel and viper gaz tag methods</name>
  <files>config/errors.go, config/viper/backend.go</files>
  <action>
1. In config/errors.go, add sentinel error after ErrConfigValidation:
   ```go
   // ErrKeyNotFound is returned when a config key/namespace doesn't exist.
   // Use errors.Is(err, ErrKeyNotFound) to check for missing keys.
   var ErrKeyNotFound = errors.New("config: key not found")
   ```

2. In config/viper/backend.go, add two new methods that use the gaz tag:
   ```go
   import "github.com/go-viper/mapstructure/v2"
   
   // gazDecoderOption configures mapstructure to use "gaz" struct tags.
   func gazDecoderOption(dc *mapstructure.DecoderConfig) {
       dc.TagName = "gaz"
   }
   
   // UnmarshalWithGazTag unmarshals entire config using gaz struct tags.
   func (b *Backend) UnmarshalWithGazTag(target any) error {
       return b.v.Unmarshal(target, gazDecoderOption)
   }
   
   // UnmarshalKeyWithGazTag unmarshals a specific key using gaz struct tags.
   func (b *Backend) UnmarshalKeyWithGazTag(key string, target any) error {
       return b.v.UnmarshalKey(key, target, gazDecoderOption)
   }
   
   // HasKey returns true if the key exists in config (either directly or as a parent namespace).
   func (b *Backend) HasKey(key string) bool {
       if b.v.IsSet(key) {
           return true
       }
       // Check if it's a namespace with children (viper.Sub returns non-nil)
       return b.v.Sub(key) != nil
   }
   ```

Note: The `gazDecoderOption` function is a `viper.DecoderConfigOption` that configures mapstructure's decoder to use the "gaz" tag instead of the default "mapstructure" tag. This is passed to viper's Unmarshal methods which accept variadic DecoderConfigOption.
  </action>
  <verify>
    - `go build ./config/...` compiles without errors
    - `grep -n "ErrKeyNotFound" config/errors.go` shows the new sentinel
    - `grep -n "UnmarshalKeyWithGazTag" config/viper/backend.go` shows the new method
  </verify>
  <done>
    - config.ErrKeyNotFound sentinel exists
    - Backend has UnmarshalWithGazTag, UnmarshalKeyWithGazTag, and HasKey methods
    - Package compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Unmarshal methods to ProviderValues</name>
  <files>provider_config.go</files>
  <action>
Add Unmarshal and UnmarshalKey methods to ProviderValues that:
1. Check if key exists using HasKey (for UnmarshalKey)
2. Return wrapped ErrKeyNotFound if namespace doesn't exist
3. Delegate to viper backend's gaz tag methods via type assertion
4. Fall back to standard Backend.UnmarshalKey if gaz tag methods not available

```go
import (
    "fmt"
    "github.com/petabytecl/gaz/config"
)

// gazUnmarshaler is implemented by backends that support gaz struct tags.
type gazUnmarshaler interface {
    UnmarshalWithGazTag(target any) error
    UnmarshalKeyWithGazTag(key string, target any) error
    HasKey(key string) bool
}

// Unmarshal unmarshals the entire config into target struct.
// Uses "gaz" struct tags for field mapping.
//
// Example:
//
//     type AppConfig struct {
//         Redis RedisConfig `gaz:"redis"`
//         DB    DBConfig    `gaz:"database"`
//     }
//
//     var cfg AppConfig
//     if err := pv.Unmarshal(&cfg); err != nil {
//         return err
//     }
func (pv *ProviderValues) Unmarshal(target any) error {
    if gu, ok := pv.backend.(gazUnmarshaler); ok {
        return gu.UnmarshalWithGazTag(target)
    }
    // Fallback: use standard Unmarshal (uses mapstructure tag)
    return pv.backend.Unmarshal(target)
}

// UnmarshalKey unmarshals config at the given key/namespace into target struct.
// Uses "gaz" struct tags for field mapping.
// Returns config.ErrKeyNotFound if the key/namespace doesn't exist.
//
// Example:
//
//     type RedisConfig struct {
//         Host string `gaz:"host"`
//         Port int    `gaz:"port"`
//     }
//
//     var cfg RedisConfig
//     if err := pv.UnmarshalKey("redis", &cfg); err != nil {
//         if errors.Is(err, config.ErrKeyNotFound) {
//             // Handle missing namespace
//         }
//         return err
//     }
func (pv *ProviderValues) UnmarshalKey(key string, target any) error {
    if gu, ok := pv.backend.(gazUnmarshaler); ok {
        if !gu.HasKey(key) {
            return fmt.Errorf("%w: %s", config.ErrKeyNotFound, key)
        }
        return gu.UnmarshalKeyWithGazTag(key, target)
    }
    // Fallback: use standard UnmarshalKey (uses mapstructure tag)
    // Note: no HasKey check in fallback since Backend doesn't have it
    return pv.backend.UnmarshalKey(key, target)
}
```

Add the import for "fmt" if not already present. The gazUnmarshaler interface is defined locally in this file (not exported) because it's an implementation detail for type-asserting the backend.
  </action>
  <verify>
    - `go build ./...` compiles without errors
    - `grep -n "func (pv \*ProviderValues) Unmarshal" provider_config.go` shows both methods
    - `grep -n "ErrKeyNotFound" provider_config.go` shows error handling
  </verify>
  <done>
    - ProviderValues has Unmarshal(target any) error method
    - ProviderValues has UnmarshalKey(key string, target any) error method
    - Methods use gaz tag via type assertion
    - Missing key returns wrapped ErrKeyNotFound
    - Full package compiles
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./...` — Full project compiles
2. `go test ./config/...` — Existing config tests pass
3. `go test ./...` — All existing tests pass (no regressions)
</verification>

<success_criteria>
1. config.ErrKeyNotFound sentinel error exists and is exported
2. viper.Backend has UnmarshalWithGazTag, UnmarshalKeyWithGazTag, HasKey methods
3. ProviderValues.Unmarshal populates struct using gaz tags
4. ProviderValues.UnmarshalKey populates struct from namespace using gaz tags
5. UnmarshalKey returns ErrKeyNotFound for missing namespaces
6. All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/25-configuration-harmonization/25-01-SUMMARY.md`
</output>
