---
phase: 25-configuration-harmonization
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - config/validation.go
  - provider_config_test.go
autonomous: true

must_haves:
  truths:
    - "Validation error messages show gaz tag field names (not Go field names)"
    - "Unmarshal with gaz tags populates nested structs correctly"
    - "UnmarshalKey returns ErrKeyNotFound for non-existent namespace"
    - "Partial config fill leaves unset struct fields at zero value"
  artifacts:
    - path: "config/validation.go"
      provides: "gaz tag priority in RegisterTagNameFunc"
      contains: 'fld.Tag.Get("gaz")'
    - path: "provider_config_test.go"
      provides: "Unmarshal and UnmarshalKey tests"
      contains: "TestProviderValues_Unmarshal"
  key_links:
    - from: "config/validation.go"
      to: "validator"
      via: "RegisterTagNameFunc with gaz tag priority"
      pattern: 'Tag\\.Get\\("gaz"\\)'
---

<objective>
Integrate gaz tag with validator and add comprehensive tests for config unmarshaling.

Purpose: Ensure validation error messages reference gaz tag field names for consistency, and verify all Unmarshal functionality works correctly with thorough test coverage.

Output: Updated validator tag name resolution and comprehensive test coverage for ProviderValues.Unmarshal and UnmarshalKey.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-configuration-harmonization/25-CONTEXT.md
@.planning/phases/25-configuration-harmonization/25-RESEARCH.md

@config/validation.go
@provider_config.go
@provider_config_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add gaz tag priority to validator RegisterTagNameFunc</name>
  <files>config/validation.go</files>
  <action>
Update the RegisterTagNameFunc in newConfigValidator() to check gaz tag first, then fall back to mapstructure, json, and finally field name.

Replace the current RegisterTagNameFunc call:
```go
// Register tag name function to use gaz tags for field names in error messages.
// Priority: gaz -> mapstructure -> json -> Go field name.
// This ensures validation errors reference the config key name users expect.
v.RegisterTagNameFunc(func(fld reflect.StructField) string {
    // Try gaz tag first (our custom config tag)
    name, _, _ := strings.Cut(fld.Tag.Get("gaz"), ",")
    if name != "-" && name != "" {
        return name
    }
    // Fall back to mapstructure tag (for compatibility with older code)
    name, _, _ = strings.Cut(fld.Tag.Get("mapstructure"), ",")
    if name != "-" && name != "" {
        return name
    }
    // Fall back to json tag
    name, _, _ = strings.Cut(fld.Tag.Get("json"), ",")
    if name != "-" && name != "" {
        return name
    }
    return fld.Name
})
```

Update the comment at line 22-23 to reflect the new priority order.
  </action>
  <verify>
    - `go build ./config/...` compiles without errors
    - `grep -n 'Tag.Get("gaz")' config/validation.go` shows the gaz tag check
    - `go test ./config/...` — existing validation tests pass
  </verify>
  <done>
    - RegisterTagNameFunc checks gaz tag before mapstructure tag
    - Package compiles and existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for Unmarshal functionality</name>
  <files>provider_config_test.go</files>
  <action>
Add test cases for ProviderValues.Unmarshal and UnmarshalKey. Add these tests after the existing provider config tests in provider_config_test.go:

```go
func TestProviderValues_UnmarshalKey(t *testing.T) {
    tests := []struct {
        name        string
        configSetup func(backend config.Backend)
        key         string
        target      any
        wantErr     bool
        errContains string
        validate    func(t *testing.T, target any)
    }{
        {
            name: "unmarshal simple struct with gaz tags",
            configSetup: func(b config.Backend) {
                b.Set("redis.host", "localhost")
                b.Set("redis.port", 6379)
            },
            key: "redis",
            target: &struct {
                Host string `gaz:"host"`
                Port int    `gaz:"port"`
            }{},
            wantErr: false,
            validate: func(t *testing.T, target any) {
                cfg := target.(*struct {
                    Host string `gaz:"host"`
                    Port int    `gaz:"port"`
                })
                assert.Equal(t, "localhost", cfg.Host)
                assert.Equal(t, 6379, cfg.Port)
            },
        },
        {
            name: "unmarshal nested struct with gaz tags",
            configSetup: func(b config.Backend) {
                b.Set("database.pool.max", 10)
                b.Set("database.pool.idle", 5)
                b.Set("database.host", "db.local")
            },
            key: "database",
            target: &struct {
                Host string `gaz:"host"`
                Pool struct {
                    Max  int `gaz:"max"`
                    Idle int `gaz:"idle"`
                } `gaz:"pool"`
            }{},
            wantErr: false,
            validate: func(t *testing.T, target any) {
                cfg := target.(*struct {
                    Host string `gaz:"host"`
                    Pool struct {
                        Max  int `gaz:"max"`
                        Idle int `gaz:"idle"`
                    } `gaz:"pool"`
                })
                assert.Equal(t, "db.local", cfg.Host)
                assert.Equal(t, 10, cfg.Pool.Max)
                assert.Equal(t, 5, cfg.Pool.Idle)
            },
        },
        {
            name:        "missing namespace returns ErrKeyNotFound",
            configSetup: func(b config.Backend) {},
            key:         "nonexistent",
            target:      &struct{ Host string `gaz:"host"` }{},
            wantErr:     true,
            errContains: "key not found",
        },
        {
            name: "partial fill leaves unset fields at zero value",
            configSetup: func(b config.Backend) {
                b.Set("partial.host", "myhost")
                // port not set
            },
            key: "partial",
            target: &struct {
                Host string `gaz:"host"`
                Port int    `gaz:"port"`
            }{},
            wantErr: false,
            validate: func(t *testing.T, target any) {
                cfg := target.(*struct {
                    Host string `gaz:"host"`
                    Port int    `gaz:"port"`
                })
                assert.Equal(t, "myhost", cfg.Host)
                assert.Equal(t, 0, cfg.Port) // zero value
            },
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            app := gaz.NewApp(gaz.WithName("test"))
            tt.configSetup(app.ConfigManager().Backend())

            err := app.Build(context.Background())
            require.NoError(t, err)

            pv := gaz.MustResolve[*gaz.ProviderValues](app.Container())
            err = pv.UnmarshalKey(tt.key, tt.target)

            if tt.wantErr {
                require.Error(t, err)
                if tt.errContains != "" {
                    assert.Contains(t, err.Error(), tt.errContains)
                }
                if tt.errContains == "key not found" {
                    assert.True(t, errors.Is(err, config.ErrKeyNotFound))
                }
                return
            }

            require.NoError(t, err)
            if tt.validate != nil {
                tt.validate(t, tt.target)
            }
        })
    }
}

func TestProviderValues_Unmarshal(t *testing.T) {
    type AppConfig struct {
        Server struct {
            Host string `gaz:"host"`
            Port int    `gaz:"port"`
        } `gaz:"server"`
        Debug bool `gaz:"debug"`
    }

    app := gaz.NewApp(gaz.WithName("test"))
    backend := app.ConfigManager().Backend()
    backend.Set("server.host", "0.0.0.0")
    backend.Set("server.port", 8080)
    backend.Set("debug", true)

    err := app.Build(context.Background())
    require.NoError(t, err)

    pv := gaz.MustResolve[*gaz.ProviderValues](app.Container())

    var cfg AppConfig
    err = pv.Unmarshal(&cfg)
    require.NoError(t, err)

    assert.Equal(t, "0.0.0.0", cfg.Server.Host)
    assert.Equal(t, 8080, cfg.Server.Port)
    assert.True(t, cfg.Debug)
}
```

Add the config import if not already present:
```go
import "github.com/petabytecl/gaz/config"
```

Note: The test uses inline struct types to demonstrate gaz tag behavior. The key thing being tested is that:
1. Fields are populated using gaz tags (not mapstructure)
2. Nested structs work correctly
3. ErrKeyNotFound is returned for missing namespaces
4. Partial fill works (unset fields remain zero)
  </action>
  <verify>
    - `go test -v -run "TestProviderValues_Unmarshal" ./...` — new tests pass
    - `go test ./...` — all tests pass
  </verify>
  <done>
    - TestProviderValues_UnmarshalKey covers: simple struct, nested struct, missing namespace, partial fill
    - TestProviderValues_Unmarshal covers: full config unmarshaling
    - All new tests pass
    - All existing tests pass
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./...` — Full project compiles
2. `go test -v -run "TestProviderValues_Unmarshal" ./...` — New tests pass
3. `go test ./...` — All tests pass (including existing ones)
4. `go test ./config/...` — Config package tests pass
</verification>

<success_criteria>
1. Validator RegisterTagNameFunc checks gaz tag first (before mapstructure)
2. TestProviderValues_UnmarshalKey exists with 4+ test cases
3. TestProviderValues_Unmarshal exists for full config unmarshaling
4. Tests verify gaz tag field mapping works correctly
5. Tests verify ErrKeyNotFound is returned for missing namespaces
6. Tests verify partial fill behavior (unset fields stay zero)
7. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/25-configuration-harmonization/25-02-SUMMARY.md`
</output>
