---
phase: 15-cron
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - cron/wrapper.go
  - cron/scheduler.go
autonomous: true

must_haves:
  truths:
    - "Scheduler wraps robfig/cron with SkipIfStillRunning by default"
    - "Jobs are resolved fresh from container each execution (transient per run)"
    - "Panics in jobs are recovered and logged with stack traces"
    - "Jobs execute with context derived from app context + timeout"
    - "Scheduler implements worker.Worker interface (Name, Start, Stop)"
  artifacts:
    - path: "cron/wrapper.go"
      provides: "DI-aware job wrapper with panic recovery"
      exports: ["NewJobWrapper"]
    - path: "cron/scheduler.go"
      provides: "Scheduler wrapping robfig/cron"
      exports: ["Scheduler", "NewScheduler"]
  key_links:
    - from: "cron/wrapper.go"
      to: "di.Container"
      via: "ResolveByName for transient job resolution"
      pattern: "ResolveByName"
    - from: "cron/scheduler.go"
      to: "robfig/cron.Cron"
      via: "wraps cron.New with options"
      pattern: "cron\\.New"
    - from: "cron/scheduler.go"
      to: "worker.Worker"
      via: "implements interface"
      pattern: "Name.*Start.*Stop"
---

<objective>
Create the Scheduler type wrapping robfig/cron and the DI-aware job wrapper that resolves fresh job instances from container per execution with panic recovery, context/timeout handling, and structured logging.

Purpose: Core cron functionality that bridges gaz's DI container with robfig/cron's scheduling.
Output: Scheduler implementing worker.Worker with DI-aware job execution, panic recovery, and SkipIfStillRunning.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/15-cron/15-CONTEXT.md
@.planning/phases/15-cron/15-RESEARCH.md
@.planning/phases/15-cron/15-01-SUMMARY.md
@cron/job.go
@cron/logger.go
@worker/worker.go
@worker/supervisor.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DI-aware job wrapper with panic recovery</name>
  <files>cron/wrapper.go</files>
  <action>
Create `cron/wrapper.go` with diJobWrapper that implements cron.Job interface:

1. Struct fields:
   - container: pointer to container interface for resolving jobs
   - serviceName: type name for container resolution
   - jobName: human-readable name for logging
   - schedule: schedule expression (for reference)
   - timeout: job timeout duration
   - appCtx: parent context (cancelled on shutdown)
   - logger: *slog.Logger for structured logging
   - mu: sync.Mutex for thread-safe status tracking
   - running: bool for health check
   - lastRun: time.Time
   - lastErr: error

2. Define `Resolver` interface that container will implement:
   ```go
   type Resolver interface {
       ResolveByName(name string, opts any) (any, error)
   }
   ```

3. Implement `NewJobWrapper(resolver Resolver, serviceName, jobName, schedule string, timeout time.Duration, appCtx context.Context, logger *slog.Logger) *diJobWrapper`

4. Implement `Run()` method per RESEARCH.md:
   - Set running=true with mutex
   - Defer: set running=false, update lastRun
   - Call runWithRecovery() which wraps executeJob() with defer/recover
   - In executeJob():
     - Resolve fresh instance from container using serviceName
     - Type assert to CronJob
     - Create ctx with timeout if timeout > 0
     - Log "job started" with job name
     - Call job.Run(ctx)
     - Log "job finished" with duration, or "job failed" with error
     - Update lastErr

5. Implement panic recovery following worker/supervisor.go pattern:
   - Use runtime/debug.Stack() for stack traces
   - Log with "job panicked", job name, panic value, and stack trace

6. Add status accessors for health check: `IsRunning() bool`, `LastRun() time.Time`, `LastError() error`
  </action>
  <verify>`go build ./cron/...` compiles, wrapper implements cron.Job interface</verify>
  <done>diJobWrapper resolves fresh job from container per execution, has panic recovery with stack traces</done>
</task>

<task type="auto">
  <name>Task 2: Create Scheduler implementing worker.Worker</name>
  <files>cron/scheduler.go</files>
  <action>
Create `cron/scheduler.go` with Scheduler that wraps robfig/cron:

1. Scheduler struct fields:
   - cron: *cron.Cron (robfig/cron instance)
   - logger: *slog.Logger
   - resolver: Resolver interface for job wrapper
   - appCtx: context.Context for job execution
   - mu: sync.Mutex
   - jobs: []*diJobWrapper for tracking
   - running: bool

2. Implement `NewScheduler(resolver Resolver, appCtx context.Context, logger *slog.Logger) *Scheduler`:
   - Create slog adapter using NewSlogAdapter
   - Create cron.Cron with options:
     - cron.WithLogger(adapter)
     - cron.WithChain(cron.SkipIfStillRunning(adapter))
   - Do NOT use cron.Recover() - we have custom panic recovery in wrapper
   - Return configured Scheduler

3. Implement worker.Worker interface:
   ```go
   func (s *Scheduler) Name() string { return "cron.Scheduler" }
   
   func (s *Scheduler) Start() {
       s.mu.Lock()
       defer s.mu.Unlock()
       if s.running {
           return
       }
       s.running = true
       s.logger.Info("starting cron scheduler", "jobs", len(s.jobs))
       s.cron.Start()
   }
   
   func (s *Scheduler) Stop() {
       s.mu.Lock()
       defer s.mu.Unlock()
       if !s.running {
           return
       }
       s.running = false
       s.logger.Info("stopping cron scheduler, waiting for running jobs")
       ctx := s.cron.Stop()  // Returns context that completes when jobs finish
       <-ctx.Done()          // Wait for graceful shutdown (CRN-05)
       s.logger.Info("cron scheduler stopped")
   }
   ```

4. Implement `RegisterJob(serviceName, jobName, schedule string, timeout time.Duration) error`:
   - If schedule is empty string, log "job schedule disabled" and return nil (not an error, job opted out per CONTEXT.md)
   - Create diJobWrapper with all parameters
   - Create recoveryWrapper that wraps diJobWrapper for panic safety
   - Call s.cron.AddJob(schedule, recoveryWrapper) - this validates the schedule expression
   - If AddJob returns error, return wrapped error "invalid schedule for job X: %w"
   - Append wrapper to s.jobs slice
   - Log "job registered" with name and schedule
   - Return nil

5. Implement `HealthCheck(ctx context.Context) error` for CRN-09:
   - Lock mutex
   - If not running, return error "scheduler not running"
   - Return nil (basic health - scheduler is running)

6. Add `JobCount() int` for testing/logging.
  </action>
  <verify>`go build ./cron/...` compiles, Scheduler implements worker.Worker interface</verify>
  <done>Scheduler wraps robfig/cron with SkipIfStillRunning, implements worker.Worker, graceful shutdown waits for jobs</done>
</task>

</tasks>

<verification>
1. `go build ./cron/...` - Package compiles
2. `go vet ./cron/...` - No vet errors
3. Verify Scheduler implements worker.Worker: compile-time check or grep for Name/Start/Stop
4. Verify diJobWrapper implements cron.Job: grep for `func.*Run\(\)` in wrapper.go
5. Verify SkipIfStillRunning is used: grep in scheduler.go
6. Verify panic recovery uses debug.Stack(): grep in wrapper.go
</verification>

<success_criteria>
- Scheduler implements worker.Worker interface (Name, Start, Stop)
- Scheduler uses SkipIfStillRunning by default (CRN-08)
- Scheduler.Stop() waits for running jobs via <-cron.Stop().Done() (CRN-05)
- diJobWrapper resolves fresh job instance each execution (transient per CONTEXT.md)
- diJobWrapper has panic recovery with stack trace logging (CRN-06)
- Empty schedule disables job gracefully (per CONTEXT.md)
- Jobs execute with context + timeout (per CONTEXT.md)
</success_criteria>

<output>
After completion, create `.planning/phases/15-cron/15-02-SUMMARY.md`
</output>
