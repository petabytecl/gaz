---
phase: 15-cron
plan: 03
type: execute
wave: 3
depends_on: ["15-02"]
files_modified:
  - app.go
  - compat.go
autonomous: true

must_haves:
  truths:
    - "CronJobs registered via For[CronJob](c).Transient().Provider(...) are discovered during Build()"
    - "Scheduler integrates with worker lifecycle (starts with workers, stops with workers)"
    - "CronJob type alias exported from root gaz package"
  artifacts:
    - path: "app.go"
      provides: "Scheduler integration with App lifecycle"
      contains: "discoverCronJobs"
    - path: "compat.go"
      provides: "CronJob type alias"
      exports: ["CronJob"]
  key_links:
    - from: "app.go"
      to: "cron.Scheduler"
      via: "scheduler field initialized in New()"
      pattern: "scheduler.*cron\\.Scheduler"
    - from: "app.go"
      to: "worker.Manager"
      via: "scheduler registered with workerMgr"
      pattern: "workerMgr\\.Register.*scheduler"
---

<objective>
Integrate cron Scheduler with App lifecycle for auto-discovery of CronJob implementations during Build() and lifecycle management via WorkerManager.

Purpose: Enable seamless scheduled task support - users register CronJob providers, App handles discovery and lifecycle automatically.
Output: App with scheduler field, discoverCronJobs() method, and CronJob alias in root package.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/15-cron/15-CONTEXT.md
@.planning/phases/15-cron/15-RESEARCH.md
@.planning/phases/15-cron/15-02-SUMMARY.md
@app.go
@compat.go
@cron/scheduler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Scheduler to App and implement discoverCronJobs</name>
  <files>app.go</files>
  <action>
1. Add import for cron package:
   ```go
   "github.com/petabytecl/gaz/cron"
   ```

2. Add scheduler field to App struct (near workerMgr field):
   ```go
   // Cron scheduler
   scheduler *cron.Scheduler
   ```

3. In New() function, initialize scheduler after workerMgr (scheduler needs logger which is set up before):
   ```go
   // Initialize Scheduler with nil context for now (set in Build)
   app.scheduler = cron.NewScheduler(app.container, context.Background(), app.Logger)
   ```
   Note: We use context.Background() initially; actual job execution will use app context.

4. Create `discoverCronJobs() error` method following discoverWorkers pattern:
   ```go
   func (a *App) discoverCronJobs() error {
       a.container.ForEachService(func(name string, svc di.ServiceWrapper) {
           // CronJobs should be transient (new instance per execution)
           // But we still need to resolve once to get schedule info
           
           // Try to resolve and check for CronJob interface
           instance, err := a.container.ResolveByName(name, nil)
           if err != nil {
               return // Skip services that fail to resolve
           }
           
           if job, ok := instance.(cron.CronJob); ok {
               // Register with scheduler using service name for later resolution
               if regErr := a.scheduler.RegisterJob(
                   name,           // serviceName for container resolution
                   job.Name(),     // human name for logging
                   job.Schedule(), // cron expression
                   job.Timeout(),  // execution timeout
               ); regErr != nil {
                   a.Logger.Warn("failed to register cron job",
                       "name", job.Name(),
                       "error", regErr,
                   )
               }
           }
       })
       return nil
   }
   ```

5. Call discoverCronJobs() in Build() after discoverWorkers():
   ```go
   // Discover cron jobs from registered services
   if err := a.discoverCronJobs(); err != nil {
       errs = append(errs, err)
   }
   
   // Register scheduler with worker manager (only if jobs exist)
   if a.scheduler.JobCount() > 0 {
       if err := a.workerMgr.Register(a.scheduler); err != nil {
           errs = append(errs, fmt.Errorf("registering scheduler: %w", err))
       }
   }
   ```

6. The scheduler now starts/stops automatically via WorkerManager lifecycle (CRN-04).
  </action>
  <verify>`go build ./...` compiles, scheduler field exists in App struct</verify>
  <done>Scheduler initialized in New(), jobs discovered in Build(), scheduler registered with workerMgr if jobs exist</done>
</task>

<task type="auto">
  <name>Task 2: Add CronJob type alias to compat.go</name>
  <files>compat.go</files>
  <action>
1. Add CronJob type alias in compat.go following Worker pattern:
   ```go
   // CronJob is a type alias for cron.CronJob for convenience.
   // Users can import this from the root gaz package instead of gaz/cron.
   type CronJob = cron.CronJob
   ```

2. Add import for cron package if not already present.

3. Ensure the alias is grouped with other type aliases (like Worker, Container, etc.).
  </action>
  <verify>`go build ./...` compiles, CronJob alias accessible from root package</verify>
  <done>CronJob type alias exported from root gaz package</done>
</task>

</tasks>

<verification>
1. `go build ./...` - All packages compile
2. `go vet ./...` - No vet errors
3. Verify scheduler field in App: grep "scheduler.*Scheduler" app.go
4. Verify discoverCronJobs called in Build: grep "discoverCronJobs" app.go
5. Verify CronJob alias in compat.go: grep "type CronJob" compat.go
6. Verify scheduler registered with workerMgr: grep "workerMgr.Register.*scheduler" app.go
</verification>

<success_criteria>
- App has scheduler *cron.Scheduler field
- Scheduler initialized in New() with container and logger
- discoverCronJobs() scans for CronJob interface implementations
- Scheduler registered with WorkerManager if jobs exist (CRN-04)
- CronJob type alias exported from root gaz package
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-cron/15-03-SUMMARY.md`
</output>
