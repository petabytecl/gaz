---
phase: 14-workers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - worker/worker.go
  - worker/options.go
  - worker/backoff.go
  - worker/doc.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Worker interface exists with Start(), Stop(), Name() methods"
    - "Worker registration options exist (WithPoolSize, WithCritical)"
    - "Backoff configuration wraps jpillora/backoff with sensible defaults"
  artifacts:
    - path: "worker/worker.go"
      provides: "Worker interface definition"
      exports: ["Worker"]
      contains: "type Worker interface"
    - path: "worker/options.go"
      provides: "Registration options for workers"
      exports: ["WorkerOptions", "WithPoolSize", "WithCritical"]
    - path: "worker/backoff.go"
      provides: "Backoff configuration wrapper"
      exports: ["BackoffConfig", "NewBackoffConfig"]
    - path: "worker/doc.go"
      provides: "Package documentation"
      contains: "Package worker"
  key_links:
    - from: "worker/options.go"
      to: "worker/worker.go"
      via: "imports Worker type"
      pattern: "Worker"
    - from: "worker/backoff.go"
      to: "github.com/jpillora/backoff"
      via: "wraps external library"
      pattern: "jpillora/backoff"
---

<objective>
Create the worker package foundation with Worker interface, registration options, and backoff configuration.

Purpose: Establishes the core types and external dependency that all other worker functionality builds upon.
Output: worker/ package with interface, options, backoff, and dependency on jpillora/backoff.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-workers/14-CONTEXT.md
@.planning/phases/14-workers/14-RESEARCH.md

# Existing patterns to follow
@di/lifecycle.go
@config/types.go
@config/options.go
@config/doc.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Worker interface and package documentation</name>
  <files>worker/worker.go, worker/doc.go</files>
  <action>
Create the worker package directory and core interface:

**worker/doc.go:**
- Package documentation explaining worker purpose
- Reference to Worker interface and WorkerManager
- Examples of implementing a simple worker

**worker/worker.go:**
- Define `Worker` interface with three methods (per CONTEXT.md locked decision):
  - `Start()` - Returns immediately; worker spawns its own goroutine internally
  - `Stop()` - Signals shutdown without timeout context; worker decides when to return  
  - `Name() string` - Required identifier for logging
- Add doc comments explaining the contract:
  - Start() must be non-blocking
  - Stop() signals shutdown, worker should exit gracefully
  - Name() must return a non-empty string for logging

Follow existing patterns from di/lifecycle.go (Starter/Stopper interfaces).
  </action>
  <verify>`go build ./worker/...` succeeds</verify>
  <done>Worker interface defined with Start(), Stop(), Name() methods matching CONTEXT.md specification</done>
</task>

<task type="auto">
  <name>Task 2: Create registration options and backoff configuration</name>
  <files>worker/options.go, worker/backoff.go, go.mod, go.sum</files>
  <action>
Add jpillora/backoff dependency:
```bash
go get github.com/jpillora/backoff
```

**worker/options.go:**
- Define `WorkerOptions` struct with fields:
  - `PoolSize int` - Number of pool instances (default 1)
  - `Critical bool` - If true, crash app when circuit breaker trips
  - `StableRunPeriod time.Duration` - Duration of stable run before backoff reset (default 30s per RESEARCH.md)
  - `MaxRestarts int` - Max restarts in circuit breaker window (default 5)
  - `CircuitWindow time.Duration` - Circuit breaker time window (default 10 minutes)
- Create option functions:
  - `WithPoolSize(n int) WorkerOption` - Sets pool size for worker registration
  - `WithCritical() WorkerOption` - Marks worker as critical (crashes app on failure)
  - `WithStableRunPeriod(d time.Duration) WorkerOption`
  - `WithMaxRestarts(n int) WorkerOption`
  - `WithCircuitWindow(d time.Duration) WorkerOption`
- Define `WorkerOption func(*WorkerOptions)` type
- Create `DefaultWorkerOptions() *WorkerOptions` with sensible defaults

**worker/backoff.go:**
- Define `BackoffConfig` struct wrapping jpillora/backoff parameters:
  - `Min time.Duration` (default 1s)
  - `Max time.Duration` (default 5 minutes)
  - `Factor float64` (default 2)
  - `Jitter bool` (default true)
- Create `NewBackoffConfig() *BackoffConfig` with defaults from RESEARCH.md
- Create `NewBackoff(cfg *BackoffConfig) *backoff.Backoff` factory function
- Add method `(c *BackoffConfig) Apply(opts ...BackoffOption)` for customization

Follow existing patterns from config/options.go for option function pattern.
  </action>
  <verify>`go build ./worker/...` succeeds and `go mod tidy` shows jpillora/backoff in go.mod</verify>
  <done>WorkerOptions with pool/critical settings, BackoffConfig wrapping jpillora/backoff with defaults</done>
</task>

</tasks>

<verification>
- [ ] `go build ./worker/...` compiles without errors
- [ ] `go mod tidy && cat go.mod | grep jpillora` shows backoff dependency
- [ ] Worker interface has Start(), Stop(), Name() methods
- [ ] WorkerOptions has PoolSize, Critical, MaxRestarts, CircuitWindow fields
- [ ] BackoffConfig has Min, Max, Factor, Jitter fields with sensible defaults
</verification>

<success_criteria>
- Worker interface matches CONTEXT.md locked decision (Start/Stop/Name, not Run(ctx))
- BackoffConfig defaults match RESEARCH.md recommendations (1s min, 5m max, factor 2, jitter true)
- WorkerOptions defaults match RESEARCH.md (30s stable period, 5 max restarts, 10m circuit window)
- Package compiles and dependency is tracked in go.mod
</success_criteria>

<output>
After completion, create `.planning/phases/14-workers/14-01-SUMMARY.md`
</output>
