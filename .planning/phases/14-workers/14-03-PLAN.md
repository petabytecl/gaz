---
phase: 14-workers
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - app.go
  - compat.go
autonomous: true

must_haves:
  truths:
    - "Workers auto-start on app.Run() after Starter hooks complete"
    - "Workers auto-stop on app.Stop() before Stopper hooks run"
    - "Workers implementing Worker interface are auto-discovered"
    - "Critical worker failure triggers app graceful shutdown"
  artifacts:
    - path: "app.go"
      provides: "App with WorkerManager integration"
      contains: "workerMgr"
    - path: "compat.go"
      provides: "Worker type alias for root package"
      contains: "Worker = worker.Worker"
  key_links:
    - from: "app.go"
      to: "worker/manager.go"
      via: "imports and uses worker.Manager"
      pattern: "worker\\.Manager|workerMgr"
    - from: "app.go"
      to: "Worker interface"
      via: "auto-discovery during Build"
      pattern: "worker\\.Worker"
---

<objective>
Integrate WorkerManager with App lifecycle for auto-discovery, auto-start, and auto-stop of workers.

Purpose: Workers registered via For[T]().Provider() are automatically discovered if they implement Worker interface, started after Starter hooks complete, and stopped before Stopper hooks run.
Output: Updated app.go with WorkerManager lifecycle integration.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-workers/14-CONTEXT.md
@.planning/phases/14-workers/14-RESEARCH.md
@.planning/phases/14-workers/14-01-SUMMARY.md
@.planning/phases/14-workers/14-02-SUMMARY.md

# Prior plan outputs
@worker/worker.go
@worker/manager.go

# Files to modify
@app.go
@compat.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WorkerManager to App struct and discover workers</name>
  <files>app.go</files>
  <action>
Update App struct to include WorkerManager:

1. **Add import:** `"github.com/petabytecl/gaz/worker"`

2. **Add field to App struct:**
   ```go
   workerMgr *worker.Manager
   ```

3. **Initialize in New():**
   ```go
   app.workerMgr = worker.NewManager(app.Logger)
   ```

4. **Add worker discovery in Build()** (after collectProviderConfigs, before container.Build):
   ```go
   // Discover workers from registered services
   if err := a.discoverWorkers(); err != nil {
       errs = append(errs, err)
   }
   ```

5. **Implement discoverWorkers():**
   ```go
   func (a *App) discoverWorkers() error {
       a.container.ForEachService(func(name string, svc di.ServiceWrapper) {
           // Skip transient services
           if svc.IsTransient() {
               return
           }
           
           // Try to resolve and check for Worker interface
           instance, err := a.container.ResolveByName(name, nil)
           if err != nil {
               return // Skip services that fail to resolve
           }
           
           if w, ok := instance.(worker.Worker); ok {
               // Register with default options
               // Providers can customize via WithWorkerOptions in future
               if regErr := a.workerMgr.Register(w); regErr != nil {
                   a.Logger.Warn("failed to register worker",
                       "name", name,
                       "error", regErr,
                   )
               }
           }
       })
       return nil
   }
   ```

6. **Set critical failure handler in New():**
   ```go
   a.workerMgr.SetCriticalFailHandler(func() {
       a.Logger.Error("critical worker failed, initiating shutdown")
       go func() {
           ctx, cancel := context.WithTimeout(context.Background(), a.opts.ShutdownTimeout)
           defer cancel()
           _ = a.Stop(ctx)
       }()
   })
   ```
  </action>
  <verify>`go build ./...` succeeds</verify>
  <done>WorkerManager integrated into App, workers auto-discovered during Build()</done>
</task>

<task type="auto">
  <name>Task 2: Integrate workers with Run()/Stop() lifecycle</name>
  <files>app.go, compat.go</files>
  <action>
**Update Run() in app.go:**

After all Starter hooks complete (after the layer-by-layer startup loop), start workers:
```go
// Start workers after all services started
a.Logger.InfoContext(ctx, "starting workers")
if err := a.workerMgr.Start(ctx); err != nil {
    // Rollback
    shutdownCtx, cancel := context.WithTimeout(context.Background(), a.opts.ShutdownTimeout)
    defer cancel()
    _ = a.Stop(shutdownCtx)
    return fmt.Errorf("starting workers: %w", err)
}
```

**Update Stop() in app.go:**

Before stopping services (before the stopServices call), stop workers:
```go
// Stop workers first (they may depend on services)
a.Logger.InfoContext(ctx, "stopping workers")
if err := a.workerMgr.Stop(); err != nil {
    errs = append(errs, fmt.Errorf("stopping workers: %w", err))
}
```

**Update compat.go:**

Add type alias for Worker interface in root package:
```go
// Worker is a background task that runs continuously.
// Alias for worker.Worker for convenience.
type Worker = worker.Worker
```

Also add import for worker package if not present.

**Lifecycle order:**
1. Build() - discover workers, register with manager
2. Run() - start services layer by layer, then start all workers
3. Stop() - stop all workers first, then stop services layer by layer

This ensures workers can depend on services (services start before workers) and services don't stop while workers are still running (workers stop before services).
  </action>
  <verify>`go build ./...` succeeds and `go test ./... -run TestApp` passes</verify>
  <done>Workers auto-start after services, auto-stop before services, Worker alias in root package</done>
</task>

</tasks>

<verification>
- [ ] `go build ./...` compiles without errors
- [ ] WorkerManager initialized in New()
- [ ] Workers discovered during Build() via interface check
- [ ] Workers started in Run() after service Starter hooks
- [ ] Workers stopped in Stop() before service Stopper hooks
- [ ] Critical worker failure triggers app shutdown
- [ ] gaz.Worker type alias exists in compat.go
- [ ] Existing tests pass: `go test ./...`
</verification>

<success_criteria>
- Services implementing worker.Worker are auto-discovered (no manual registration)
- Workers start after all Starter hooks complete
- Workers stop before Stopper hooks run
- Critical worker circuit breaker trip initiates graceful app shutdown
- gaz.Worker alias allows using worker interface from root package
</success_criteria>

<output>
After completion, create `.planning/phases/14-workers/14-03-SUMMARY.md`
</output>
