---
phase: 08-hardened-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lifecycle.go
  - app.go
autonomous: true

must_haves:
  truths:
    - "Hooks execute sequentially during shutdown (LIFO order)"
    - "Each hook is wrapped with a per-hook timeout context"
    - "Timed-out hooks are blamed in logs with name and elapsed time"
    - "Application continues to next hook after per-hook timeout"
    - "Global timeout triggers os.Exit(1) with blame log"
  artifacts:
    - path: "lifecycle.go"
      provides: "Timeout field in HookConfig, WithHookTimeout option"
      contains: "Timeout time.Duration"
    - path: "app.go"
      provides: "Sequential shutdown orchestrator with blame logging"
      contains: "exceeded.*timeout"
  key_links:
    - from: "stopServices()"
      to: "per-hook context.WithTimeout"
      via: "wrapping each hook invocation"
      pattern: "context\\.WithTimeout"
    - from: "hook timeout"
      to: "blame logging"
      via: "Logger.ErrorContext after hook exceeds timeout"
      pattern: "exceeded.*timeout"
---

<objective>
Implement hardened shutdown orchestrator with per-hook timeout enforcement and blame logging.

Purpose: Ensure applications never hang indefinitely during shutdown by enforcing timeouts and identifying which specific hook is causing delays.

Output: Modified `lifecycle.go` with timeout configuration, modified `app.go` with sequential shutdown orchestrator that enforces per-hook timeouts, logs blame for hanging hooks, and triggers force exit on global timeout.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-hardened-lifecycle/08-CONTEXT.md
@.planning/phases/08-hardened-lifecycle/08-RESEARCH.md
@lifecycle.go
@app.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Timeout Configuration Infrastructure</name>
  <files>lifecycle.go, app.go</files>
  <action>
1. In `lifecycle.go`:
   - Add `Timeout time.Duration` field to `HookConfig` struct
   - Create `WithHookTimeout(d time.Duration) HookOption` function that sets the timeout

2. In `app.go`:
   - Add `PerHookTimeout time.Duration` to `AppOptions` struct (default 10s)
   - Create `WithPerHookTimeout(d time.Duration) Option` function
   - Create package-level variable `var exitFunc = os.Exit` for testability
   - Update `New()` to initialize default `PerHookTimeout: 10 * time.Second`

Note: The existing `ShutdownTimeout` serves as the global timeout. The new `PerHookTimeout` is the per-hook default.
  </action>
  <verify>
`go build ./...` succeeds with no errors.
  </verify>
  <done>
- HookConfig has Timeout field
- WithHookTimeout option function exists
- AppOptions has PerHookTimeout field
- WithPerHookTimeout option function exists
- exitFunc variable declared for testability
  </done>
</task>

<task type="auto">
  <name>Task 2: Sequential Shutdown Orchestrator with Blame Logging</name>
  <files>app.go</files>
  <action>
Rewrite `stopServices()` to implement sequential shutdown with per-hook timeout and blame:

1. **Sequential execution** (not parallel as currently):
   - Iterate through shutdown order layers
   - For each layer, iterate through services sequentially (one at a time)
   - This ensures predictable shutdown and accurate blame tracking

2. **Per-hook timeout wrapper**:
   - For each hook, create `hookCtx, cancel := context.WithTimeout(ctx, timeout)`
   - Use hook-specific timeout if set via `WithHookTimeout`, else use `a.opts.PerHookTimeout`
   - Pass `hookCtx` to `svc.stop(hookCtx)`
   - Track start time for elapsed calculation

3. **Blame logging format** (as specified in CONTEXT.md):
   ```
   shutdown: {name} exceeded {timeout} timeout (elapsed: {elapsed})
   ```
   - Use `a.Logger.ErrorContext()` first
   - If logger call fails, fall back to `fmt.Fprintf(os.Stderr, ...)`

4. **Error handling**:
   - If hook times out: log blame, cancel context, continue to next hook
   - If hook returns error: log error, continue to next hook
   - Collect all errors, return combined at end

5. **Global timeout force exit**:
   - At start of `Stop()`, spawn a goroutine that sleeps for `a.opts.ShutdownTimeout`
   - If goroutine wakes before `stopServices()` completes:
     - Log "shutdown: global timeout exceeded, forcing exit"
     - Call `exitFunc(1)` (os.Exit(1))
   - Use a `done` channel to cancel the goroutine if shutdown completes normally

6. **Log successful completions**:
   - When hook completes successfully, log at Info level with duration

Implementation notes:
- Keep existing startup logic in `Run()` unchanged (parallel startup is fine)
- The shutdown goroutine should be started in `Stop()` method
- Use `select` with hook context and done channel to detect timeout
  </action>
  <verify>
```bash
go build ./... && go test -run TestRunAndStop -v
```
Existing tests still pass. Manual review confirms sequential shutdown and timeout infrastructure.
  </verify>
  <done>
- `stopServices()` executes hooks sequentially
- Each hook gets a context with per-hook timeout
- Timed-out hooks produce blame log with name and elapsed time
- Global timeout goroutine calls exitFunc(1) if shutdown exceeds ShutdownTimeout
- Hooks continue executing after one times out
- All errors collected and returned
  </done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
go build ./...

# Existing tests pass
go test -v -run "TestRunAndStop|TestStopError|TestSignalHandling"

# Lint passes
golangci-lint run
```
</verification>

<success_criteria>
- LIFE-01: PerHookTimeout (10s) and ShutdownTimeout (30s) configurable and enforced
- LIFE-02: exitFunc(1) called when global timeout exceeded
- LIFE-04: Blame logging identifies hook name and elapsed time on timeout
- Existing App tests continue to pass
- No golangci-lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-hardened-lifecycle/08-01-SUMMARY.md`
</output>
