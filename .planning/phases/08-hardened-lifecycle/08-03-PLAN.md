---
phase: 08-hardened-lifecycle
plan: 03
type: execute
wave: 3
depends_on: ["08-01", "08-02"]
files_modified:
  - shutdown_test.go
autonomous: true

must_haves:
  truths:
    - "Test proves graceful shutdown completes when hooks finish in time"
    - "Test proves force exit happens when hook exceeds global timeout"
    - "Test proves blame log identifies the specific hanging hook"
    - "Test proves double-SIGINT triggers immediate exit"
  artifacts:
    - path: "shutdown_test.go"
      provides: "Comprehensive shutdown hardening tests"
      exports: ["TestShutdownSuite"]
      min_lines: 100
  key_links:
    - from: "test"
      to: "exitFunc"
      via: "test replaces exitFunc to capture exit calls"
      pattern: "exitFunc\\s*="
    - from: "test"
      to: "blame logging"
      via: "custom logger captures blame messages"
      pattern: "exceeded.*timeout"
---

<objective>
Create comprehensive tests for hardened shutdown behavior covering graceful completion, timeout enforcement, blame logging, and double-SIGINT.

Purpose: Verify all LIFE-* requirements are met with automated tests that can catch regressions.

Output: New `shutdown_test.go` with test suite covering all shutdown hardening scenarios.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-hardened-lifecycle/08-01-SUMMARY.md
@.planning/phases/08-hardened-lifecycle/08-02-SUMMARY.md
@app.go
@app_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test Suite Setup and Helpers</name>
  <files>shutdown_test.go</files>
  <action>
Create new `shutdown_test.go` with test suite infrastructure:

1. **Package declaration and imports**:
   ```go
   package gaz
   
   import (
       "bytes"
       "context"
       "log/slog"
       "sync"
       "sync/atomic"
       "syscall"
       "testing"
       "time"
       
       "github.com/stretchr/testify/suite"
   )
   ```

2. **Test suite struct**:
   ```go
   type ShutdownTestSuite struct {
       suite.Suite
       originalExitFunc func(int)
       exitCalled       atomic.Bool
       exitCode         atomic.Int32
       logBuffer        *bytes.Buffer
   }
   ```

3. **SetupTest/TeardownTest**:
   - Save original `exitFunc`
   - Replace with mock that sets `exitCalled` and `exitCode`
   - Reset atomics
   - Create log buffer for capturing logs

4. **Helper: createAppWithSlowHook(hookDuration, perHookTimeout, globalTimeout)**:
   - Creates app with a service that has an OnStop hook sleeping for `hookDuration`
   - Configures timeouts as specified
   - Returns configured app ready for testing

5. **Helper: createLogCapturingApp()**:
   - Creates app with logger writing to `logBuffer`
   - Allows assertion on logged messages

6. **Suite runner**:
   ```go
   func TestShutdownTestSuite(t *testing.T) {
       suite.Run(t, new(ShutdownTestSuite))
   }
   ```
  </action>
  <verify>
`go test -run TestShutdownTestSuite -v` runs (may have no test methods yet, but compiles).
  </verify>
  <done>
- ShutdownTestSuite struct defined with exitFunc mock and log buffer
- SetupTest saves and replaces exitFunc
- TeardownTest restores original exitFunc
- Helper functions for creating test apps exist
- Suite runner function exists
  </done>
</task>

<task type="auto">
  <name>Task 2: Graceful and Timeout Tests</name>
  <files>shutdown_test.go</files>
  <action>
Add tests verifying timeout behavior:

1. **TestGracefulShutdownCompletes**:
   - Create app with hook that completes in 50ms
   - Set perHookTimeout to 1s, globalTimeout to 5s
   - Call Stop()
   - Assert exitFunc NOT called
   - Assert Stop() returns nil (no error)

2. **TestPerHookTimeoutContinuesToNextHook**:
   - Create app with two services:
     - Service A: OnStop sleeps 500ms (will timeout)
     - Service B: OnStop completes immediately
   - Set perHookTimeout to 100ms
   - Call Stop()
   - Assert both hooks were attempted (B ran even though A timed out)
   - Assert blame log contains "Service A" and "exceeded"
   - Assert exitFunc NOT called (per-hook timeout doesn't exit, just logs)

3. **TestGlobalTimeoutForcesExit**:
   - Create app with hook that sleeps 2s
   - Set perHookTimeout to 5s, globalTimeout to 500ms
   - Call Stop()
   - Assert exitFunc(1) WAS called
   - Assert log contains "global timeout"

4. **TestBlameLloggingFormat**:
   - Create app with hook "DatabasePool" that sleeps 200ms
   - Set perHookTimeout to 100ms
   - Call Stop()
   - Assert log contains: hook name, "exceeded", timeout value, elapsed time

5. **TestWithPerHookTimeoutOption**:
   - Create app with WithPerHookTimeout(2*time.Second)
   - Assert app.opts.PerHookTimeout equals 2s

6. **TestWithShutdownTimeoutOption**:
   - Create app with WithShutdownTimeout(45*time.Second)
   - Assert app.opts.ShutdownTimeout equals 45s
  </action>
  <verify>
```bash
go test -run "TestShutdownTestSuite/TestGraceful|TestShutdownTestSuite/TestPerHook|TestShutdownTestSuite/TestGlobal|TestShutdownTestSuite/TestBlame|TestShutdownTestSuite/TestWith" -v
```
All tests pass.
  </verify>
  <done>
- Test proves graceful completion when hooks finish in time
- Test proves per-hook timeout allows next hook to run
- Test proves global timeout triggers exitFunc(1)
- Test proves blame logging includes hook name and timing
- Tests for configuration options exist
  </done>
</task>

<task type="auto">
  <name>Task 3: Double-SIGINT Tests</name>
  <files>shutdown_test.go</files>
  <action>
Add tests verifying double-SIGINT behavior:

1. **TestFirstSIGINTLogsHint**:
   - Create app with slow hook (1s)
   - Start Run() in goroutine
   - Wait for app to be running
   - Send SIGINT via syscall.Kill
   - Assert log contains "Ctrl+C again to force" or similar hint
   - Send second SIGINT to complete the test

2. **TestDoubleSIGINTForcesImmediateExit**:
   - Create app with slow hook (5s)
   - Set globalTimeout to 10s (so timeout won't trigger)
   - Start Run() in goroutine
   - Wait for app to be running
   - Send first SIGINT
   - Wait 50ms
   - Send second SIGINT
   - Assert exitFunc(1) was called
   - Assert log contains "force" or "second interrupt"
   - Assert exit happened quickly (within 200ms of second signal)

3. **TestSIGTERMDoesNotEnableDoubleSignal**:
   - Create app with slow hook (1s)
   - Start Run() in goroutine
   - Wait for app to be running
   - Send SIGTERM
   - Wait for graceful shutdown to complete (or timeout)
   - Assert no force exit was triggered by sending a second signal
   - (This test verifies SIGTERM triggers graceful shutdown only)

Note: These tests involve signals which can be tricky. Use `syscall.Kill(syscall.Getpid(), signal)` pattern from existing tests. Use Eventually assertions with short intervals.
  </action>
  <verify>
```bash
go test -run "TestShutdownTestSuite/TestFirst|TestShutdownTestSuite/TestDouble|TestShutdownTestSuite/TestSIGTERM" -v
```
All double-signal tests pass.
  </verify>
  <done>
- Test proves first SIGINT logs hint about Ctrl+C again
- Test proves double SIGINT calls exitFunc(1) immediately
- Test proves SIGTERM follows graceful path without double-signal
- Signal tests use proper syscall patterns
  </done>
</task>

</tasks>

<verification>
```bash
# All shutdown tests pass
go test -run TestShutdownTestSuite -v

# All app tests still pass (no regressions)
go test -run "Test.*App.*" -v

# Full test suite
go test -v ./...

# Lint passes
golangci-lint run
```
</verification>

<success_criteria>
- All LIFE-* requirements covered by tests
- Test for graceful completion (hooks finish in time)
- Test for per-hook timeout (continues to next hook)
- Test for global timeout (force exit)
- Test for blame logging (hook name, elapsed time)
- Test for double-SIGINT (immediate exit on second signal)
- Test for SIGTERM (no double-signal behavior)
- All tests pass, no lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-hardened-lifecycle/08-03-SUMMARY.md`
</output>
