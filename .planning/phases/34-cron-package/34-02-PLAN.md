---
phase: 34-cron-package
plan: 02
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - cronx/cron.go
  - cronx/cron_test.go
  - cronx/chain.go
  - cronx/chain_test.go
  - cronx/option.go
  - cronx/option_test.go
autonomous: true

must_haves:
  truths:
    - "Cron.Start() begins the scheduler in a goroutine"
    - "Cron.Stop() returns a context that completes when running jobs finish"
    - "Cron.AddJob(spec, job) registers jobs with cron schedules"
    - "Cron.AddFunc(spec, func) registers functions as jobs"
    - "SkipIfStillRunning wrapper prevents overlapping job executions"
    - "Recover wrapper catches panics and logs them"
    - "WithLogger, WithChain, WithLocation options configure the scheduler"
    - "Entries(), Entry(id), Remove(id) provide introspection and management"
  artifacts:
    - path: "cronx/cron.go"
      provides: "Cron scheduler with Start/Stop/AddJob/AddFunc/Entries/Entry/Remove"
      exports: ["Cron", "Entry", "EntryID", "Job", "FuncJob", "New"]
    - path: "cronx/chain.go"
      provides: "Job wrappers for cross-cutting concerns"
      exports: ["JobWrapper", "Chain", "NewChain", "SkipIfStillRunning", "Recover", "DelayIfStillRunning"]
    - path: "cronx/option.go"
      provides: "Functional options for Cron configuration"
      exports: ["Option", "WithLogger", "WithChain", "WithLocation", "WithParser", "WithSeconds"]
  key_links:
    - from: "cronx/cron.go"
      to: "cronx/parser.go"
      via: "Cron uses parser to parse schedule specs"
      pattern: "parser\\.Parse"
    - from: "cronx/cron.go"
      to: "cronx/chain.go"
      via: "Cron applies Chain to wrap jobs"
      pattern: "c\\.chain\\.Then"
    - from: "cronx/option.go"
      to: "cronx/cron.go"
      via: "Options modify Cron fields"
      pattern: "func\\(c \\*Cron\\)"
---

<objective>
Create the Cron scheduler type and job wrapper infrastructure.

Purpose: Implement the main scheduler that runs jobs on their schedules, plus decorators like SkipIfStillRunning for controlling job execution behavior.

Output:
- cronx/cron.go - Main Cron type with Start/Stop/AddJob lifecycle
- cronx/chain.go - JobWrapper, Chain, SkipIfStillRunning, Recover
- cronx/option.go - Functional options (WithLogger, WithChain, WithLocation)
- Comprehensive tests for scheduler behavior
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-cron-package/34-01-SUMMARY.md

Reference implementation to adapt:
@_tmp_trust/cronx/cron.go
@_tmp_trust/cronx/chain.go
@_tmp_trust/cronx/option.go
@_tmp_trust/cronx/cron_test.go
@_tmp_trust/cronx/chain_test.go
@_tmp_trust/cronx/option_test.go

Files created in Plan 01:
@cronx/spec.go
@cronx/parser.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cron scheduler type with full API</name>
  <files>
    - cronx/cron.go
    - cronx/cron_test.go
  </files>
  <action>
Implement the main Cron scheduler type:

1. **cronx/cron.go** - Adapt from reference `_tmp_trust/cronx/cron.go`:

   Key types to define:
   ```go
   // Job is an interface for submitted cron jobs.
   type Job interface {
       Run()
   }

   // EntryID identifies an entry within a Cron instance
   type EntryID int

   // Entry consists of a schedule and the func to execute on that schedule.
   type Entry struct {
       Next       time.Time
       Prev       time.Time
       Schedule   Schedule
       WrappedJob Job
       Job        Job
       ID         EntryID
   }

   // FuncJob is a wrapper that turns a func() into a cron.Job
   type FuncJob func()
   func (f FuncJob) Run() { f() }
   ```

   Cron struct fields:
   - parser ScheduleParser
   - location *time.Location
   - stop, add, remove, snapshot channels
   - logger *slog.Logger (changed from logx.Logger)
   - entries []*Entry
   - chain Chain
   - jobWaiter sync.WaitGroup
   - nextID EntryID
   - runningMu sync.Mutex
   - running bool

   Methods to implement:
   - New(opts ...Option) *Cron - constructor with defaults
   - AddFunc(spec string, cmd func()) (EntryID, error)
   - AddJob(spec string, cmd Job) (EntryID, error)
   - Schedule(schedule Schedule, cmd Job) EntryID
   - Entries() []Entry - snapshot of entries
   - Entry(id EntryID) Entry - get specific entry
   - Remove(id EntryID) - remove entry
   - Start() - start in goroutine
   - Run() - blocking run
   - Stop() context.Context - stop and return wait context
   - Location() *time.Location

   Internal methods:
   - run() - main scheduler loop
   - startJob(j Job) - run job in goroutine with WaitGroup
   - now() time.Time - current time in location
   - entrySnapshot() []Entry
   - removeEntry(id EntryID)
   - byTime sorting for entries

   Key adaptation:
   - Change `logger logx.Logger` to `logger *slog.Logger`
   - Change `logx.NewDiscard()` to `slog.New(slog.NewTextHandler(io.Discard, nil))`
   - Logger calls: `c.logger.Info("start")` becomes `c.logger.Info("start")` (same API!)

2. **cronx/cron_test.go** - Adapt from reference tests:
   - Test Start/Stop lifecycle
   - Test AddFunc/AddJob before and after Start
   - Test Remove before and after Start
   - Test Entries() and Entry(id)
   - Test multiple entries sorting
   - Test Stop returns context that waits for jobs
   - Test double Start is no-op
   - Test concurrent access safety
   - Use newBufLogger() that returns discarding slog.Logger for tests
  </action>
  <verify>
```bash
# Package compiles
go build ./cronx/...

# Cron tests pass
go test ./cronx/... -v -run "TestCron|TestJob|TestStart|TestStop|TestAdd|TestRemove|TestEntries"
```
  </verify>
  <done>
- cronx/cron.go exports Cron, Entry, EntryID, Job, FuncJob, New
- Start/Stop lifecycle works correctly
- AddFunc/AddJob register jobs with schedule validation
- Entries(), Entry(id), Remove(id) work for introspection
- Stop() returns context that completes when jobs finish
- Logger uses *slog.Logger instead of logx.Logger
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create chain wrappers and functional options</name>
  <files>
    - cronx/chain.go
    - cronx/chain_test.go
    - cronx/option.go
    - cronx/option_test.go
  </files>
  <action>
Implement job wrappers and configuration options:

1. **cronx/chain.go** - Adapt from reference `_tmp_trust/cronx/chain.go`:

   Types:
   ```go
   // JobWrapper decorates the given Job with some behavior.
   type JobWrapper func(Job) Job

   // Chain is a sequence of JobWrappers
   type Chain struct {
       wrappers []JobWrapper
   }
   ```

   Functions:
   - NewChain(c ...JobWrapper) Chain
   - (c Chain) Then(j Job) Job - applies wrappers in reverse order

   Wrappers (adapt logger from logx.Logger to *slog.Logger):
   - Recover(logger *slog.Logger) JobWrapper - catches panics, logs with stack trace
   - DelayIfStillRunning(logger *slog.Logger) JobWrapper - serializes with mutex, logs delays
   - SkipIfStillRunning(logger *slog.Logger) JobWrapper - skips if previous still running, logs skips

   Key adaptations for slog:
   ```go
   // Old: logger.Error(err, "panic", "stack", "...\n"+string(buf))
   // New: logger.Error("panic", "error", err, "stack", string(buf))

   // Old: logger.Info("delay", "duration", dur)
   // New: logger.Info("delay", slog.Duration("duration", dur))

   // Old: logger.Info("skip")
   // New: logger.Info("skip")
   ```

2. **cronx/chain_test.go** - Adapt from reference tests:
   - Test Chain.Then() applies wrappers correctly
   - Test SkipIfStillRunning skips when job running
   - Test DelayIfStillRunning waits for previous
   - Test Recover catches panics

3. **cronx/option.go** - Adapt from reference `_tmp_trust/cronx/option.go`:

   ```go
   // Option represents a modification to the default behavior of a Cron.
   type Option func(*Cron)

   func WithLocation(loc *time.Location) Option
   func WithSeconds() Option  // enables seconds field
   func WithParser(p ScheduleParser) Option
   func WithChain(wrappers ...JobWrapper) Option
   func WithLogger(logger *slog.Logger) Option  // changed from logx.Logger
   ```

4. **cronx/option_test.go** - Adapt from reference tests:
   - Test WithLocation changes cron timezone
   - Test WithParser changes parser
   - Test WithChain applies wrappers
   - Test WithSeconds enables 6-field parsing
   - Test WithLogger sets logger
  </action>
  <verify>
```bash
# Package compiles
go build ./cronx/...

# Chain and option tests pass
go test ./cronx/... -v -run "TestChain|TestSkip|TestDelay|TestRecover|TestWith"

# Full package test
go test ./cronx/... -v
```
  </verify>
  <done>
- cronx/chain.go exports JobWrapper, Chain, NewChain, SkipIfStillRunning, Recover, DelayIfStillRunning
- cronx/option.go exports Option, WithLogger, WithChain, WithLocation, WithParser, WithSeconds
- SkipIfStillRunning prevents overlapping executions
- Recover catches panics and logs with stack traces
- All wrappers use *slog.Logger for logging
- All tests pass
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
# Full package test with coverage
go test ./cronx/... -v -cover

# Verify no new external dependencies
go list -m all | grep -v "github.com/petabytecl/gaz" | wc -l

# Integration test - create cron, add job, start, stop
go test ./cronx/... -v -run "TestAddBeforeRunning|TestAddWhileRunning"
```
</verification>

<success_criteria>
- [ ] cronx/cron.go exports Cron, Entry, EntryID, Job, FuncJob, New
- [ ] Start() begins scheduler, Stop() returns wait context
- [ ] AddJob/AddFunc register jobs with schedule validation
- [ ] Entries(), Entry(id), Remove(id) provide introspection
- [ ] cronx/chain.go exports SkipIfStillRunning, Recover, DelayIfStillRunning
- [ ] SkipIfStillRunning prevents overlapping job executions (CRN-06)
- [ ] cronx/option.go exports WithLogger, WithChain, WithLocation, WithParser, WithSeconds
- [ ] All components use *slog.Logger (not logx.Logger or cron.Logger interface)
- [ ] All tests pass with no race conditions
</success_criteria>

<output>
After completion, create `.planning/phases/34-cron-package/34-02-SUMMARY.md`
</output>
