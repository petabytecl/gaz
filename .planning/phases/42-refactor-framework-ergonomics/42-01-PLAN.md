---
phase: 42
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app.go
  - app_use.go
  - module_builder.go
autonomous: true
must_haves:
  truths:
    - "App stores flag registration functions internally"
    - "Module application registers flags recursively"
    - "App.Use no longer depends on cobraCmd presence"
  artifacts:
    - path: app.go
      provides: "flagFns storage"
    - path: module_builder.go
      provides: "recursive flag registration"
  key_links:
    - from: "module_builder.Apply"
      to: "app.AddFlagsFn"
      via: "method call"
---

<objective>
Enable deferred flag registration and recursive module flag collection.

Purpose: Decouple flag registration from Cobra command presence, allowing App.Use() to work before App.WithCobra().
Output: App struct with flagFns storage and updated module application logic.
</objective>

<context>
@app.go
@app_use.go
@module_builder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add flag storage to App struct</name>
  <files>app.go</files>
  <action>
    Modify `App` struct in `app.go`:
    1. Add field `flagFns []func(*pflag.FlagSet)`.
    2. Add method `AddFlagsFn(fn func(*pflag.FlagSet))` to append to `flagFns`.
       - Check for nil `fn` before appending.
    
    Ensure `flagFns` is initialized (slice zero value is fine).
  </action>
  <verify>
    Create a test verification script or check syntax.
    `go build ./...`
  </verify>
  <done>
    App struct has `flagFns` and `AddFlagsFn` method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Module.Apply to register flags</name>
  <files>module_builder.go, app_use.go</files>
  <action>
    1. Update `builtModule.Apply` in `module_builder.go`:
       - If `m.flagsFn` is not nil, call `app.AddFlagsFn(m.flagsFn)`.
       - This ensures that when a module is applied, its flags are stored in the app.
       - Since `Apply` calls child modules recursively, their flags will also be registered.

    2. Update `App.Use` in `app_use.go`:
       - Remove the logic that checks `a.cobraCmd` and applies flags immediately.
       - Remove the interface check for `FlagsFn()`.
       - Rely solely on `m.Apply(a)` to handle flag registration (via step 1).
    
    This change makes `App.Use` order-independent regarding `WithCobra`.
  </action>
  <verify>
    `go test ./...`
  </verify>
  <done>
    Flags are registered via `Apply` call, not conditionally in `Use`.
  </done>
</task>

</tasks>

<verification>
Check that `App` compiles and `Use` no longer references `cobraCmd` for flags.
</verification>

<output>
After completion, create .planning/phases/42-refactor-framework-ergonomics/42-01-SUMMARY.md
</output>
