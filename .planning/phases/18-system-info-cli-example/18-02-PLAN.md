---
phase: 18-system-info-cli-example
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - examples/system-info-cli/worker.go
  - examples/system-info-cli/main.go
  - examples/system-info-cli/README.md
autonomous: true

must_haves:
  truths:
    - "Worker refreshes system info at configured interval"
    - "RegisterCobraFlags exposes --sysinfo-* flags in --help"
    - "One-shot mode (--sysinfo-once) displays info and exits"
    - "Continuous mode runs worker until Ctrl+C"
    - "JSON format outputs valid JSON"
  artifacts:
    - path: "examples/system-info-cli/worker.go"
      provides: "RefreshWorker implementing Worker interface"
      exports: ["RefreshWorker", "NewRefreshWorker"]
    - path: "examples/system-info-cli/main.go"
      provides: "CLI entry point with Cobra and gaz integration"
      contains: "RegisterCobraFlags"
    - path: "examples/system-info-cli/README.md"
      provides: "Example documentation"
      min_lines: 30
  key_links:
    - from: "main.go"
      to: "RegisterCobraFlags"
      via: "app.RegisterCobraFlags(rootCmd) before Execute()"
      pattern: "app\\.RegisterCobraFlags\\(rootCmd\\)"
    - from: "main.go"
      to: "Worker registration"
      via: "gaz.For[*RefreshWorker] with Instance"
      pattern: "For\\[\\*RefreshWorker\\].*Instance"
    - from: "worker.go"
      to: "collector.Collect()"
      via: "periodic ticker in goroutine"
      pattern: "collector\\.Collect\\(\\)"
---

<objective>
Complete the system-info-cli example with Worker for continuous monitoring, Cobra CLI integration with RegisterCobraFlags, and documentation.

Purpose: Demonstrate the full gaz pattern: DI registration, ConfigProvider flags visible in --help, Worker auto-discovery and lifecycle management, graceful shutdown.

Output: worker.go (background refresh), main.go (CLI entry point), README.md (documentation)
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-system-info-cli-example/18-RESEARCH.md
@.planning/phases/18-system-info-cli-example/18-01-SUMMARY.md
@examples/cobra-cli/main.go
@examples/config-loading/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RefreshWorker implementing Worker interface</name>
  <files>
    examples/system-info-cli/worker.go
  </files>
  <action>
Create worker.go implementing the gaz Worker interface:

1. RefreshWorker struct with fields:
   - name string
   - interval time.Duration
   - format string
   - collector *Collector
   - done chan struct{}
   - wg sync.WaitGroup

2. NewRefreshWorker(name string, interval time.Duration, format string, collector *Collector) *RefreshWorker

3. Name() string - returns worker name

4. Start() - MUST be non-blocking:
   - Create done channel
   - Add 1 to WaitGroup
   - Spawn goroutine that:
     - Defers wg.Done()
     - Creates ticker with interval
     - Defers ticker.Stop()
     - Initial collection and display on start
     - Loop selecting on done channel (return) or ticker.C (collect and display)

5. Stop() - blocks until goroutine exits:
   - Close done channel
   - Wait on WaitGroup

Important patterns (from 14-03-SUMMARY):
- Start() spawns internal goroutine, returns immediately
- Stop() signals via channel, waits for goroutine to finish
- Worker is auto-discovered during Build() when registered via For[T]()
  </action>
  <verify>
File exists: `ls examples/system-info-cli/worker.go`
  </verify>
  <done>
RefreshWorker implementing Worker interface with non-blocking Start(), graceful Stop(), and periodic Collect()/Display() cycle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create main.go with Cobra CLI and RegisterCobraFlags</name>
  <files>
    examples/system-info-cli/main.go
  </files>
  <action>
Create main.go following the pattern from RESEARCH.md "Complete Main Setup":

1. Package comment explaining the example demonstrates:
   - DI with For[T]() and Resolve[T]()
   - ConfigProvider with ProviderValues
   - Workers with lifecycle integration
   - RegisterCobraFlags for CLI visibility

2. main() function:
   - Create rootCmd with Use: "sysinfo", Short/Long descriptions
   - Create app with gaz.New(gaz.WithShutdownTimeout(5 * time.Second))
   - Register ConfigProvider: gaz.For[*SystemInfoConfig](app.Container()).Provider(NewSystemInfoConfig)
   - Register Collector: gaz.For[*Collector](app.Container()).Provider(NewCollector)
   - CRITICAL: Call app.RegisterCobraFlags(rootCmd) BEFORE rootCmd.Execute()
   - Add runCmd subcommand with RunE: runSysInfo
   - Add versionCmd subcommand printing version
   - Execute rootCmd

3. runSysInfo(cmd *cobra.Command, args []string) error:
   - Call app.WithCobra(cmd) to attach lifecycle
   - Resolve SystemInfoConfig
   - If cfg.Once() is true:
     - Resolve Collector
     - Call Collect() and Display()
     - Return (no worker, app exits)
   - Else (continuous mode):
     - Resolve Collector
     - Create RefreshWorker with config values
     - Register worker: gaz.For[*RefreshWorker](app.Container()).Named("sysinfo-worker").Instance(worker)
     - Print startup message
     - Return app.Run(cmd.Context())

Key patterns (from 17-01-SUMMARY):
- RegisterCobraFlags MUST be called BEFORE Execute() for --help visibility
- Flags appear as --sysinfo-refresh, --sysinfo-format, --sysinfo-once
- Worker registration via Instance() enables auto-discovery during Build()
  </action>
  <verify>
Compile check: `cd examples/system-info-cli && go mod tidy && go build -o /dev/null .`
  </verify>
  <done>
main.go with Cobra CLI, RegisterCobraFlags before Execute, one-shot and continuous modes, Worker auto-discovery.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create README.md documentation</name>
  <files>
    examples/system-info-cli/README.md
  </files>
  <action>
Create README.md documenting the example:

# System Info CLI Example

Brief description: Demonstrates gaz DI framework features with a practical system information CLI.

## Features Demonstrated
- **Dependency Injection**: For[T]() and Resolve[T]() patterns
- **ConfigProvider**: Flag-based config with ProviderValues
- **Workers**: Background data collection with lifecycle
- **Cobra Integration**: RegisterCobraFlags for CLI visibility

## Usage

```bash
# One-shot mode (display and exit)
go run . run --sysinfo-once

# JSON output
go run . run --sysinfo-once --sysinfo-format json

# Continuous monitoring (default 5s refresh)
go run . run

# Custom refresh interval
go run . run --sysinfo-refresh 10s

# View available flags
go run . run --help
```

## Configuration Flags

| Flag | Type | Default | Description |
|------|------|---------|-------------|
| --sysinfo-refresh | duration | 5s | Refresh interval |
| --sysinfo-format | string | text | Output format (text, json) |
| --sysinfo-once | bool | false | Run once and exit |

## Architecture

```
main.go      - CLI entry, Cobra setup, gaz App
config.go    - ConfigProvider with sysinfo flags
collector.go - gopsutil data collection
worker.go    - Background refresh Worker
```

## Key Patterns

1. **ConfigProvider before Execute()**
   - Register ConfigProvider
   - Call RegisterCobraFlags(rootCmd)
   - Then rootCmd.Execute()

2. **Worker lifecycle**
   - Worker registered via For[T]().Instance()
   - Auto-discovered during Build()
   - Starts after services, stops before services

3. **Graceful shutdown**
   - Ctrl+C triggers Stop()
   - Worker waits for current cycle
   - Clean exit
  </action>
  <verify>
File exists and has content: `wc -l examples/system-info-cli/README.md` shows >30 lines
  </verify>
  <done>
README.md with usage examples, flag documentation, architecture diagram, and key patterns.
  </done>
</task>

</tasks>

<verification>
Complete verification of the example:

1. Build: `cd examples/system-info-cli && go build -o sysinfo .`
2. Help shows flags: `./sysinfo run --help` includes --sysinfo-refresh, --sysinfo-format, --sysinfo-once
3. One-shot text: `./sysinfo run --sysinfo-once` displays system info and exits
4. One-shot JSON: `./sysinfo run --sysinfo-once --sysinfo-format json` outputs valid JSON
5. Continuous mode: `./sysinfo run` refreshes every 5s (Ctrl+C to stop - verify graceful shutdown)
6. Version: `./sysinfo version` prints version
7. Clean up: `rm -f sysinfo`
</verification>

<success_criteria>
- `go run . run --help` shows --sysinfo-* flags (RegisterCobraFlags working)
- `go run . run --sysinfo-once` displays system info and exits cleanly
- `go run . run --sysinfo-once --sysinfo-format json` outputs valid JSON
- `go run . run` starts continuous monitoring with periodic refresh
- Ctrl+C triggers graceful shutdown (worker stops cleanly)
- README documents all features and usage patterns
</success_criteria>

<output>
After completion, create `.planning/phases/18-system-info-cli-example/18-02-SUMMARY.md`
</output>
