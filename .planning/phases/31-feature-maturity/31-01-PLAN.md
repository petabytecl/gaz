---
phase: 31-feature-maturity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config/viper/backend.go
  - config/manager.go
  - config/backend.go
  - app.go
autonomous: true

must_haves:
  truths:
    - "WithStrictConfig() option causes Build() to fail if config contains unknown keys"
    - "Config validation happens after all sources merged (file + env)"
    - "Default behavior unchanged (non-strict mode) for backward compatibility"
  artifacts:
    - path: "config/viper/backend.go"
      provides: "UnmarshalStrict method using mapstructure ErrorUnused"
      contains: "ErrorUnused"
    - path: "config/manager.go"
      provides: "LoadIntoStrict method for strict config validation"
      exports: ["LoadIntoStrict"]
    - path: "app.go"
      provides: "WithStrictConfig() option"
      contains: "strictConfig"
  key_links:
    - from: "app.go"
      to: "config/manager.go"
      via: "LoadIntoStrict call when strictConfig flag set"
      pattern: "LoadIntoStrict"
    - from: "config/manager.go"
      to: "config/viper/backend.go"
      via: "UnmarshalStrict delegation"
      pattern: "UnmarshalStrict"
---

<objective>
Implement strict configuration validation via WithStrictConfig() option

Purpose: Catch typos and obsolete configuration keys by failing at startup if config file contains unregistered keys
Output: WithStrictConfig() option, UnmarshalStrict in viper backend, LoadIntoStrict in Manager
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-feature-maturity/31-RESEARCH.md

@config/viper/backend.go
@config/manager.go
@config/backend.go
@app.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UnmarshalStrict to viper backend and StrictUnmarshaler interface</name>
  <files>config/viper/backend.go, config/backend.go</files>
  <action>
In config/viper/backend.go:
1. Add strictDecoderOption function that sets dc.ErrorUnused = true:
   ```go
   func strictDecoderOption(dc *mapstructure.DecoderConfig) {
       dc.ErrorUnused = true
   }
   ```

2. Add UnmarshalStrict method to Backend:
   ```go
   // UnmarshalStrict unmarshals config into target, failing if config contains
   // keys that don't map to struct fields. This catches typos and obsolete config.
   func (b *Backend) UnmarshalStrict(target any) error {
       return b.v.Unmarshal(target, strictDecoderOption)
   }
   ```

In config/backend.go:
3. Add StrictUnmarshaler interface:
   ```go
   // StrictUnmarshaler is implemented by backends that support strict unmarshal.
   // Strict unmarshal fails if config contains keys that don't map to struct fields.
   type StrictUnmarshaler interface {
       UnmarshalStrict(target any) error
   }
   ```

4. Add compile-time assertion in backend.go for Backend implementing StrictUnmarshaler
  </action>
  <verify>
Run: `go build ./config/...` - compiles without error
Run: `go test ./config/viper/... -run TestUnmarshalStrict` - test passes (if test exists) or no error
  </verify>
  <done>
UnmarshalStrict method exists in viper Backend using ErrorUnused=true.
StrictUnmarshaler interface defined in config package.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add LoadIntoStrict to config Manager</name>
  <files>config/manager.go</files>
  <action>
Add LoadIntoStrict method to Manager that:
1. Performs same steps as LoadInto (bind env, Load, apply defaults, validate)
2. Uses StrictUnmarshaler interface if backend implements it:
   ```go
   // LoadIntoStrict loads configuration and unmarshals with strict validation.
   // Unlike LoadInto, this fails if the config contains keys that don't map
   // to fields in the target struct. Use this to catch typos and obsolete config.
   func (m *Manager) LoadIntoStrict(target any) error {
       if target == nil {
           return nil
       }

       // Bind struct env vars before loading
       if m.envPrefix != "" {
           if eb, ok := m.backend.(EnvBinder); ok {
               m.bindStructEnv(eb, target, "")
           }
       }

       // Load from files/env
       if err := m.Load(); err != nil {
           return err
       }

       // Use strict unmarshal if backend supports it
       if su, ok := m.backend.(StrictUnmarshaler); ok {
           if err := su.UnmarshalStrict(target); err != nil {
               return fmt.Errorf("config: strict validation failed: %w", err)
           }
       } else {
           // Fallback to normal unmarshal
           if err := m.backend.Unmarshal(target); err != nil {
               return fmt.Errorf("config: failed to unmarshal: %w", err)
           }
       }

       // Apply Defaulter interface
       if d, ok := target.(Defaulter); ok {
           d.Default()
       }

       // Validate using struct tags
       if err := ValidateStruct(target); err != nil {
           return err
       }

       // Validate using Validator interface
       if v, ok := target.(Validator); ok {
           if err := v.Validate(); err != nil {
               return fmt.Errorf("config: custom validation failed: %w", err)
           }
       }

       return nil
   }
   ```

Note: StrictUnmarshaler interface added in Task 1.
  </action>
  <verify>
Run: `go build ./config/...` - compiles without error
Run: `go test ./config/... -v` - existing tests pass
  </verify>
  <done>
Manager.LoadIntoStrict() method exists that uses StrictUnmarshaler interface.
Strict validation errors wrapped with clear message.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add WithStrictConfig() option to App and wire to loadConfig</name>
  <files>app.go</files>
  <action>
1. Add strictConfig field to App struct:
   ```go
   strictConfig bool // enables strict config validation
   ```

2. Add WithStrictConfig option function:
   ```go
   // WithStrictConfig enables strict configuration validation.
   // If enabled, Build() fails if the config file contains any keys
   // that are not mapped to fields in the config struct.
   // This helps catch typos and obsolete configuration.
   //
   // Strict validation is only applied when a config target is set
   // via WithConfig(). It has no effect on ConfigProvider pattern.
   func WithStrictConfig() Option {
       return func(a *App) {
           a.strictConfig = true
       }
   }
   ```

3. Modify loadConfig() method to use LoadIntoStrict when strictConfig is true:
   Replace this block:
   ```go
   if a.configTarget != nil {
       if err := a.configMgr.LoadInto(a.configTarget); err != nil {
           return fmt.Errorf("loading config into target: %w", err)
       }
   }
   ```
   With:
   ```go
   if a.configTarget != nil {
       if a.strictConfig {
           if err := a.configMgr.LoadIntoStrict(a.configTarget); err != nil {
               return fmt.Errorf("loading config (strict mode): %w", err)
           }
       } else {
           if err := a.configMgr.LoadInto(a.configTarget); err != nil {
               return fmt.Errorf("loading config into target: %w", err)
           }
       }
   }
   ```
  </action>
  <verify>
Run: `go build .` - compiles without error
Run: `go test . -run TestWithStrictConfig` - test passes (if exists) or create one
Run: `go test ./... -count=1` - all tests pass
  </verify>
  <done>
WithStrictConfig() option exists and wires to loadConfig().
loadConfig uses LoadIntoStrict when strictConfig is true.
FEAT-01 complete.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` passes
2. `go test ./... -count=1` passes (all existing tests)
3. Manual test: Create app with `WithStrictConfig()`, config file with unknown key -> Build() fails
4. Manual test: Same app without `WithStrictConfig()` -> Build() succeeds (backward compat)
</verification>

<success_criteria>
- [ ] UnmarshalStrict in viper backend uses mapstructure ErrorUnused=true
- [ ] StrictUnmarshaler interface defined in config package
- [ ] LoadIntoStrict in Manager delegates to StrictUnmarshaler
- [ ] WithStrictConfig() option exists in gaz package
- [ ] loadConfig() uses LoadIntoStrict when strictConfig flag is set
- [ ] All existing tests pass
- [ ] FEAT-01 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/31-feature-maturity/31-01-SUMMARY.md`
</output>
