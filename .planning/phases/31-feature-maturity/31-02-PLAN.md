---
phase: 31-feature-maturity
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - worker/options.go
  - worker/supervisor.go
autonomous: true

must_haves:
  truths:
    - "Dead letter handler is invoked when circuit breaker trips (not on individual panics)"
    - "Handler receives worker name, final error, panic count, and timestamp"
    - "Handler panics are recovered and logged (don't crash supervisor)"
    - "Default behavior unchanged when no handler configured"
  artifacts:
    - path: "worker/options.go"
      provides: "DeadLetterInfo struct, DeadLetterHandler type, WithDeadLetterHandler option"
      contains: "DeadLetterHandler"
    - path: "worker/supervisor.go"
      provides: "invokeDeadLetterHandler method with panic recovery"
      contains: "invokeDeadLetterHandler"
  key_links:
    - from: "worker/supervisor.go"
      to: "worker/options.go"
      via: "s.opts.OnDeadLetter invocation"
      pattern: "OnDeadLetter"
---

<objective>
Implement worker dead letter handling via callback pattern

Purpose: Allow applications to be notified when workers permanently fail (circuit breaker trips) for logging, alerting, or persistence
Output: DeadLetterInfo struct, DeadLetterHandler type, WithDeadLetterHandler option, supervisor integration
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-feature-maturity/31-RESEARCH.md

@worker/options.go
@worker/supervisor.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DeadLetterInfo, DeadLetterHandler, and WithDeadLetterHandler option</name>
  <files>worker/options.go</files>
  <action>
1. Add DeadLetterInfo struct (before WorkerOptions):
   ```go
   // DeadLetterInfo contains information about a worker that has permanently failed.
   // This is passed to the DeadLetterHandler when the circuit breaker trips.
   type DeadLetterInfo struct {
       // WorkerName is the name of the failed worker
       WorkerName string
       // FinalError is the last error or panic value before the circuit tripped
       FinalError error
       // PanicCount is the number of panics/failures in the circuit window
       PanicCount int
       // CircuitWindow is the duration of the failure tracking window
       CircuitWindow time.Duration
       // Timestamp is when the circuit breaker tripped
       Timestamp time.Time
   }

   // DeadLetterHandler is called when a worker exhausts restart attempts
   // and the circuit breaker trips. Use this to log, alert, persist to
   // external queue, or take other action on permanently failed workers.
   //
   // The handler is wrapped in recover() to prevent handler panics from
   // crashing the supervisor.
   type DeadLetterHandler func(info DeadLetterInfo)
   ```

2. Add OnDeadLetter field to WorkerOptions struct:
   ```go
   // OnDeadLetter is called when the circuit breaker trips.
   // Use this to log, alert, or persist failed worker info.
   // The handler is wrapped in recover() for safety.
   OnDeadLetter DeadLetterHandler
   ```

3. Add WithDeadLetterHandler option function:
   ```go
   // WithDeadLetterHandler sets a callback for dead letter handling.
   // The handler is called when a worker's circuit breaker trips
   // (after MaxRestarts failures within CircuitWindow).
   //
   // Use this to implement logging, alerting, or external persistence
   // for permanently failed workers.
   //
   // Example:
   //
   //	manager.Register(worker, WithDeadLetterHandler(func(info DeadLetterInfo) {
   //	    log.Error("worker permanently failed",
   //	        "name", info.WorkerName,
   //	        "error", info.FinalError,
   //	        "panics", info.PanicCount,
   //	    )
   //	    // Optionally persist to external queue, send alert, etc.
   //	}))
   func WithDeadLetterHandler(fn DeadLetterHandler) WorkerOption {
       return func(o *WorkerOptions) {
           o.OnDeadLetter = fn
       }
   }
   ```
  </action>
  <verify>
Run: `go build ./worker/...` - compiles without error
  </verify>
  <done>
DeadLetterInfo struct and DeadLetterHandler type defined.
OnDeadLetter field added to WorkerOptions.
WithDeadLetterHandler option function created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Invoke dead letter handler in supervisor when circuit trips</name>
  <files>worker/supervisor.go</files>
  <action>
1. Add lastError field to supervisor struct to track the final error:
   ```go
   // Last error for dead letter reporting
   lastError error
   ```

2. In runWithRecovery(), capture panic value as error for dead letter reporting.
   After the recover() block that logs the panic, add:
   ```go
   // After: s.logger.Error("worker panicked", ...)
   s.lastError = fmt.Errorf("panic: %v", r)
   ```

   Also capture start failure error:
   ```go
   // After: s.logger.Error("worker failed to start", slog.Any("error", err))
   s.lastError = err
   ```

3. Add invokeDeadLetterHandler method with panic protection:
   ```go
   // invokeDeadLetterHandler calls the dead letter handler with panic recovery.
   // This ensures a buggy handler doesn't crash the supervisor.
   func (s *supervisor) invokeDeadLetterHandler() {
       if s.opts.OnDeadLetter == nil {
           return
       }

       defer func() {
           if r := recover(); r != nil {
               s.logger.Error("dead letter handler panicked",
                   slog.Any("panic", r),
               )
           }
       }()

       info := DeadLetterInfo{
           WorkerName:    s.worker.Name(),
           FinalError:    s.lastError,
           PanicCount:    s.failures,
           CircuitWindow: s.opts.CircuitWindow,
           Timestamp:     time.Now(),
       }
       s.opts.OnDeadLetter(info)
   }
   ```

4. In supervise(), invoke handler when circuit breaker trips.
   Find the block:
   ```go
   // Check if circuit breaker should trip
   if s.failures >= s.opts.MaxRestarts {
       s.logger.Error("circuit breaker tripped", ...)
   ```

   After the error log and BEFORE the critical worker check, add:
   ```go
   // Invoke dead letter handler if configured
   s.invokeDeadLetterHandler()
   ```

5. Import "fmt" at top if not already imported (needed for fmt.Errorf in panic capture)
  </action>
  <verify>
Run: `go build ./worker/...` - compiles without error
Run: `go test ./worker/... -v` - all tests pass
Run: `go test ./... -count=1` - all project tests pass
  </verify>
  <done>
invokeDeadLetterHandler method exists with panic recovery.
Dead letter handler invoked when circuit breaker trips.
lastError tracked for inclusion in DeadLetterInfo.
FEAT-02 complete.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` passes
2. `go test ./... -count=1` passes (all existing tests)
3. Manual test: Register worker with WithDeadLetterHandler, make it panic repeatedly -> handler called with correct info
4. Manual test: Handler that panics itself -> supervisor logs error but doesn't crash
5. Manual test: Worker without handler -> existing behavior unchanged
</verification>

<success_criteria>
- [ ] DeadLetterInfo struct exists with WorkerName, FinalError, PanicCount, CircuitWindow, Timestamp
- [ ] DeadLetterHandler type defined
- [ ] WithDeadLetterHandler option function exists
- [ ] OnDeadLetter field added to WorkerOptions
- [ ] invokeDeadLetterHandler method has defer/recover protection
- [ ] Dead letter handler invoked only when circuit breaker trips (not individual panics)
- [ ] All existing tests pass
- [ ] FEAT-02 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/31-feature-maturity/31-02-SUMMARY.md`
</output>
