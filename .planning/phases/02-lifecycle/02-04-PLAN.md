---
phase: 02
plan: 04
type: execute
wave: 3
depends_on: [02-03]
files_modified: [app.go, app_test.go]
autonomous: true
must_haves:
  truths:
    - "App.Run() starts services and waits"
    - "App handles SIGTERM/SIGINT"
    - "App.Stop() shuts down gracefully"
    - "Hooks receive context with timeouts"
  artifacts:
    - path: "app.go"
      provides: "gaz.App struct and Run method"
  key_links:
    - from: "gaz.NewApp"
      to: "Container"
      via: "composition"
    - from: "App.Run"
      to: "LifecycleEngine"
      via: "execution"
---

<objective>
Implement the Application Runtime wrapper.

Purpose: Provide the high-level API for running the application, managing signals, and orchestrating the lifecycle.
Output: `gaz.App` struct and `Run` method.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@lifecycle_engine.go
@container.go

# Combines Container, Graph, and Engine into a usable App
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create App Struct</name>
  <files>app.go</files>
  <action>
    Create `app.go`:
    - `type App struct { container *Container, opts AppOptions }`
    - `NewApp(c *Container, opts ...AppOption) *App`
    - Options: `WithShutdownTimeout(time.Duration)`
  </action>
  <verify>
    Compilation.
  </verify>
  <done>
    App struct defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Run and Stop</name>
  <files>app.go</files>
  <action>
    Implement `Run(ctx context.Context) error`:
    - Call `c.Build()`.
    - Retrieve graph from container.
    - Call `ComputeStartupOrder` (from Plan 03).
    - Execute `Start` on services layer by layer.
    - If error, rollback (call Stop).
    - Block until `Stop()` called or Signal received.
    
    Implement `Stop(ctx context.Context) error`:
    - Compute shutdown order.
    - Execute `Stop` on services.
  </action>
  <verify>
    Unit tests in `app_test.go` mocking the start/stop flow.
  </verify>
  <done>
    Run/Stop logic implemented.
  </done>
</task>

<task type="auto">
  <name>Task 3: Signal Handling</name>
  <files>app.go</files>
  <action>
    Enhance `Run` to handle signals:
    - Create `notify` channel for `os.Interrupt`, `syscall.SIGTERM`.
    - Select on signal channel.
    - If signal received, create context with timeout (configured in Task 1).
    - Call `Stop(ctx)`.
  </action>
  <verify>
    Test by sending signal to running app (in test).
  </verify>
  <done>
    App shuts down on SIGTERM.
  </done>
</task>

</tasks>

<verification>
Create an integration test in `app_test.go` that:
1. Registers services with Start/Stop hooks.
2. Runs the app in a goroutine.
3. Sends a signal.
4. Verifies start order and stop order (via logs or state checks).
</verification>

<success_criteria>
- [ ] App.Run() blocks until signal
- [ ] OnStart hooks run in order
- [ ] OnStop hooks run in reverse order
- [ ] Graceful shutdown on SIGTERM
</success_criteria>

<output>
After completion, create `.planning/phases/02-lifecycle/02-04-SUMMARY.md`
</output>
