---
phase: 43-logger-cli-flags
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app.go
  - cobra.go
  - app_test.go
  - cobra_test.go
autonomous: true

must_haves:
  truths:
    - "WithCobra(cmd) is a gaz.Option passed to gaz.New(), not a method"
    - "Logger is NOT created in New() - it is nil until Build()"
    - "Logger is created in Build() using resolved logger.Config or defaults"
    - "WorkerManager, Scheduler, EventBus are created in Build() after Logger"
    - "Existing tests pass after updating for new initialization pattern"
  artifacts:
    - path: "app.go"
      provides: "Deferred logger/subsystem initialization in Build()"
      contains: "initializeLogger"
    - path: "cobra.go"
      provides: "WithCobra as Option function, updated lifecycle hooks"
      contains: "func WithCobra"
    - path: "app_test.go"
      provides: "Updated tests for deferred initialization"
      min_lines: 200
    - path: "cobra_test.go"
      provides: "Updated tests for WithCobra as Option"
      min_lines: 100
  key_links:
    - from: "app.go"
      to: "logger/config.go"
      via: "Resolve logger.Config in Build()"
      pattern: "Resolve.*logger\\.Config"
    - from: "app.go"
      to: "cobra.go"
      via: "WithCobra Option sets cobraCmd in App"
      pattern: "WithCobra.*Option"
    - from: "cobra.go"
      to: "app.go"
      via: "Option stores cmd, hooks call Build/Start/Stop"
      pattern: "a\\.cobraCmd.*=.*cmd"
---

<objective>
Restructure App initialization to defer Logger and subsystem creation until Build(), enabling flag values to be available before Logger is created.

Purpose: The logger is currently created immediately in `gaz.New()` with hardcoded defaults BEFORE any modules are loaded and BEFORE flags are parsed. This must change so logger CLI flags can work. No backward compatibility needed - breaking changes allowed.

Output: Refactored app.go and cobra.go with deferred initialization, updated tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-logger-cli-flags/43-CONTEXT.md
@.planning/phases/42-refactor-framework-ergonomics/42-01-SUMMARY.md
@.planning/phases/42-refactor-framework-ergonomics/42-02-SUMMARY.md

# Key files to modify
@app.go
@cobra.go
@logger/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor App to defer Logger and subsystem initialization</name>
  <files>app.go, cobra.go</files>
  <action>
**Part A: Update app.go - Defer initialization from New() to Build()**

1. In `New()`, REMOVE these lines (currently around lines 180-215):
   - Logger creation and configuration
   - WorkerManager initialization
   - Scheduler initialization  
   - EventBus initialization
   - Logger registration in container
   - EventBus registration in container

2. In `New()`, KEEP:
   - Container creation
   - Options application
   - ConfigManager initialization
   - modules map initialization

3. Add a new `initializeLogger()` method:
   ```go
   // initializeLogger creates the logger from resolved config or defaults.
   // Called during Build() after config is loaded and flags are parsed.
   func (a *App) initializeLogger() error {
       // Check if logger.Config is available (logger module registered)
       cfg, err := Resolve[logger.Config](a.container)
       if err != nil {
           // No logger module - use defaults or app option
           if a.opts.LoggerConfig == nil {
               a.opts.LoggerConfig = &logger.Config{
                   Level:  slog.LevelInfo,
                   Format: "text",
               }
           }
           a.Logger = logger.NewLogger(a.opts.LoggerConfig)
       } else {
           // Logger module provided config - use it
           a.Logger = logger.NewLogger(&cfg)
       }
       
       // Register Logger in container
       return For[*slog.Logger](a.container).Instance(a.Logger)
   }
   ```

4. Add a new `initializeSubsystems()` method:
   ```go
   // initializeSubsystems creates WorkerManager, Scheduler, EventBus.
   // Called during Build() after logger is initialized.
   func (a *App) initializeSubsystems() error {
       // WorkerManager
       a.workerMgr = worker.NewManager(a.Logger)
       a.workerMgr.SetCriticalFailHandler(func() {
           a.Logger.Error("critical worker failed, initiating shutdown")
           go func() {
               ctx, cancel := context.WithTimeout(context.Background(), a.opts.ShutdownTimeout)
               defer cancel()
               _ = a.Stop(ctx)
           }()
       })
       
       // Scheduler
       a.scheduler = cron.NewScheduler(a.container, context.Background(), a.Logger)
       
       // EventBus
       a.eventBus = eventbus.New(a.Logger)
       
       // Register EventBus in container
       return For[*eventbus.EventBus](a.container).Instance(a.eventBus)
   }
   ```

5. In `Build()`, add calls to these methods BEFORE collectProviderConfigs():
   - After `registerProviderValuesEarly()` succeeds
   - Add: `if err := a.initializeLogger(); err != nil { errs = append(errs, err) }`
   - Add: `if err := a.initializeSubsystems(); err != nil { errs = append(errs, err) }`
   - These must be BEFORE discoverWorkers() since it uses workerMgr

6. Add a `loggerInitialized` field to App struct to track state and prevent double-init.

7. Update any methods that access Logger before Build() to handle nil Logger gracefully (e.g., use slog.Default() as fallback).

**Part B: Update cobra.go - Make WithCobra an Option**

1. Convert `WithCobra(cmd)` from method to Option function:
   ```go
   // WithCobra attaches the App lifecycle to a Cobra command.
   // This is now an Option passed to gaz.New(), not a method.
   func WithCobra(cmd *cobra.Command) Option {
       return func(a *App) {
           a.cobraCmd = cmd
           
           // Preserve existing hooks
           originalPreRunE := cmd.PersistentPreRunE
           originalPostRunE := cmd.PersistentPostRunE
           
           cmd.PersistentPreRunE = func(c *cobra.Command, args []string) error {
               // Chain original hook first
               if originalPreRunE != nil {
                   if err := originalPreRunE(c, args); err != nil {
                       return err
                   }
               }
               
               ctx := c.Context()
               if ctx == nil {
                   ctx = context.Background()
               }
               
               // Apply any pending flags NOW (before bootstrap)
               for _, fn := range a.flagFns {
                   fn(cmd.PersistentFlags())
               }
               
               if err := a.bootstrap(ctx, c, args); err != nil {
                   return err
               }
               
               c.SetContext(context.WithValue(ctx, contextKey{}, a))
               return nil
           }
           
           cmd.PersistentPostRunE = func(c *cobra.Command, args []string) error {
               stopCtx, cancel := context.WithTimeout(context.Background(), a.opts.ShutdownTimeout)
               defer cancel()
               
               stopErr := a.Stop(stopCtx)
               
               a.mu.Lock()
               a.running = false
               a.mu.Unlock()
               
               if originalPostRunE != nil {
                   if err := originalPostRunE(c, args); err != nil {
                       return errors.Join(stopErr, err)
                   }
               }
               return stopErr
           }
           
           // Inject default RunE if none defined
           if cmd.Run == nil && cmd.RunE == nil {
               cmd.RunE = func(c *cobra.Command, args []string) error {
                   return a.waitForShutdownSignal(c.Context())
               }
           }
       }
   }
   ```

2. REMOVE the old `(a *App) WithCobra(cmd) *App` method entirely.

3. Update `AddFlagsFn` to store flags but NOT apply immediately (flags applied in PersistentPreRunE):
   - Keep storing in `a.flagFns`
   - Remove the immediate application when `a.cobraCmd != nil`
  </action>
  <verify>
go build ./... && go vet ./...
  </verify>
  <done>
WithCobra is now an Option function, not a method.
New() no longer creates Logger/WorkerManager/Scheduler/EventBus.
Build() initializes Logger from resolved config or defaults, then subsystems.
Project compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tests for new initialization pattern</name>
  <files>app_test.go, cobra_test.go</files>
  <action>
**Part A: Update app_test.go**

1. Find all tests that access `app.Logger` immediately after `New()`:
   - These must be updated to call `Build()` first
   - OR check for nil Logger and use slog.Default()

2. Update test patterns:
   - Before: `app := gaz.New(); app.Logger.Info(...)`
   - After: `app := gaz.New(); _ = app.Build(); app.Logger.Info(...)`

3. Add new test `TestLoggerInitializedInBuild`:
   ```go
   func (s *AppTestSuite) TestLoggerInitializedInBuild() {
       app := gaz.New()
       
       // Before Build, Logger should be nil
       s.Nil(app.Logger, "Logger should be nil before Build()")
       
       // After Build, Logger should be initialized
       err := app.Build()
       s.Require().NoError(err)
       s.NotNil(app.Logger, "Logger should be initialized after Build()")
   }
   ```

4. Add test for logger.Config resolution:
   ```go
   func (s *AppTestSuite) TestLoggerConfigResolution() {
       app := gaz.New()
       
       // Register logger.Config manually
       cfg := logger.Config{Level: slog.LevelDebug, Format: "json"}
       err := gaz.For[logger.Config](app.Container()).Instance(cfg)
       s.Require().NoError(err)
       
       // Build should use the registered config
       err = app.Build()
       s.Require().NoError(err)
       s.NotNil(app.Logger)
       // Logger level is internal, can verify via output or just check no error
   }
   ```

5. Update any tests that depend on WorkerManager, Scheduler, EventBus being available immediately after New().

**Part B: Update cobra_test.go**

1. Update test to use Option pattern:
   - Before: `app := gaz.New(); app.WithCobra(cmd)`
   - After: `app := gaz.New(gaz.WithCobra(cmd))`

2. Update `TestWithCobraInjectsDefaultRunE`:
   ```go
   func (s *AppTestSuite) TestWithCobraInjectsDefaultRunE() {
       cmd := &cobra.Command{Use: "test"}
       app := gaz.New(gaz.WithCobra(cmd))
       
       // Verify cmd has RunE injected
       s.NotNil(cmd.RunE, "WithCobra should inject default RunE")
       
       // Verify Logger is nil before cmd execution
       s.Nil(app.Logger)
   }
   ```

3. Add test verifying flag application timing:
   ```go
   func (s *AppTestSuite) TestWithCobraFlagsAppliedBeforeBuild() {
       cmd := &cobra.Command{Use: "test"}
       var flagValue string
       
       app := gaz.New(gaz.WithCobra(cmd))
       app.AddFlagsFn(func(fs *pflag.FlagSet) {
           fs.StringVar(&flagValue, "test-flag", "default", "test flag")
       })
       
       // Simulate command execution
       cmd.SetArgs([]string{"--test-flag=custom"})
       // Flags should be parsed and bound during PersistentPreRunE
   }
   ```

4. Update any tests that called `.WithCobra()` as a method.
  </action>
  <verify>
go test -race -v ./... && make lint
  </verify>
  <done>
All tests updated to use WithCobra as Option.
Tests verify Logger is nil before Build() and initialized after.
Tests verify subsystems initialized in Build().
All tests pass with race detection.
Linter passes.
  </done>
</task>

</tasks>

<verification>
```bash
# Build and vet
go build ./...
go vet ./...

# Run all tests with race detection
go test -race -v ./...

# Run linter
make lint

# Verify examples still compile
go build ./examples/...
```
</verification>

<success_criteria>
- [ ] WithCobra is an Option function (gaz.WithCobra(cmd)), not a method
- [ ] Logger is nil immediately after New(), created in Build()
- [ ] Build() resolves logger.Config if registered, otherwise uses defaults
- [ ] WorkerManager, Scheduler, EventBus initialized in Build() after Logger
- [ ] All existing tests updated and passing
- [ ] Examples compile without changes (they already call Build)
- [ ] Linter passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/43-logger-cli-flags/43-01-SUMMARY.md`
</output>
