---
phase: 43-logger-cli-flags
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - logger/config.go
  - logger/provider.go
  - logger/module.go
  - logger/module_test.go
autonomous: true

must_haves:
  truths:
    - "User can set log level via --log-level flag (debug, info, warn, error)"
    - "User can set log format via --log-format flag (text, json)"
    - "User can set log output via --log-output flag (stdout, stderr, or file path)"
    - "User can enable source location via --log-add-source flag"
    - "Invalid level or format errors immediately with clear message"
    - "File output gracefully falls back to stdout on error"
  artifacts:
    - path: "logger/config.go"
      provides: "Config with Output field, Flags(), Namespace(), Validate(), SetDefaults(), DefaultConfig()"
      exports: ["Config", "DefaultConfig"]
    - path: "logger/provider.go"
      provides: "NewLogger supporting output destinations (stdout, stderr, file)"
      exports: ["NewLogger"]
    - path: "logger/module.go"
      provides: "NewModule following gateway pattern with flag registration"
      exports: ["NewModule"]
    - path: "logger/module_test.go"
      provides: "Tests for module, config validation, flag binding"
      min_lines: 50
  key_links:
    - from: "logger/module.go"
      to: "gaz.NewModule"
      via: "Flags(defaultCfg.Flags)"
      pattern: "gaz\\.NewModule.*Flags"
    - from: "logger/module.go"
      to: "logger/provider.go"
      via: "NewLogger provider registration"
      pattern: "NewLogger"
    - from: "logger/provider.go"
      to: "logger/config.go"
      via: "Config.Output field"
      pattern: "cfg\\.Output"
---

<objective>
Enable logger module to register CLI flags for runtime configuration of log format, level, output destination, and source location.

Purpose: Users can configure logging behavior via CLI flags (--log-level, --log-format, --log-output, --log-add-source) following the established ConfigProvider pattern from Phase 41-42.

Output: Complete logger module with CLI flag support, validation, and tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-logger-cli-flags/43-CONTEXT.md

# Existing logger files to modify
@logger/config.go
@logger/provider.go

# Pattern to follow
@server/gateway/config.go
@server/gateway/module.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Config and Provider with CLI flag support</name>
  <files>logger/config.go, logger/provider.go</files>
  <action>
Update logger/config.go:

1. Add Output field to Config struct:
   - `Output string` - accepts "stdout" (default), "stderr", or file path
   - Add struct tags: `json:"output" yaml:"output" mapstructure:"output" gaz:"output"`

2. Add internal levelName field to Config:
   - `levelName string` - used by Flags() for string level binding
   - NOT exported, only used internally for flag binding

3. Add DefaultConfig() function returning Config with:
   - Level: slog.LevelInfo
   - levelName: "info"
   - Format: "text" (changed from json - per CONTEXT.md decisions)
   - Output: "stdout"
   - AddSource: false

4. Add Namespace() method: returns "log"

5. Add Flags(fs *pflag.FlagSet) method:
   - `--log-level` (string): "debug", "info", "warn", "error". Bind to c.levelName. Default: "info"
   - `--log-format` (string): "text" or "json". Bind to c.Format. Default: "text"
   - `--log-output` (string): "stdout", "stderr", or file path. Bind to c.Output. Default: "stdout"
   - `--log-add-source` (bool): Enable file:line in logs. Bind to c.AddSource. Default: false

6. Add Validate() error method:
   - Validate levelName: must be one of "debug", "info", "warn", "error"
   - Validate Format: must be "text" or "json"
   - Convert levelName to Level field (call parseLevel helper)
   - Return error with clear message listing valid options on invalid input

7. Add SetDefaults() method:
   - If Format == "", set to "text"
   - If Output == "", set to "stdout"
   - If levelName == "", set to "info" and Level to slog.LevelInfo

8. Add parseLevel(name string) (slog.Level, error) helper:
   - "debug" -> slog.LevelDebug
   - "info" -> slog.LevelInfo
   - "warn" -> slog.LevelWarn
   - "error" -> slog.LevelError
   - Default: error with valid options

Update logger/provider.go:

1. Change NewLogger signature to accept io.Writer output parameter:
   - `NewLogger(cfg *Config, output io.Writer) *slog.Logger`

2. Add NewLoggerFromConfig(cfg *Config) (*slog.Logger, error) function:
   - Determine output writer based on cfg.Output:
     - "stdout" -> os.Stdout
     - "stderr" -> os.Stderr
     - file path -> os.OpenFile with O_APPEND|O_CREATE|O_WRONLY, 0644
   - On file open error: log warning to stderr and fall back to os.Stdout
   - Call NewLogger(cfg, output) and return

3. Update NewLogger to use the provided io.Writer:
   - Replace hardcoded os.Stdout with the output parameter
  </action>
  <verify>
go build ./logger/...
go vet ./logger/...
  </verify>
  <done>
Config has Output field, Flags(), Namespace(), Validate(), SetDefaults(), DefaultConfig().
Provider supports stdout, stderr, and file output destinations.
Both files compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create logger module and tests</name>
  <files>logger/module.go, logger/module_test.go</files>
  <action>
Create logger/module.go following gateway/module.go pattern:

1. NewModule() function returning gaz.Module:
   - Create defaultCfg := DefaultConfig()
   - Use gaz.NewModule("logger")
   - Chain .Flags(defaultCfg.Flags)
   - Chain .Provide() with config provider:
     - Register Config provider using gaz.For[Config](c).Provider()
     - Start with defaultCfg (has flags bound)
     - Resolve *gaz.ProviderValues if available
     - UnmarshalKey with cfg.Namespace() to load config
     - Call cfg.SetDefaults()
     - Call cfg.Validate() - return error on validation failure
     - Return cfg
   - Chain .Provide() with logger provider:
     - Register *slog.Logger using gaz.For[*slog.Logger](c).Provider()
     - Resolve Config
     - Call NewLoggerFromConfig(cfg)
   - Chain .Build()

Create logger/module_test.go:

1. TestModuleRegistration:
   - Create gaz.App with logger.NewModule()
   - Verify Config and *slog.Logger are resolvable
   - Verify default values (level=info, format=text, output=stdout)

2. TestConfigValidation:
   - Test invalid level returns error with valid options listed
   - Test invalid format returns error with valid options listed
   - Test valid combinations succeed

3. TestConfigFlags:
   - Create Config, call Flags() on pflag.FlagSet
   - Verify flags are registered with correct defaults
   - Parse flags with custom values, verify they're bound

4. TestOutputDestinations:
   - Test "stdout" works
   - Test "stderr" works
   - Test file path creates file and appends
   - Test invalid file path (e.g., "/nonexistent/path") falls back to stdout with warning
  </action>
  <verify>
go test -race -v ./logger/...
make lint
  </verify>
  <done>
NewModule() creates a gaz.Module that registers Config and *slog.Logger.
All tests pass including config validation, flag binding, and output destinations.
Linter passes with no errors.
  </done>
</task>

</tasks>

<verification>
```bash
# Build and vet
go build ./logger/...
go vet ./logger/...

# Run tests with race detection
go test -race -v ./logger/...

# Run linter
make lint

# Verify integration (manual sanity check)
# Create a simple test app that uses logger.NewModule() with flags
```
</verification>

<success_criteria>
- [ ] Config has Output field, Flags(), Namespace(), Validate(), SetDefaults()
- [ ] NewLogger accepts io.Writer parameter
- [ ] NewLoggerFromConfig handles stdout/stderr/file output
- [ ] File output errors fall back to stdout with warning
- [ ] NewModule() returns gaz.Module with flag registration
- [ ] Invalid level/format errors immediately with clear message
- [ ] All tests pass with race detection
- [ ] Linter passes with no errors
- [ ] Coverage maintained above 90%
</success_criteria>

<output>
After completion, create `.planning/phases/43-logger-cli-flags/43-01-SUMMARY.md`
</output>
