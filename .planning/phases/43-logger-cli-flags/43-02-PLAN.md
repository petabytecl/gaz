---
phase: 43-logger-cli-flags
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - logger/config.go
  - logger/provider.go
  - logger/module.go
  - logger/module_test.go
autonomous: true

must_haves:
  truths:
    - "User can set log level via --log-level flag (debug, info, warn, error)"
    - "User can set log format via --log-format flag (text, json)"
    - "User can set log output via --log-output flag (stdout, stderr, or file path)"
    - "User can enable source location via --log-add-source flag"
    - "Invalid level or format errors immediately with clear message"
    - "File output gracefully falls back to stdout on error"
    - "logger.NewModule() provides logger.Config (not *slog.Logger) to container"
  artifacts:
    - path: "logger/config.go"
      provides: "Config with Output field, Flags(), Namespace(), Validate(), SetDefaults(), DefaultConfig()"
      exports: ["Config", "DefaultConfig"]
    - path: "logger/provider.go"
      provides: "NewLogger with output resolution, NewLoggerWithWriter for testing"
      exports: ["NewLogger", "NewLoggerWithWriter"]
    - path: "logger/module.go"
      provides: "NewModule providing logger.Config with flags"
      exports: ["NewModule"]
    - path: "logger/module_test.go"
      provides: "Comprehensive tests for module and config"
      min_lines: 100
  key_links:
    - from: "logger/module.go"
      to: "gaz.NewModule"
      via: "Flags(defaultCfg.Flags)"
      pattern: "gaz\\.NewModule.*Flags"
    - from: "logger/module.go"
      to: "logger/config.go"
      via: "Register logger.Config provider"
      pattern: "For\\[Config\\]"
    - from: "app.go"
      to: "logger/module.go"
      via: "Build() resolves logger.Config from container"
      pattern: "Resolve.*logger\\.Config"
---

<objective>
Create logger module that registers CLI flags and provides logger.Config to the container. The App (in Build()) will resolve this config and create the Logger.

Purpose: Enable users to configure logging via CLI flags (--log-level, --log-format, --log-output, --log-add-source). This depends on Plan 01 which deferred Logger creation to Build().

Output: Complete logger module with CLI flag support, validation, and comprehensive tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-logger-cli-flags/43-CONTEXT.md

# Prior plan summary (REQUIRED - this plan depends on it)
@.planning/phases/43-logger-cli-flags/43-01-SUMMARY.md

# Existing logger files to modify
@logger/config.go
@logger/provider.go

# Pattern to follow for module structure
@server/gateway/config.go
@server/gateway/module.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Config and Provider with CLI flag support</name>
  <files>logger/config.go, logger/provider.go</files>
  <action>
**Update logger/config.go:**

1. Add Output field to Config struct:
   ```go
   type Config struct {
       Level     slog.Level
       Format    string
       AddSource bool
       Output    string    // "stdout" (default), "stderr", or file path
       levelName string    // internal: used for flag binding
   }
   ```

2. Add DefaultConfig() function:
   ```go
   func DefaultConfig() Config {
       return Config{
           Level:     slog.LevelInfo,
           levelName: "info",
           Format:    "text",
           Output:    "stdout",
           AddSource: false,
       }
   }
   ```

3. Add Namespace() method:
   ```go
   func (c *Config) Namespace() string {
       return "log"
   }
   ```

4. Add Flags(fs *pflag.FlagSet) method:
   ```go
   func (c *Config) Flags(fs *pflag.FlagSet) {
       fs.StringVar(&c.levelName, "log-level", c.levelName, 
           "Log level: debug, info, warn, error")
       fs.StringVar(&c.Format, "log-format", c.Format, 
           "Log format: text, json")
       fs.StringVar(&c.Output, "log-output", c.Output, 
           "Log output: stdout, stderr, or file path")
       fs.BoolVar(&c.AddSource, "log-add-source", c.AddSource, 
           "Include source file:line in logs")
   }
   ```

5. Add Validate() error method:
   ```go
   func (c *Config) Validate() error {
       // Validate and convert levelName to Level
       level, err := parseLevel(c.levelName)
       if err != nil {
           return err
       }
       c.Level = level
       
       // Validate format
       if c.Format != "text" && c.Format != "json" {
           return fmt.Errorf("invalid log format %q: must be text or json", c.Format)
       }
       
       return nil
   }
   ```

6. Add SetDefaults() method:
   ```go
   func (c *Config) SetDefaults() {
       if c.Format == "" {
           c.Format = "text"
       }
       if c.Output == "" {
           c.Output = "stdout"
       }
       if c.levelName == "" {
           c.levelName = "info"
           c.Level = slog.LevelInfo
       }
   }
   ```

7. Add parseLevel helper:
   ```go
   func parseLevel(name string) (slog.Level, error) {
       switch name {
       case "debug":
           return slog.LevelDebug, nil
       case "info":
           return slog.LevelInfo, nil
       case "warn":
           return slog.LevelWarn, nil
       case "error":
           return slog.LevelError, nil
       default:
           return slog.LevelInfo, fmt.Errorf(
               "invalid log level %q: must be debug, info, warn, or error", name)
       }
   }
   ```

**Update logger/provider.go:**

1. Keep NewLogger(cfg *Config) signature but update to handle Output:
   ```go
   func NewLogger(cfg *Config) *slog.Logger {
       w := resolveOutput(cfg)
       return NewLoggerWithWriter(cfg, w)
   }
   ```

2. Add NewLoggerWithWriter for testing:
   ```go
   func NewLoggerWithWriter(cfg *Config, w io.Writer) *slog.Logger {
       lvl := new(slog.LevelVar)
       lvl.Set(cfg.Level)
       
       var handler slog.Handler
       if cfg.Format == "text" {
           handler = tint.NewHandler(w, &tint.Options{
               Level:      lvl,
               AddSource:  cfg.AddSource,
               TimeFormat: "15:04:05.000",
           })
       } else {
           handler = slog.NewJSONHandler(w, &slog.HandlerOptions{
               Level:     lvl,
               AddSource: cfg.AddSource,
           })
       }
       
       handler = NewContextHandler(handler)
       logger := slog.New(handler)
       slog.SetDefault(logger)
       return logger
   }
   ```

3. Add resolveOutput helper:
   ```go
   func resolveOutput(cfg *Config) io.Writer {
       switch cfg.Output {
       case "", "stdout":
           return os.Stdout
       case "stderr":
           return os.Stderr
       default:
           // File path - attempt to open
           f, err := os.OpenFile(cfg.Output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
           if err != nil {
               // Log warning to stderr and fall back to stdout
               fmt.Fprintf(os.Stderr, "logger: failed to open %s: %v, falling back to stdout\n", 
                   cfg.Output, err)
               return os.Stdout
           }
           return f
       }
   }
   ```

4. Add import for "io" package.
  </action>
  <verify>
go build ./logger/... && go vet ./logger/...
  </verify>
  <done>
Config has Output field, Flags(), Namespace(), Validate(), SetDefaults(), DefaultConfig().
NewLogger internally handles stdout/stderr/file output via resolveOutput().
NewLoggerWithWriter added for testing scenarios.
Invalid level/format returns descriptive error.
File open errors fall back to stdout with warning.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create logger module and comprehensive tests</name>
  <files>logger/module.go, logger/module_test.go</files>
  <action>
**Create logger/module.go:**

```go
package logger

import (
    "fmt"
    
    "github.com/petabytecl/gaz"
)

// NewModule creates a logger module that provides logger.Config with CLI flags.
// The App resolves this config in Build() to create the Logger.
//
// Usage:
//   app := gaz.New(gaz.WithCobra(rootCmd))
//   app.Use(logger.NewModule())
//
// Flags registered:
//   --log-level   Log level: debug, info, warn, error (default: info)
//   --log-format  Log format: text, json (default: text)
//   --log-output  Log output: stdout, stderr, or file path (default: stdout)
//   --log-add-source  Include source file:line in logs (default: false)
func NewModule() gaz.Module {
    defaultCfg := DefaultConfig()
    
    return gaz.NewModule("logger").
        Flags(defaultCfg.Flags).
        Provide(func(c *gaz.Container) error {
            return gaz.For[Config](c).Provider(func(c *gaz.Container) (Config, error) {
                cfg := defaultCfg
                
                // Try to load from config manager if available
                pv, err := gaz.Resolve[*gaz.ProviderValues](c)
                if err == nil {
                    if err := pv.UnmarshalKey(cfg.Namespace(), &cfg); err != nil {
                        return cfg, fmt.Errorf("unmarshal logger config: %w", err)
                    }
                }
                
                cfg.SetDefaults()
                if err := cfg.Validate(); err != nil {
                    return cfg, err
                }
                
                return cfg, nil
            })
        }).
        Build()
}
```

**Create logger/module_test.go:**

```go
package logger_test

import (
    "bytes"
    "os"
    "path/filepath"
    "testing"
    
    "github.com/spf13/pflag"
    "github.com/stretchr/testify/suite"
    
    "github.com/petabytecl/gaz"
    "github.com/petabytecl/gaz/logger"
)

type LoggerModuleTestSuite struct {
    suite.Suite
}

func TestLoggerModuleTestSuite(t *testing.T) {
    suite.Run(t, new(LoggerModuleTestSuite))
}

func (s *LoggerModuleTestSuite) TestModuleRegistration() {
    app := gaz.New()
    app.Use(logger.NewModule())
    
    err := app.Build()
    s.Require().NoError(err)
    
    // Config should be resolvable
    cfg, err := gaz.Resolve[logger.Config](app.Container())
    s.Require().NoError(err)
    
    // Check defaults
    s.Equal("text", cfg.Format)
    s.Equal("stdout", cfg.Output)
}

func (s *LoggerModuleTestSuite) TestDefaultConfig() {
    cfg := logger.DefaultConfig()
    
    s.Equal("info", cfg.LevelName())
    s.Equal("text", cfg.Format)
    s.Equal("stdout", cfg.Output)
    s.False(cfg.AddSource)
}

func (s *LoggerModuleTestSuite) TestConfigFlags() {
    cfg := logger.DefaultConfig()
    fs := pflag.NewFlagSet("test", pflag.ContinueOnError)
    cfg.Flags(fs)
    
    // Verify flags registered
    s.NotNil(fs.Lookup("log-level"))
    s.NotNil(fs.Lookup("log-format"))
    s.NotNil(fs.Lookup("log-output"))
    s.NotNil(fs.Lookup("log-add-source"))
    
    // Parse custom values
    err := fs.Parse([]string{
        "--log-level=debug",
        "--log-format=json",
        "--log-output=stderr",
        "--log-add-source",
    })
    s.Require().NoError(err)
    
    // Validate to convert levelName to Level
    err = cfg.Validate()
    s.Require().NoError(err)
    
    s.Equal("json", cfg.Format)
    s.Equal("stderr", cfg.Output)
    s.True(cfg.AddSource)
}

func (s *LoggerModuleTestSuite) TestConfigValidation_InvalidLevel() {
    cfg := logger.DefaultConfig()
    fs := pflag.NewFlagSet("test", pflag.ContinueOnError)
    cfg.Flags(fs)
    _ = fs.Parse([]string{"--log-level=trace"})
    
    err := cfg.Validate()
    s.Error(err)
    s.Contains(err.Error(), "invalid log level")
    s.Contains(err.Error(), "trace")
}

func (s *LoggerModuleTestSuite) TestConfigValidation_InvalidFormat() {
    cfg := logger.DefaultConfig()
    fs := pflag.NewFlagSet("test", pflag.ContinueOnError)
    cfg.Flags(fs)
    _ = fs.Parse([]string{"--log-format=yaml"})
    
    err := cfg.Validate()
    s.Error(err)
    s.Contains(err.Error(), "invalid log format")
    s.Contains(err.Error(), "yaml")
}

func (s *LoggerModuleTestSuite) TestOutputStdout() {
    cfg := logger.DefaultConfig()
    cfg.Output = "stdout"
    
    log := logger.NewLogger(&cfg)
    s.NotNil(log)
}

func (s *LoggerModuleTestSuite) TestOutputStderr() {
    cfg := logger.DefaultConfig()
    cfg.Output = "stderr"
    
    log := logger.NewLogger(&cfg)
    s.NotNil(log)
}

func (s *LoggerModuleTestSuite) TestOutputFile() {
    dir := s.T().TempDir()
    path := filepath.Join(dir, "test.log")
    
    cfg := logger.DefaultConfig()
    cfg.Output = path
    
    log := logger.NewLogger(&cfg)
    s.NotNil(log)
    
    // Write a log entry
    log.Info("test message")
    
    // Verify file exists and has content
    content, err := os.ReadFile(path)
    s.Require().NoError(err)
    s.Contains(string(content), "test message")
}

func (s *LoggerModuleTestSuite) TestOutputFileFallback() {
    cfg := logger.DefaultConfig()
    cfg.Output = "/nonexistent/directory/test.log"
    
    // Should not panic, should fall back to stdout
    log := logger.NewLogger(&cfg)
    s.NotNil(log)
}

func (s *LoggerModuleTestSuite) TestNewLoggerWithWriter() {
    var buf bytes.Buffer
    cfg := logger.DefaultConfig()
    cfg.Format = "json"
    
    log := logger.NewLoggerWithWriter(&cfg, &buf)
    log.Info("test message")
    
    s.Contains(buf.String(), "test message")
}

func (s *LoggerModuleTestSuite) TestAllLevels() {
    levels := []string{"debug", "info", "warn", "error"}
    for _, level := range levels {
        cfg := logger.DefaultConfig()
        fs := pflag.NewFlagSet("test", pflag.ContinueOnError)
        cfg.Flags(fs)
        _ = fs.Parse([]string{"--log-level=" + level})
        
        err := cfg.Validate()
        s.NoError(err, "level %s should be valid", level)
    }
}
```

Note: You may need to add a `LevelName()` accessor method to Config:
```go
func (c *Config) LevelName() string {
    return c.levelName
}
```
  </action>
  <verify>
go test -race -v ./logger/... && make lint
  </verify>
  <done>
NewModule() creates a gaz.Module that provides logger.Config.
Module registers --log-level, --log-format, --log-output, --log-add-source flags.
All tests pass including config validation, flag binding, and output destinations.
Linter passes with no errors.
  </done>
</task>

</tasks>

<verification>
```bash
# Build and vet
go build ./logger/...
go vet ./logger/...

# Run tests with race detection
go test -race -v ./logger/...

# Run linter
make lint

# Integration test: verify with example
cd examples/grpc-gateway
go build -o /dev/null .
```
</verification>

<success_criteria>
- [ ] Config has Output field, Flags(), Namespace(), Validate(), SetDefaults()
- [ ] DefaultConfig() returns sensible defaults (level=info, format=text, output=stdout)
- [ ] NewLogger internally handles stdout/stderr/file output
- [ ] File output errors fall back to stdout with warning (not panic)
- [ ] NewLoggerWithWriter allows custom io.Writer for testing
- [ ] NewModule() returns gaz.Module providing logger.Config
- [ ] Invalid level (e.g., "trace") returns error with valid options listed
- [ ] Invalid format (e.g., "yaml") returns error with valid options listed
- [ ] All tests pass with race detection
- [ ] Linter passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/43-logger-cli-flags/43-02-SUMMARY.md`
</output>
