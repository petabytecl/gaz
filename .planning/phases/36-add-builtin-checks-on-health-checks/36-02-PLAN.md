---
phase: 36-add-builtin-checks
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - health/checks/tcp/tcp.go
  - health/checks/tcp/tcp_test.go
  - health/checks/dns/dns.go
  - health/checks/dns/dns_test.go
autonomous: true

must_haves:
  truths:
    - "Developer can create TCP dial check by providing host:port"
    - "Developer can create DNS resolution check by providing hostname"
    - "TCP check respects context deadline"
    - "DNS check respects context deadline"
  artifacts:
    - path: "health/checks/tcp/tcp.go"
      provides: "TCP dial health check factory"
      exports: ["Config", "New"]
    - path: "health/checks/dns/dns.go"
      provides: "DNS resolution health check factory"
      exports: ["Config", "New"]
  key_links:
    - from: "health/checks/tcp/tcp.go"
      to: "net"
      via: "net.Dialer.DialContext"
      pattern: "DialContext"
    - from: "health/checks/dns/dns.go"
      to: "net"
      via: "net.Resolver.LookupHost"
      pattern: "LookupHost"
---

<objective>
Create TCP and DNS connectivity health checks using stdlib net package.

Purpose: Provide generic connectivity checks for TCP services and DNS resolution verification.
Output: health/checks/tcp/ and health/checks/dns/ subpackages with Config + New factories
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-add-builtin-checks-on-health-checks/36-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TCP dial check</name>
  <files>health/checks/tcp/tcp.go, health/checks/tcp/tcp_test.go</files>
  <action>
Create health/checks/tcp/tcp.go:

```go
// Package tcp provides a health check for TCP port connectivity.
package tcp

import (
    "context"
    "fmt"
    "net"
    "time"
)

// Config configures the TCP dial health check.
type Config struct {
    // Addr is the address to dial (host:port). Required.
    Addr string
    // Timeout for the dial operation. Optional, defaults to 2s.
    // The context deadline takes precedence if shorter.
    Timeout time.Duration
}

// New creates a new TCP dial health check.
// Verifies TCP connectivity by establishing and immediately closing a connection.
//
// Returns nil if connection succeeds, error if dial fails.
func New(cfg Config) func(context.Context) error {
    if cfg.Timeout == 0 {
        cfg.Timeout = 2 * time.Second
    }
    
    return func(ctx context.Context) error {
        if cfg.Addr == "" {
            return fmt.Errorf("tcp: address is empty")
        }
        
        var d net.Dialer
        d.Timeout = cfg.Timeout
        
        conn, err := d.DialContext(ctx, "tcp", cfg.Addr)
        if err != nil {
            return fmt.Errorf("tcp: dial failed: %w", err)
        }
        return conn.Close()
    }
}
```

Create tests that:
1. Test empty address returns error
2. Test successful connection (use net.Listen to create test server)
3. Test connection failure to invalid port
4. Test context cancellation
  </action>
  <verify>go test -v ./health/checks/tcp/...</verify>
  <done>TCP check connects and closes connection, returns error on failure</done>
</task>

<task type="auto">
  <name>Task 2: Implement DNS resolution check</name>
  <files>health/checks/dns/dns.go, health/checks/dns/dns_test.go</files>
  <action>
Create health/checks/dns/dns.go:

```go
// Package dns provides a health check for DNS hostname resolution.
package dns

import (
    "context"
    "fmt"
    "net"
    "time"
)

// Config configures the DNS resolution health check.
type Config struct {
    // Host is the hostname to resolve. Required.
    Host string
    // Timeout for the resolution. Optional, defaults to 2s.
    // The context deadline takes precedence if shorter.
    Timeout time.Duration
}

// New creates a new DNS resolution health check.
// Verifies DNS resolution by looking up the hostname.
//
// Returns nil if resolution succeeds with at least one address, error otherwise.
func New(cfg Config) func(context.Context) error {
    if cfg.Timeout == 0 {
        cfg.Timeout = 2 * time.Second
    }
    
    resolver := &net.Resolver{}
    
    return func(ctx context.Context) error {
        if cfg.Host == "" {
            return fmt.Errorf("dns: hostname is empty")
        }
        
        ctx, cancel := context.WithTimeout(ctx, cfg.Timeout)
        defer cancel()
        
        addrs, err := resolver.LookupHost(ctx, cfg.Host)
        if err != nil {
            return fmt.Errorf("dns: lookup failed: %w", err)
        }
        if len(addrs) == 0 {
            return fmt.Errorf("dns: no addresses found for %s", cfg.Host)
        }
        return nil
    }
}
```

Create tests that:
1. Test empty hostname returns error
2. Test successful resolution (use "localhost" as it always resolves)
3. Test resolution failure for non-existent domain
4. Test context timeout
  </action>
  <verify>go test -v ./health/checks/dns/...</verify>
  <done>DNS check resolves hostname, returns error if no addresses found</done>
</task>

</tasks>

<verification>
```bash
# Run all tests
go test -v ./health/checks/tcp/... ./health/checks/dns/...

# Verify builds
go build ./health/checks/...
```
</verification>

<success_criteria>
- health/checks/tcp/tcp.go exports Config and New
- health/checks/dns/dns.go exports Config and New
- TCP check uses DialContext with configurable timeout
- DNS check uses LookupHost with configurable timeout
- Both respect context cancellation
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/36-add-builtin-checks-on-health-checks/36-02-SUMMARY.md`
</output>
