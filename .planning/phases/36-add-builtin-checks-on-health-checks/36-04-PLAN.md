---
phase: 36-add-builtin-checks
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - health/checks/runtime/runtime.go
  - health/checks/runtime/runtime_test.go
autonomous: true

must_haves:
  truths:
    - "Developer can create goroutine count threshold check"
    - "Developer can create memory usage threshold check"
    - "Developer can create GC pause threshold check"
    - "All runtime checks return error when threshold exceeded"
  artifacts:
    - path: "health/checks/runtime/runtime.go"
      provides: "Runtime metrics health checks"
      exports: ["GoroutineCount", "MemoryUsage", "GCPause"]
    - path: "health/checks/runtime/runtime_test.go"
      provides: "Runtime checks tests"
      min_lines: 50
  key_links:
    - from: "health/checks/runtime/runtime.go"
      to: "runtime"
      via: "runtime.NumGoroutine, runtime.ReadMemStats"
      pattern: "(NumGoroutine|ReadMemStats)"
---

<objective>
Create runtime metrics health checks for Go process monitoring.

Purpose: Provide checks for detecting goroutine leaks, memory issues, and GC pressure - useful for liveness probes.
Output: health/checks/runtime/ subpackage with GoroutineCount, MemoryUsage, GCPause factories
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-add-builtin-checks-on-health-checks/36-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement runtime checks</name>
  <files>health/checks/runtime/runtime.go</files>
  <action>
Create health/checks/runtime/runtime.go:

```go
// Package runtime provides health checks based on Go runtime metrics.
// These checks are useful for liveness probes to detect resource exhaustion.
package runtime

import (
    "context"
    "fmt"
    "runtime"
    "time"
)

// GoroutineCount returns a check that fails if goroutine count exceeds threshold.
// Useful for detecting goroutine leaks which lead to resource exhaustion.
//
// Example threshold: 1000 for a typical web service.
func GoroutineCount(threshold int) func(context.Context) error {
    return func(ctx context.Context) error {
        count := runtime.NumGoroutine()
        if count > threshold {
            return fmt.Errorf("runtime: too many goroutines (%d > %d)", count, threshold)
        }
        return nil
    }
}

// MemoryUsage returns a check that fails if heap allocation exceeds threshold.
// Threshold is in bytes. Useful for detecting memory leaks before OOM.
//
// Example threshold: 1<<30 (1GB) for a typical web service.
func MemoryUsage(threshold uint64) func(context.Context) error {
    return func(ctx context.Context) error {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        if m.Alloc > threshold {
            return fmt.Errorf("runtime: memory usage too high (%d bytes > %d bytes)", 
                m.Alloc, threshold)
        }
        return nil
    }
}

// GCPause returns a check that fails if any recent GC pause exceeds threshold.
// Useful for detecting GC pressure that affects latency-sensitive applications.
//
// Example threshold: 100*time.Millisecond for latency-sensitive services.
func GCPause(threshold time.Duration) func(context.Context) error {
    thresholdNs := uint64(threshold.Nanoseconds())
    return func(ctx context.Context) error {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        
        // Check the most recent GC pause (PauseNs is a circular buffer)
        // NumGC is total GC cycles, PauseNs[(NumGC+255)%256] is most recent
        if m.NumGC > 0 {
            idx := (m.NumGC + 255) % 256
            if m.PauseNs[idx] > thresholdNs {
                return fmt.Errorf("runtime: GC pause too long (%s > %s)", 
                    time.Duration(m.PauseNs[idx]), threshold)
            }
        }
        return nil
    }
}
```

Key implementation notes:
- GoroutineCount uses runtime.NumGoroutine() which is cheap
- MemoryUsage uses runtime.ReadMemStats() which has some overhead
- GCPause checks only the most recent GC cycle (not all 256 in buffer)
- All functions accept threshold to avoid hardcoding limits
  </action>
  <verify>go build ./health/checks/runtime/...</verify>
  <done>Runtime checks compile with correct signatures</done>
</task>

<task type="auto">
  <name>Task 2: Add runtime checks tests</name>
  <files>health/checks/runtime/runtime_test.go</files>
  <action>
Create health/checks/runtime/runtime_test.go with tests:

1. **GoroutineCount tests:**
   - Test passes when under threshold (use current count + 100)
   - Test fails when over threshold (use 1 as threshold - guaranteed to fail)

2. **MemoryUsage tests:**
   - Test passes when under threshold (use large threshold like 10GB)
   - Test fails when over threshold (use 1 byte threshold - guaranteed to fail)

3. **GCPause tests:**
   - Test passes with high threshold (1 hour - any pause is shorter)
   - Note: Can't easily force a long GC pause in tests

4. **Context cancellation:**
   - Verify checks return immediately (they don't block)
   - Context is passed but these checks don't use it (they're CPU-bound)

Tests should be deterministic by using extreme thresholds.
  </action>
  <verify>go test -v ./health/checks/runtime/...</verify>
  <done>Runtime checks return error when threshold exceeded, all tests pass</done>
</task>

</tasks>

<verification>
```bash
# Run tests
go test -v ./health/checks/runtime/...

# Verify no race conditions (ReadMemStats is safe)
go test -race ./health/checks/runtime/...
```
</verification>

<success_criteria>
- health/checks/runtime/runtime.go exports GoroutineCount, MemoryUsage, GCPause
- Each function accepts threshold and returns func(context.Context) error
- GoroutineCount uses runtime.NumGoroutine()
- MemoryUsage uses runtime.ReadMemStats().Alloc
- GCPause checks most recent GC pause
- Tests verify threshold behavior
</success_criteria>

<output>
After completion, create `.planning/phases/36-add-builtin-checks-on-health-checks/36-04-SUMMARY.md`
</output>
