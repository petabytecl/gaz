---
phase: 36-add-builtin-checks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - health/checks/doc.go
  - health/checks/sql/sql.go
  - health/checks/sql/sql_test.go
autonomous: true

must_haves:
  truths:
    - "Developer can create SQL database health check by passing *sql.DB"
    - "SQL check uses PingContext for optimal connection testing"
    - "SQL check returns nil if healthy, error if unhealthy"
  artifacts:
    - path: "health/checks/doc.go"
      provides: "Package documentation for health/checks"
      min_lines: 10
    - path: "health/checks/sql/sql.go"
      provides: "SQL database health check factory"
      exports: ["Config", "New"]
    - path: "health/checks/sql/sql_test.go"
      provides: "SQL check tests"
      min_lines: 30
  key_links:
    - from: "health/checks/sql/sql.go"
      to: "database/sql"
      via: "db.PingContext(ctx)"
      pattern: "PingContext"
---

<objective>
Create the health/checks package foundation and SQL database health check.

Purpose: Establish the package structure and implement the highest-priority check (P0) that every database-backed application needs.
Output: health/checks/doc.go, health/checks/sql/sql.go with Config + New factory
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-add-builtin-checks-on-health-checks/36-RESEARCH.md
@health/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create package foundation</name>
  <files>health/checks/doc.go</files>
  <action>
Create health/checks/doc.go with package documentation:

```go
// Package checks provides reusable health check implementations for common
// infrastructure dependencies.
//
// Each subpackage provides a Config struct and New() factory function that
// returns a health check function compatible with health.CheckFunc:
//
//	func(context.Context) error
//
// Example usage with the health package:
//
//	import (
//	    "github.com/petabytecl/gaz/health"
//	    checksql "github.com/petabytecl/gaz/health/checks/sql"
//	)
//
//	func main() {
//	    db, _ := sql.Open("postgres", dsn)
//	    
//	    registrar.AddReadinessCheck("database", checksql.New(checksql.Config{
//	        DB: db,
//	    }))
//	}
//
// Available check packages:
//   - sql: SQL database connectivity (database/sql)
//   - tcp: TCP port connectivity
//   - dns: DNS hostname resolution
//   - http: HTTP upstream availability
//   - runtime: Go runtime metrics (goroutines, memory, GC)
//   - redis: Redis connectivity (requires go-redis/v9)
//   - disk: Disk space monitoring (requires gopsutil/v4)
package checks
```

Use import alias `checksql` in examples to avoid collision with `database/sql`.
  </action>
  <verify>go build ./health/checks/...</verify>
  <done>health/checks/doc.go exists and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement SQL database check</name>
  <files>health/checks/sql/sql.go, health/checks/sql/sql_test.go</files>
  <action>
Create health/checks/sql/sql.go:

```go
// Package sql provides a health check for SQL databases using database/sql.
package sql

import (
    "context"
    "database/sql"
    "fmt"
)

// Config configures the SQL database health check.
type Config struct {
    // DB is the database connection pool to check. Required.
    DB *sql.DB
}

// New creates a new SQL database health check.
// Uses PingContext which is optimized for connection testing and respects
// the context deadline.
//
// Returns nil if healthy (ping succeeds), error if unhealthy.
func New(cfg Config) func(context.Context) error {
    return func(ctx context.Context) error {
        if cfg.DB == nil {
            return fmt.Errorf("sql: database connection is nil")
        }
        if err := cfg.DB.PingContext(ctx); err != nil {
            return fmt.Errorf("sql: ping failed: %w", err)
        }
        return nil
    }
}
```

Create health/checks/sql/sql_test.go with tests:
1. Test nil DB returns error
2. Test successful ping with mock driver
3. Test ping failure propagates error
4. Test context cancellation is respected

Use `database/sql/driver` to create a minimal test driver, or use a simple in-memory approach. Keep tests simple without external test dependencies.
  </action>
  <verify>go test -v ./health/checks/sql/...</verify>
  <done>SQL check returns nil for healthy, error for unhealthy or nil DB</done>
</task>

</tasks>

<verification>
```bash
# Build all check packages
go build ./health/checks/...

# Run SQL check tests
go test -v ./health/checks/sql/...

# Verify function signature matches health.CheckFunc
go vet ./health/checks/sql/...
```
</verification>

<success_criteria>
- health/checks/doc.go exists with package documentation
- health/checks/sql/sql.go exports Config struct and New function
- New returns `func(context.Context) error` matching health.CheckFunc
- Tests pass for nil DB, success, and failure cases
- `go build ./health/checks/...` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/36-add-builtin-checks-on-health-checks/36-01-SUMMARY.md`
</output>
