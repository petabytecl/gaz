---
phase: 36-add-builtin-checks
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - health/checks/http/http.go
  - health/checks/http/http_test.go
autonomous: true

must_haves:
  truths:
    - "Developer can create HTTP upstream check by providing URL"
    - "HTTP check validates response status code"
    - "HTTP check respects context deadline"
    - "HTTP check has configurable expected status code"
  artifacts:
    - path: "health/checks/http/http.go"
      provides: "HTTP upstream health check factory"
      exports: ["Config", "New"]
    - path: "health/checks/http/http_test.go"
      provides: "HTTP check tests"
      min_lines: 50
  key_links:
    - from: "health/checks/http/http.go"
      to: "net/http"
      via: "http.Client.Do with NewRequestWithContext"
      pattern: "NewRequestWithContext"
---

<objective>
Create HTTP upstream health check using stdlib net/http package.

Purpose: Provide a check for HTTP-based dependencies (APIs, microservices) with configurable status code validation.
Output: health/checks/http/ subpackage with Config + New factory
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-add-builtin-checks-on-health-checks/36-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HTTP upstream check</name>
  <files>health/checks/http/http.go</files>
  <action>
Create health/checks/http/http.go:

```go
// Package http provides a health check for HTTP upstream services.
package http

import (
    "context"
    "fmt"
    "net/http"
    "time"
)

// Config configures the HTTP upstream health check.
type Config struct {
    // URL is the health check endpoint URL. Required.
    URL string
    // Timeout for the HTTP request. Optional, defaults to 5s.
    // The context deadline takes precedence if shorter.
    Timeout time.Duration
    // ExpectedStatusCode is the expected response status. Optional, defaults to 200.
    ExpectedStatusCode int
    // Client is the HTTP client to use. Optional, a default client is created.
    // Providing a custom client allows reusing connection pools and custom TLS config.
    Client *http.Client
}

// New creates a new HTTP upstream health check.
// Performs GET request and validates response status code.
//
// Returns nil if response matches expected status, error otherwise.
func New(cfg Config) func(context.Context) error {
    if cfg.Timeout == 0 {
        cfg.Timeout = 5 * time.Second
    }
    if cfg.ExpectedStatusCode == 0 {
        cfg.ExpectedStatusCode = http.StatusOK
    }
    
    client := cfg.Client
    if client == nil {
        client = &http.Client{
            Timeout: cfg.Timeout,
            CheckRedirect: func(*http.Request, []*http.Request) error {
                return http.ErrUseLastResponse // Don't follow redirects
            },
        }
    }
    
    return func(ctx context.Context) error {
        if cfg.URL == "" {
            return fmt.Errorf("http: URL is empty")
        }
        
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, cfg.URL, nil)
        if err != nil {
            return fmt.Errorf("http: failed to create request: %w", err)
        }
        req.Header.Set("Connection", "close")
        
        resp, err := client.Do(req)
        if err != nil {
            return fmt.Errorf("http: request failed: %w", err)
        }
        defer resp.Body.Close()
        
        if resp.StatusCode != cfg.ExpectedStatusCode {
            return fmt.Errorf("http: unexpected status %d (expected %d)", 
                resp.StatusCode, cfg.ExpectedStatusCode)
        }
        return nil
    }
}
```

Key implementation details:
- Default timeout 5s (HTTP requests take longer than TCP dials)
- Don't follow redirects by default (health endpoints shouldn't redirect)
- Set Connection: close to avoid holding connections
- Allow custom client for connection pool reuse
  </action>
  <verify>go build ./health/checks/http/...</verify>
  <done>HTTP check implementation compiles</done>
</task>

<task type="auto">
  <name>Task 2: Add HTTP check tests</name>
  <files>health/checks/http/http_test.go</files>
  <action>
Create health/checks/http/http_test.go with tests using httptest.NewServer:

1. Test empty URL returns error
2. Test successful response (200 OK)
3. Test custom expected status code (e.g., 204)
4. Test unexpected status code returns error
5. Test connection failure (server not listening)
6. Test context cancellation
7. Test custom client is used when provided

Use httptest.NewServer to create test servers that return specific status codes.
  </action>
  <verify>go test -v ./health/checks/http/...</verify>
  <done>HTTP check validates status codes, all tests pass</done>
</task>

</tasks>

<verification>
```bash
# Run tests with verbose output
go test -v ./health/checks/http/...

# Verify no race conditions
go test -race ./health/checks/http/...
```
</verification>

<success_criteria>
- health/checks/http/http.go exports Config and New
- Config has URL, Timeout, ExpectedStatusCode, Client fields
- New creates check that validates HTTP response status
- Default timeout is 5s, default expected status is 200
- Tests cover success, failure, custom status, and timeout cases
</success_criteria>

<output>
After completion, create `.planning/phases/36-add-builtin-checks-on-health-checks/36-03-SUMMARY.md`
</output>
